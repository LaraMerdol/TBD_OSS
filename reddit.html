<meta http-equiv="Content-Type" content="text/html; charset=utf-8"><link type="text/css" rel="stylesheet" href="resources/sheet.css" >
<style type="text/css">.ritz .waffle a { color: inherit; }.ritz .waffle .s6{border-bottom:1px SOLID #f6f8f9;border-right:1px SOLID #ffffff;background-color:#ffffff;text-align:center;color:#434343;font-family:docs-Roboto,Arial;font-size:10pt;vertical-align:middle;white-space:nowrap;overflow:hidden;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s14{border-bottom:1px SOLID #284e3f;border-right:1px SOLID #ffffff;background-color:#ffffff;text-align:left;color:#434343;font-family:docs-Roboto,Arial;font-size:10pt;vertical-align:middle;white-space:nowrap;overflow:hidden;direction:ltr;padding:2px 8px 2px 8px;}.ritz .waffle .s12{border-bottom:1px SOLID #f6f8f9;border-right:1px SOLID #284e3f;background-color:#f6f8f9;text-align:left;color:#434343;font-family:docs-Roboto,Arial;font-size:10pt;vertical-align:middle;white-space:nowrap;overflow:hidden;direction:ltr;padding:2px 8px 2px 8px;}.ritz .waffle .s7{border-bottom:1px SOLID #f6f8f9;border-right:1px SOLID #284e3f;background-color:#ffffff;text-align:left;color:#434343;font-family:docs-Roboto,Arial;font-size:10pt;vertical-align:middle;white-space:nowrap;overflow:hidden;direction:ltr;padding:2px 8px 2px 8px;}.ritz .waffle .s10{border-bottom:1px SOLID #f6f8f9;border-right:1px SOLID #f6f8f9;background-color:#f6f8f9;text-align:left;text-decoration:underline;text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#434343;font-family:docs-Roboto,Arial;font-size:10pt;vertical-align:middle;white-space:nowrap;overflow:hidden;direction:ltr;padding:2px 8px 2px 8px;}.ritz .waffle .s8{border-bottom:1px SOLID #f6f8f9;border-right:1px SOLID #f6f8f9;background-color:#f6f8f9;text-align:left;color:#434343;font-family:docs-Roboto,Arial;font-size:10pt;vertical-align:middle;white-space:nowrap;overflow:hidden;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s11{border-bottom:1px SOLID #f6f8f9;border-right:1px SOLID #f6f8f9;background-color:#f6f8f9;text-align:center;color:#434343;font-family:docs-Roboto,Arial;font-size:10pt;vertical-align:middle;white-space:nowrap;overflow:hidden;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s5{border-bottom:1px SOLID #f6f8f9;border-right:1px SOLID #ffffff;background-color:#ffffff;text-align:left;text-decoration:underline;text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#434343;font-family:docs-Roboto,Arial;font-size:10pt;vertical-align:middle;white-space:nowrap;overflow:hidden;direction:ltr;padding:2px 8px 2px 8px;}.ritz .waffle .s0{border-bottom:1px SOLID #284e3f;border-right:1px SOLID #356854;background-color:#356854;text-align:left;color:#ffffff;font-family:docs-Roboto,Arial;font-size:10pt;vertical-align:middle;white-space:nowrap;overflow:hidden;direction:ltr;padding:2px 8px 2px 8px;}.ritz .waffle .s3{text-overflow:ellipsis;overflow:hidden;vertical-align:top;display:inline-block;height:fit-content;border-radius:8px;}.ritz .waffle .s13{border-bottom:1px SOLID #284e3f;border-right:1px SOLID #ffffff;background-color:#ffffff;text-align:left;color:#434343;font-family:docs-Roboto,Arial;font-size:10pt;vertical-align:middle;white-space:nowrap;overflow:hidden;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s15{border-bottom:1px SOLID #284e3f;border-right:1px SOLID #ffffff;background-color:#ffffff;text-align:left;text-decoration:underline;text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#434343;font-family:docs-Roboto,Arial;font-size:10pt;vertical-align:middle;white-space:nowrap;overflow:hidden;direction:ltr;padding:2px 8px 2px 8px;}.ritz .waffle .s2{border-bottom:1px SOLID #f6f8f9;border-right:1px SOLID #ffffff;background-color:#ffffff;text-align:left;color:#434343;font-family:docs-Roboto,Arial;font-size:10pt;vertical-align:middle;white-space:nowrap;overflow:hidden;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s4{border-bottom:1px SOLID #f6f8f9;border-right:1px SOLID #ffffff;background-color:#ffffff;text-align:left;color:#434343;font-family:docs-Roboto,Arial;font-size:10pt;vertical-align:middle;white-space:nowrap;overflow:hidden;direction:ltr;padding:2px 8px 2px 8px;}.ritz .waffle .s16{border-bottom:1px SOLID #284e3f;border-right:1px SOLID #ffffff;background-color:#ffffff;text-align:center;color:#434343;font-family:docs-Roboto,Arial;font-size:10pt;vertical-align:middle;white-space:nowrap;overflow:hidden;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s1{border-bottom:1px SOLID #284e3f;border-right:1px SOLID #284e3f;background-color:#356854;text-align:left;color:#ffffff;font-family:docs-Roboto,Arial;font-size:10pt;vertical-align:middle;white-space:nowrap;overflow:hidden;direction:ltr;padding:2px 8px 2px 8px;}.ritz .waffle .s17{border-bottom:1px SOLID #284e3f;border-right:1px SOLID #284e3f;background-color:#ffffff;text-align:left;color:#434343;font-family:docs-Roboto,Arial;font-size:10pt;vertical-align:middle;white-space:nowrap;overflow:hidden;direction:ltr;padding:2px 8px 2px 8px;}.ritz .waffle .s9{border-bottom:1px SOLID #f6f8f9;border-right:1px SOLID #f6f8f9;background-color:#f6f8f9;text-align:left;color:#434343;font-family:docs-Roboto,Arial;font-size:10pt;vertical-align:middle;white-space:nowrap;overflow:hidden;direction:ltr;padding:2px 8px 2px 8px;}</style><div class="ritz grid-container" dir="ltr"><table class="waffle" cellspacing="0" cellpadding="0"><thead><tr><th class="row-header freezebar-vertical-handle"></th><th id="958685326C0" style="width:175px;" class="column-headers-background">A</th><th id="958685326C1" style="width:300px;" class="column-headers-background">B</th><th id="958685326C2" style="width:300px;" class="column-headers-background">C</th><th id="958685326C3" style="width:300px;" class="column-headers-background">D</th><th id="958685326C4" style="width:156px;" class="column-headers-background">E</th><th id="958685326C5" style="width:300px;" class="column-headers-background">F</th><th id="958685326C6" style="width:300px;" class="column-headers-background">G</th></tr></thead><tbody><tr style="height: 30px"><th id="958685326R0" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">1</div></th><td class="s0" dir="ltr"><div style="display:flex; vertical-align:middle"><svg width="1.25em" viewBox="0 0 20 20" style="display: inline; padding-right: max(6px, 0.25em)"><g id="dropdown-table-header-icon"><path d="M15 9L12 12L9 9H15Z" fill="#ffffff"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M7 4H13C16.31 4 19 6.69 19 10C19 13.31 16.31 16 13 16H7C3.69 16 1 13.31 1 10C1 6.69 3.69 4 7 4ZM7 14.5H13C15.48 14.5 17.5 12.48 17.5 10C17.5 7.52 15.48 5.5 13 5.5H7C4.52 5.5 2.5 7.52 2.5 10C2.5 12.48 4.52 14.5 7 14.5Z" fill="#ffffff"></path></g></svg><div>subreddit</div></div></td><td class="s0" dir="ltr">title</td><td class="s0" dir="ltr">OSS-related?</td><td class="s0" dir="ltr">url</td><td class="s0" dir="ltr"><div style="display:flex; vertical-align:middle"><svg width="1.25em" viewBox="0 0 20 20" style="display: inline; padding-right: max(6px, 0.25em)"><g id="dropdown-table-header-icon"><path d="M15 9L12 12L9 9H15Z" fill="#ffffff"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M7 4H13C16.31 4 19 6.69 19 10C19 13.31 16.31 16 13 16H7C3.69 16 1 13.31 1 10C1 6.69 3.69 4 7 4ZM7 14.5H13C15.48 14.5 17.5 12.48 17.5 10C17.5 7.52 15.48 5.5 13 5.5H7C4.52 5.5 2.5 7.52 2.5 10C2.5 12.48 4.52 14.5 7 14.5Z" fill="#ffffff"></path></g></svg><div>OSS-related?.1</div></div></td><td class="s0" dir="ltr">discussion_items</td><td class="s1" dir="ltr">CODES</td></tr><tr><th style="height:3px;" class="freezebar-cell freezebar-horizontal-handle"></th><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td></tr><tr style="height: 30px"><th id="958685326R1" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">2</div></th><td class="s2" dir="ltr"><span class="s3" style="background-color: #dce9cb; color: #2c481f; width: 147.0px; max-width: 147.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">git</span></td><td class="s4" dir="ltr">A possible n00b question about merges and merge conflicts</td><td class="s5" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/git/comments/wlc8cv/a_possible_n00b_question_about_merges_and_merge/">https://www.reddit.com/r/git/comments/wlc8cv/a_possible_n00b_question_about_merges_and_merge/</a></td><td class="s5" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/git/comments/wlc8cv/a_possible_n00b_question_about_merges_and_merge/">https://www.reddit.com/r/git/comments/wlc8cv/a_possible_n00b_question_about_merges_and_merge/</a></td><td class="s6" dir="ltr"><span class="s3" style="background-color: #d5deeb; color: #383a3c; width: 128.0px; max-width: 128.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">YANLIŞ</span></td><td class="s4" dir="ltr">[&#39;A possible n00b question about merges and merge conflicts (new)&#39;, &#39;I\&#39;ve got a question about an issue that I run into over and over, and I just haven\&#39;t found the answer yet.  This is possibly a n00b question, please forgive me if it is.\n\n  I work in an environment that\&#39;s trunk based, rather than git flow based.  We have main, staging, and whatever feature branches we\&#39;re working on.  Branches get created from main, get merged into staging for testing, then get merged back into main once approved.\n\n  Now, lets say I have two folders, Folder A and Folder B.  They each have several files in them.  For the sake of this example, I know that they\&#39;re completely isolated from each other, and that functionality in one is not dependent upon functionality in the other.\n\n  I need to change code in Folder B, so I branch off of main, make one single change to one single file, then commit and push.\n\n  I then try to merge to staging, only to find that someone else has merged a branch that changed every file in Folder A.  So now I have to deal with merge conflicts from files I never even touched.\n\n  To me, it feels like since my personal delta from my commit is only one file, it should go into staging with no problems, and I shouldn\&#39;t have to deal with all the other changes.  But as I\&#39;ve found out multiple times, that\&#39;s not the case.\n\n  I know I can just &quot;accept all incoming&quot; on the merge conflicts since I know I haven\&#39;t changed anything.  And, I know I can merge staging into my branch first, before I try to merge my branch into staging, but it feels like I\&#39;ll get the same merge conflicts and still have to deal with all that.\n\n  Is there a different way that I should be merging, to avoid conflicts with files I never changed?  Or should I just accept all incoming?&#39;, &#39;Whoever touched Folder A didn\&#39;t follow process. That\&#39;s the only way I can think of that you\&#39;d end up with merge conflicts in the way you described.\n\nI.e. they\&#39;ve got code in main that they never merged to staging.\n\nThis sounds like a &quot;them&quot; problem. (new)&#39;, &quot;How so? Let&#39;s say a coworker branches off main at the same time I do. He updates everything in Folder A, then merges his changes into the staging branch, before I merge my own Folder B change. (new)&quot;, &quot;Unless something is horribly wrong, *you should not be getting merge conflicts*. Something is very very wrong with the way your company&#39;s branches are set up.\n\nWhat you&#39;re describing *should not happen*. (new)&quot;, &quot;I&#39;m probably to blame, since I&#39;m the common denominator.  It&#39;s at least good to know that my gut reaction is right, that I shouldn&#39;t be dealing with conflicts on files I didn&#39;t touch.  Now I just have to figure out what mistake I&#39;m making that causes the issues.\n\n  Thanks for the advice and for setting me straight! (new)&quot;, &#39;Don’t be too hard on yourself just because you don’t see the problem. \n\nSometimes the only difference between a junior and a senior dev is that the senior one won’t mind risking publicly being called stupid for having made a stupid mistake. 😂 \n\nAsk your teammates what’s going on. (new)&#39;, &quot;It&#39;s hard to say, without a lot more detail. However, repeatedly getting merge conflicts definitely means that something&#39;s breaking down somewhere.\n\nA merge conflict means that there&#39;s a commit in the branch you&#39;re merging, that is not in the branch you&#39;re merging *to*, and which specifically conflicts with the changes that are in that branch.\n\nOnce the conflict is resolved, *that* commit should not conflict again.\n\nThings that could cause repeated conflicts:\n\n* Is someone rebasing commits that have already been pushed to the remote?\n* As I mentioned before, is someone letting main and staging diverge? (Merging to main without going through staging.)\n\nI&#39;d recommend reading up on how git works, since it&#39;s way too long for a reddit post. But in a nutshell, everything in git works off of hashes that are calculated when the commit is made. Git doesn&#39;t really track files, it tracks changes - down to the individual line level. But once a change is in its log, it doesn&#39;t have to worry about that change again.\n\nWhat&#39;s happening in your case is that there&#39;s a commit somewhere that is not in the log for staging, the changes in that commit touch files in Folder A, and they conflict with someone else&#39;s changes.\n\nNow, normally, once you resolved that conflict, that commit would now be in the log, and git wouldn&#39;t worry about it anymore.\n\nY&#39;know, the rebase situation is sounding more and more plausible. Rebase replays *changes* on top of existing commits, which means that the hashes change for the new commits. So the old commit hashes aren&#39;t part of the log, which means git thinks it needs to apply them. (new)&quot;]</td><td class="s7" dir="ltr">[&#39;Use a single shared trunk&#39;, &#39;Use short-lived branches&#39;, &#39;Reduce merge conflicts (+)&#39;, &#39;Promote frequent and rapid integration (CI) (+)&#39;]</td></tr><tr style="height: 30px"><th id="958685326R2" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">3</div></th><td class="s8" dir="ltr"><span class="s3" style="background-color: #dce9cb; color: #2c481f; width: 147.0px; max-width: 147.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">git</span></td><td class="s9" dir="ltr">Any recommendations for a simple pain free git workflow for 2 developers?</td><td class="s10" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/git/comments/l4b2m1/any_recommendations_for_a_simple_pain_free_git/">https://www.reddit.com/r/git/comments/l4b2m1/any_recommendations_for_a_simple_pain_free_git/</a></td><td class="s10" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/git/comments/l4b2m1/any_recommendations_for_a_simple_pain_free_git/">https://www.reddit.com/r/git/comments/l4b2m1/any_recommendations_for_a_simple_pain_free_git/</a></td><td class="s11" dir="ltr"><span class="s3" style="background-color: #d5deeb; color: #383a3c; width: 128.0px; max-width: 128.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">YANLIŞ</span></td><td class="s9" dir="ltr">[&#39;Any recommendations for a simple pain free git workflow for 2 developers? (new)&#39;, &quot;So to give a bit of background/context, I just got job where there aren&#39;t really any best practices. Dev and Prod are one in the same, no testing, no code reviews, no version control (they have Microsoft TFS   \n but don&#39;t use it at all), no development pipeline or structure to deployments, etc.\n\nI&#39;m going to be working on a project with the lead dev so we discussed utilizing git and agreed to use it. Now, I&#39;m all for git and know the basics (add, commit, push, pull, branches, etc.) but the lead dev was a bit indifferent and tasked me with creating a private repo since he didn&#39;t know how to.\n\nMy idea for a basic workflow was something similar to/based on Trunk-Based Development. One main branch and then we each have our own dev branches off main where we do all of our development. We develop a given feature or bug fix, pull from master to resolve any conflicts, then merge into master and push the master branch upstream.\n\nCode reviews and discussion about merges most likely won&#39;t be a thing so I figure merging to local master, although not ideal, is probably the best and simplest way to go about it.\n\nDo you guys have any recommendations, feedback or advice? I&#39;d greatly appreciate it.&quot;, &#39;My team currently switched to trunk-based and it works pretty well.   \nMaster is auto deployed to sandbox environment.  \nEveryone develops on their local machine with own branches.  \nIf done, we merge the branches to master.\n\nEvery 2 weeks we create a release branch based on master which is then tested and if fine, released to production.  \n\n\nOnly thing that I have to deal with right now (as I am typing) is hotfixing. I have done a fix for a problem and merged to master last week. Now we decided this fix should be out right now so I would have to get my fix branch into the release branch, but since the PR was merged to master, it now has the commit history of master and I cant just PR that branch to the release branch and I have to cherry pick my commits over, which sucks.   \n\n\nIf someone knows a better way to handle hotfixes, please let me know.&#39;, &#39;Go Read about git-flow (new)&#39;, &#39;I would start by creating an org in case one of you leave the code is stop with the company. \n\nYou should also look into setting up a testing environment. Then you can have a master/main branch and then a develop branch the gets pushing to the testing env. You then branch off develop. (new)&#39;, &#39;I highly recommend, and use, the [Light Flow](https://yairchu.github.io/posts/simple-dev-flows) (which TBD\&#39;s site calls &quot;mainline&quot;). git-flow is too complicated especially for such a small team, and TBD is wrong imho (the linked article explains why) (new)&#39;, &#39;[deleted] (new)&#39;, &quot;I can recommend git-flow as well. It&#39;s straight forward and very user friendly. This is the guide I used: [http://danielkummer.github.io/git-flow-cheatsheet/](http://danielkummer.github.io/git-flow-cheatsheet/) (new)&quot;, &#39;yeah so cherry picking is what makes it hard, since I see the commit history of master after the merge. So looking for the actual commits to that feature branch gets tougher. Like there were 5 commits to that feature branch, but after the merge to master, the feature branch has the commit history of master, and then you have to find the 5 out of 100.\n\nFor the terminology, quickly googled: **Trunk-based development** is a required practice for **continuous integration**. **Continuous integration** (**CI**) is the combination of practicing **trunk**\\-**based development** and maintaining a suite of fast automated tests that run after each commit to **trunk** to make sure the system is always working.&#39;, &#39;[deleted] (new)&#39;, &#39;i will try it out tomorrow. Thanks for the help (new)&#39;]</td><td class="s12" dir="ltr">[&#39;Use a single shared trunk&#39;, &#39;Use short-lived branches&#39;, &#39;Cherry-pick changes to release branches&#39;, &#39;Simplifies the development workflow (+)&#39;, &#39;Promote frequent and rapid integration (CI) (+)&#39;, &#39;Reduce merge conflicts (+)&#39;, &#39;Small team&#39;]</td></tr><tr style="height: 30px"><th id="958685326R3" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">4</div></th><td class="s2" dir="ltr"><span class="s3" style="background-color: #dce9cb; color: #2c481f; width: 147.0px; max-width: 147.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">git</span></td><td class="s4" dir="ltr">Anyone have any experience with trunk based development? When should testing happen? How to handle concurrent releases and multiple teams?</td><td class="s5" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/git/comments/u5qkrk/anyone_have_any_experience_with_trunk_based/">https://www.reddit.com/r/git/comments/u5qkrk/anyone_have_any_experience_with_trunk_based/</a></td><td class="s5" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/git/comments/u5qkrk/anyone_have_any_experience_with_trunk_based/">https://www.reddit.com/r/git/comments/u5qkrk/anyone_have_any_experience_with_trunk_based/</a></td><td class="s6" dir="ltr"><span class="s3" style="background-color: #d5deeb; color: #383a3c; width: 128.0px; max-width: 128.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">YANLIŞ</span></td><td class="s4" dir="ltr">[&#39;Anyone have any experience with trunk based development? When should testing happen? How to handle concurrent releases and multiple teams?&#39;, &quot;Hey,\n\nThis may not be the right place for this type of topic, happy to be guided otherwise.\n\nI work on a project which has 3 separate teams, each team is between 4-6 developers and is a mix of internal and offshore devs. There is no formal git branching strategy in place and things are getting a bit messy so I&#39;m looking for suggesting on how to improve.\n\nI was originally going to recommend Git Flow but after some research this doesn&#39;t appear to be as popular as I thought and it probably won&#39;t scale well for us so I&#39;ve been reading about the trunk based method.\n\nOne question around the trunk based strategy is when should testing and QA and happen? Currently we deploy our feature branch to a testing area for QA and stakeholders to sign off and to ensure everything is stable, then we merge to master and deploy.\n\nThe problem we&#39;ve encountered a couple of times is that by the time testing is finished (it can take about a week), master has already moved forward and may have already been released several times during this time.\n\nThis means that code on master may no longer be compatible with our work which has just completed a round of testing, so we have to restart some of the testing but master may have changed again so we get stuck in a loop and constantly playing catch up with master during testing.\n\nWith any branching strategy, the only way around this that I can see is that we ask other teams to pause making changes to master (and releasing) until we&#39;ve finished testing and merged our feature but this seems to go against the ideals of CD teams.\n\nWe could look at merging the feature as soon as it&#39;s passed a code review but the business logic is so complex that the work often requires multiple stakeholders to sign it off, I wouldn&#39;t feel comfortable merging to master before that has happened.\n\nIs there something we&#39;re missing? Any advice is welcome.&quot;, &quot;It sounds like you have a broken review and QA process if it&#39;s taking that long. You should fix that first (new)&quot;, &#39;&gt; We could look at merging the feature as soon as it\&#39;s passed a code review but the business logic is so complex that the work often requires multiple stakeholders to sign it off, I wouldn\&#39;t feel comfortable merging to master before that has happened.\n\nHave you considered feature flags (aka feature toggles)?\n\nYou put the changes wrapped in appropriate if statements or configuration variables, launch it.\n\nOn QA, you enable those features so that they can get tested.  When you\&#39;re ready for production, it\&#39;s only a matter of changing the configuration and its live.\n\nNote that this isn\&#39;t the &quot;we can feature flag everything!&quot;  Feature flags are branches in `if` statements rather than version control.  Eventually, just as you delete branches in version control, you should deleted outdated feature flag branches.\n\nhttps://martinfowler.com/articles/feature-toggles.html\n\nhttps://launchdarkly.com\n\nhttps://docs.gitlab.com/ee/operations/feature_flags.html // https://github.com/Unleash/unleash (new)&#39;, &quot;One thing you can do is develop everything on master but cut a release branch to freeze things for QA while they test. A branch for QA isn&#39;t in conflict with the idea of trunk-based development.\n\nTrunk-based development doesn&#39;t mean no other branches exist at all. It means that developers all use the same branch and all commit their features and such to that one branch. That way developers don&#39;t diverge from each other.\n\nWhen a release cycle is completed (release branch cut, QA done, put into production), then you basically abandon that release branch. Then with the next release, you repeat the process and cut a new branch from master.\n\nOn rare occasions, you might commit to a release branch, but only in very specific circumstances, like you have a very important release (product launch, etc.) coming in 2 days, QA has finished, but at that moment a security bug is discovered that exists in both master and the release branch. Then, if the fix is small, you might create the fix in master and cherry-pick it into the release branch so you don&#39;t have to abandon the release and so that you can get QAed code into production ASAP. (This actually doesn&#39;t have to be that rare. You could be a little looser and allow cherry picks for bug fixes without which you would have to cancel the release. As long as the bug fix requires minimal changes so that it won&#39;t invalidate the QA you&#39;ve already done.)\n\nThere is such a thing as releasing directly from master, which is sort of an optional part of trunk-based development. It&#39;s a reasonable option if your tests are entirely automated or very nearly so, in which case the QA process never falls far behind master because it only takes hours at most.&quot;, &quot;Having week-long testing on a fast moving environment like trunk is pointless imo. It&#39;s a development environment and it&#39;s ok if every now and then something breaks or bugs slip through.\n\nOn trunk our main testing comes from devs during the usual process. First time in local during code review, then after the merge on trunk. We have a dedicated environment for QA which moves at a slower pace... I think we deploy once per sprint at most. And in that environment QA does extensive testing and that will be used to deploy to UAT when needed. \n\nThat doesn&#39;t mean that there&#39;s no testing done at all on dev by QA but it&#39;s more some general testing and not part of the process when developing a new item. Devs, unit and automated e2e testing should be enough to keep dev environment rolling. (new)&quot;, &#39;This sounds to me more likely to be fixed by product management changes than by Git process changes.\n\nA fundamental part of the problem is your team moves through approvals at a slower pace than the others. Why is that? Are the others not QAing things that should be QA\&#39;d?  Is your team QAing things that don\&#39;t need to be? Are there problematically slow people on your team, or stakeholders on your side who go extra slow? People on the other teams who are problematically fast?\n\nIf the different paces are fundamental to the different work the teams are doing, would it hurt the other teams to let your team dictate the release pace?\n\nIs it really necessary for your team to go through approvals again? Could there be one person who knows about this dynamic and who has the authority to approve your team\&#39;s fixes, where you tell them &quot;after you approved the other team changed the API. Check this one thing again, it\&#39;ll take one minute&quot;? Even better, can you add tests that will take care of this confirmation? If your team\&#39;s work isn\&#39;t tested, is it worth investing in adding test infrastructure?\n\nIf your team is repeatedly having Git conflicts that are so big and tricky that you feel it necessary to go through the approval process all over again, then the other team is working on the same feature as you but acting like they aren\&#39;t. Cross-team communication might go a long way to clearing that up. On the Git side, you might want to be working in a shared multi-team feature branch, to make conflicts show up as early as possible.\n\nIs there a way for the other team to know that their work will break yours? Again cross-team communication would be key. They can give the heads up, and you can be working —maybe even collaborating with them— on the fix earlier.\n\nAre the other teams being irresponsible about maintaining backwards compatibility in something your team uses as a dependency? If the other team owns a service or API shape or something and they\&#39;re making breaking changes on a weekly basis, it\&#39;s time for some reevaluating. Do they need to make breaking changes? Do you need to rely on their product? Can your team and the other team use versioning in a way that lets your team continue using the old version of the other teams\&#39; work, so that you can ship and _then_ deal with upgrading? (new)&#39;, &#39;Automated acceptance tests.\n\n&amp;#x200B;\n\nAuthorities spend time with testers to automate their approvals, by devising those test scenarios. This also have huge benefit of working even in presence of vacations and other holidays that make Authorities unavailable.\n\n&amp;#x200B;\n\nOTOH you will need some extra hardware and set up once list of such tests grows.\n\n&amp;#x200B;\n\nOTOH if you need those sign offs for auditing, acceptance tests run on specific commit hashes, and those will be the hashes released to production, so you got even more reliable auditing.\n\n&amp;#x200B;\n\n&amp;#x200B;\n\nTBD can work with current set up. You just have to cut versions off for QA.\n\nVersion passes QA, it then can be considered for final release to prod. Its having some issues. Fix them on trunk and cherry pick. It has galore of bugs, just kill it and cut new release for QA from newer code once you fix those bugs.\n\n&amp;#x200B;\n\nIdea here is that long QA demands explicit releasables for their use. But do note my advice above. QA can and should be integrated into development, which will improve overall picture. You just have options to start differently now.\n\n&amp;#x200B;\n\nIs it worth it? TBD will NOT speed QA/Approval steps. Do full analysis what happens to a feature during development.\n\n* How long requirements are gathered\n* How long does it lay in backlog\n* How long in progress\n* How long in testing\n* How long in approval\n\nOf course if feature moves back and forth, that info should also be included.\n\nThen graph it. Work done is line above middle line, waiting is a line below middle line. Scale for time is days. Its also useful to interest Authorities in automated approvals. (new)&#39;, &#39;Yup https://trunkbaseddevelopment.com/feature-flags too (new)&#39;, &#39;yeah feature flags is good stuff. we use it for bigger efforts (epics or multi-ticket more complicated features).\n\nanother thing we are experimenting with is pre-release stage where you create separate branch from master and then deploy it to separate env for QA to verify whether everything is good and ready to go to prod. if yes, just deploy same branch to prod. branch name is usually ‘release/’ (new)&#39;, &#39;Yup https://trunkbaseddevelopment.com/branch-for-release goes into that some (new)&#39;]</td><td class="s7" dir="ltr">[&#39;Use a single shared trunk&#39;, &#39;Use temporary release branches&#39;, &#39;Cherry-pick changes to release branches&#39;, &#39;Use feature flags to safely integrate incomplete features&#39;, &#39;Use feature flags to decouple deployment from release&#39;, &#39;Automate test execution (unit, integration, e2e)&#39;, &#39;Automated build and tests always pass on the CI&#39;, &#39;Promote frequent and rapid integration (CI) (+)&#39;, &#39;Reduce merge conflicts (+)&#39;, &#39;Enable fast and continuous feedback (+)&#39;, &#39;Encourage team collaboration and communication (+)&#39;, &#39;Shortens automated feedback cycles by testing each trunk commit against the main codebase through CI/CD pipelines (+).&#39;, &#39;Simplifies the development workflow (+)&#39;, &#39;Manual approval in staged releases&#39;, &#39;Requires robust testing and test infrastructure (-)&#39;, &#39;Requires strong discipline and team coordination (-)&#39;, &#39;Avoid big-bang merges&#39;, &#39;Keep trunk updated with release fixes&#39;, &#39;Integrate QA and stakeholder approval processes into automated acceptance tests to streamline approvals in TBD (new)&#39;, &#39;Explicitly track and analyze feature progress and bottlenecks (e.g., requirements gathering, backlog, in progress, testing, approval) to optimize TBD workflows (new)&#39;]</td></tr><tr style="height: 30px"><th id="958685326R4" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">5</div></th><td class="s8" dir="ltr"><span class="s3" style="background-color: #dce9cb; color: #2c481f; width: 147.0px; max-width: 147.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">git</span></td><td class="s9" dir="ltr">Best git branching strategy with dev / qa/ production ?</td><td class="s10" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/git/comments/u9n3yw/best_git_branching_strategy_with_dev_qa_production/">https://www.reddit.com/r/git/comments/u9n3yw/best_git_branching_strategy_with_dev_qa_production/</a></td><td class="s10" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/git/comments/u9n3yw/best_git_branching_strategy_with_dev_qa_production/">https://www.reddit.com/r/git/comments/u9n3yw/best_git_branching_strategy_with_dev_qa_production/</a></td><td class="s11" dir="ltr"><span class="s3" style="background-color: #d5deeb; color: #383a3c; width: 128.0px; max-width: 128.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">YANLIŞ</span></td><td class="s9" dir="ltr">[&#39;Best git branching strategy with dev / qa/ production ? (new)&#39;, &#39;I’ve tried to wrap my head around trunk based strategy but I can’t understand how you can create an automated pipeline to all three environments. I’m used to gitflow 🤯&#39;, &#39;Don\&#39;t know the better (maybe trunk with tags), but I know the worst and that`s the &quot;common&quot; in big companies from Brazil: &quot;git flow with long lived branch per environment and merge between them&quot;, jesus christ that the worst sh&amp;t ever to mantain, track and to keep environments synced&quot;\n\n\n={ (new)&#39;, &quot;With tags !\n\nWhat don&#39;t you understand ?  \n\n\nWe have staging and prod. Everything that&#39;s merged on master is deployed on staging, and when master is stable enough we tag a new version and release on prod (new)&quot;, &#39;You can have environment branches that trigger the deployments, but you should treat them as pointers and only reset them to existing commits.\n\nOr specify the environment as a variable to the pipeline.\n\nBasically you want to reuse your existing build artifacts in all the environments. (new)&#39;, &#39;For certain release cadences, CI makes binaries that get dropped into a binary repository (like artifactory). It is this binaries that get deployed to shared dev, QA, UAT/Staging before prod. (new)&#39;, &#39;Trunk-based development with release branches.\n\nhttps://medium.com/@amid.ukr/agile-git-branching-strategies-in-2023-caeead79ddd&#39;, &quot;&gt;What don&#39;t you understand ?\n\nRemember that not everyone does continuous development with lots of small updates from tons of developers, and doing version releases.  Some of us are used to checking out code and having it locked, testing changes in dev, then QA, then checking it back in and moving it to production. (sorry if I hijacked the thread) (new)&quot;, &#39;Can you point me to a useful documentation/tutorial ? (new)&#39;, &#39;But that defeats the purpose of having trunk based / one main branch ?&#39;, &#39;I have no clue what you just said (new)&#39;, &#39;How do you concretely trigger those deployments? (new)&#39;, &quot;Yes I was always in gitflow environments previously, so i&#39;m still very new to trunk based and the idea of putting commits in master to test them on staging is still weird to me but I haven&#39;t found big issues with the flow yet.&quot;, &#39;I came from git flow aswell and read this [https://trunkbaseddevelopment.com/](https://trunkbaseddevelopment.com/) (new)&#39;, &#39;No, because the environment branches should never diverge from main (unless you are using release branches). You only use them as a way to trigger a deployment of a specific commit.\n\nThis requires understanding that git branches are just pointers to commits. (new)&#39;, &#39;If **ALL** tests pass (CI), then a CD step (subject to policy) could be to run a deploy script to (shared dev, or QA, or UAT - subject to policy).  \n\n[https://paulhammant.com/2018/05/23/examining-ci-cd-and-branching-models](https://paulhammant.com/2018/05/23/examining-ci-cd-and-branching-models) speaks to that ..... for **weekly planned release** cadence or slower. (new)&#39;, &#39;It’s a dumbfucks flow. (new)&#39;, &#39;That site just basically explained a git flow model. Short lived feature branches, merge requests onto master, build, test, tag, production. (new)&#39;, &#39;This is what I advocate for. Environment branches that track the history of main. Those branches can only be merged into with fast-forward merges, keeping a clean timeline. (new)&#39;, &#39;What is CI and CD? (new)&#39;, &quot;Maybe you just don&#39;t get it ? (new)&quot;, &#39;Why? (new)&#39;, &#39;I wrote that site. Explain me how I am so how detailing gitflow? (new)&#39;, &#39;Thanks for contributing to the community with your site, it’s honestly past-due. It would be super helpful to give some command line real world examples that you run for specific scenarios. I learn better that way, that’s just me. (new)&#39;, &#39;Thank you! (new)&#39;, &#39;https://trunkbaseddevelopment.com/short-lived-feature-branches/#workstations-included - should be a graphical representation of “a day in the life”. You’re talking about git commands, right? (new)&#39;, &#39;Yes, more like a real world example from start to finish of some of the work flows you’ve described. (new)&#39;, &#39;We’re in the realm of free consulting now. (new)&#39;, &quot;My company has paid for git consulting before and even *then* they couldn&#39;t explain it well enough .. lol (new)&quot;]</td><td class="s12" dir="ltr">[&#39;Adopt CI/CD pipelines for automated integration and delivery&#39;, &#39;Automate code quality checks (linting, testing, analysis)&#39;, &#39;Automate test execution (unit, integration, e2e)&#39;, &#39;Automated build and tests always pass on the CI&#39;, &#39;Deploy frequently and provide fast feedback&#39;, &#39;Enable fast and continuous feedback (+)&#39;, &#39;Integrate CI/CD tools&#39;, &#39;Promote frequent and rapid integration (CI) (+)&#39;, &#39;Reduce merge conflicts (+)&#39;, &#39;Shortens automated feedback cycles by testing each trunk commit against the main codebase through CI/CD pipelines (+).&#39;, &#39;Simplifies the development workflow (+)&#39;, &#39;Use a single shared trunk&#39;, &#39;Use short-lived branches&#39;, &#39;Use tags for releases&#39;, &#39;Use temporary release branches&#39;, &#39;Use environment branches as fast-forward pointers to trigger deployments without diverging from main (new)&#39;]</td></tr><tr style="height: 30px"><th id="958685326R5" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">6</div></th><td class="s2" dir="ltr"><span class="s3" style="background-color: #ddebff; color: #2a3243; width: 147.0px; max-width: 147.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">devops</span></td><td class="s4" dir="ltr">Branch Protection in Trunk-Based Development</td><td class="s5" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/devops/comments/1biq61p/branch_protection_in_trunkbased_development/">https://www.reddit.com/r/devops/comments/1biq61p/branch_protection_in_trunkbased_development/</a></td><td class="s5" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/devops/comments/1biq61p/branch_protection_in_trunkbased_development/">https://www.reddit.com/r/devops/comments/1biq61p/branch_protection_in_trunkbased_development/</a></td><td class="s6" dir="ltr"><span class="s3" style="background-color: #d5deeb; color: #383a3c; width: 128.0px; max-width: 128.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">YANLIŞ</span></td><td class="s4" dir="ltr">[&#39;Branch Protection in Trunk-Based Development&#39;, &quot;Our team is about to transition from basically anarchy-mode SVN to Git with GitHub, where DevOps mandate to have `main` and release branches under protection with required pull requests and reviews.\n\nWe would like to adopt Trunk-Based Development but are uncertain how to deal with the protected release branches.\n\nIn the past, we would decide that a release is feature-complete and create a branch for it. Then, people would continue to commit bugfixes directly into the release branch, and merge them back to trunk.\n\nI have read a bit about TBD and it seems it&#39;s common practice to not even have release branches, but just tagging them. I see that this can potentially work because all features undergo thorough testing before arriving in `main`, so further work might not be necessary. However, I expect this to not work out for us and we would want to continue to create release branches in case QA comes up with things that need to be done.\n\nThe question now is how such fixes within the protected release branches should be made. The TBD source I was reading said that to prevent regressions, such fixes should be made in `main` and cherry-picked into `release`. No merge is ever done between the two and cherries only move from `main` to `release`, never the other way.\n\nIt makes total sense, but this gets really complicated if both your `main` and `release` are under PR protection. It would mean that for each fix, one would have to create a feature branch from `main`, get that approved, then cherry-pick either the merge-commit or all separate commits made into yet another feature branch off of `release` and get that approved as well.\n\nWhat other options do we have?&quot;]</td><td class="s7" dir="ltr">[&#39;Cherry-pick changes to release branches&#39;, &#39;Use tags for releases&#39;, &#39;Use temporary release branches&#39;, &#39;Mandatory code review policy&#39;, &#39;Use short-lived branches&#39;]</td></tr><tr style="height: 30px"><th id="958685326R6" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">7</div></th><td class="s8" dir="ltr"><span class="s3" style="background-color: #dbeeef; color: #133819; width: 147.0px; max-width: 147.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">softwaredevelopment</span></td><td class="s9" dir="ltr">Branching Strategies?</td><td class="s10" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/softwaredevelopment/comments/8y207a/branching_strategies/">https://www.reddit.com/r/softwaredevelopment/comments/8y207a/branching_strategies/</a></td><td class="s10" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/softwaredevelopment/comments/8y207a/branching_strategies/">https://www.reddit.com/r/softwaredevelopment/comments/8y207a/branching_strategies/</a></td><td class="s11" dir="ltr"><span class="s3" style="background-color: #d5deeb; color: #383a3c; width: 128.0px; max-width: 128.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">YANLIŞ</span></td><td class="s9" dir="ltr">[&#39;Branching Strategies? (new)&#39;, &quot;Admittedly, some of the techniques that we use in some of our projects are behind the times, but we are trying to get our workflow more up to speed with best practices, or at least a practice that will work for us.\n\nWe are moving towards being more Agile and releasing new code (both new features and bug fixes) weekly.\n\nOur current setup:\n\nTrunk - this is where all new development and bug fixes are done. We have a very small team of three developers and we all work out of here.\n\nRelease - this branch always mirrors production. When we have code that is ready to go out (whether it be a new feature or a bug fix that is already in prod), it goes into this branch which is then pushed to prod during our next release window.\n\nWe also have two QA environments. DEV and TEST. First, our development must pass QA on DEV (which is the trunk). Once it passes here, that code gets moved into the Release branch and is then pushed to TEST. Only after an item passes in both environments may it be pushed to prod. This is where we get hung up sometimes as something may be in TEST but not actually ready to go out in the next release.. but since we publish from the test branch, we either need to pull the code out or deploy it anyway.\n\nThis is generally fine for us, but I&#39;m just curious how others do it and how we can improve. (new)&quot;, &#39;We tried to utilize our own branching strategy which sounds similar to yours. We had DEV, QA, MASTER. We ran into complications with release/development timelines. We ended up drinking the git flow kool-aid, and after having struggled through trying to create our own branching strategy, git flow makes much more sense to us now. I would explain it, but there are a million articles explaining git flow, which also makes documenting our process easier.\n\nhttps://danielkummer.github.io/git-flow-cheatsheet/ (new)&#39;, &#39;Do you run TEST on multiple (possibly unrelated) changes at a time? Is the execution cost high for that environment?\n\nWhen you say &quot;not actually ready to go out &quot;, is it not passing the tests or is it functionally incomplete?\n\nFor now, it seems you would benefit from using short lived branches for each feature/bugfix, running all tests on each of them and promoting one item at a time to a unique main branch. Partial items could use feature toggles.\n\nIf I would have 2 main branches, I would use that to allow critical fixes during the week, not for sequential QA steps.&#39;, &quot;I&#39;ve been in multiple environments, large and small, and we sort of always created our own, but yours sounds close enough. We try not to have a testing / qa branch (and I used to be a QA manager)... but typically the branches became different and thus, testing was invalid. \n\n\\- Master (Whats in production, with tags)\n\n\\- Development (Staging for the next release)\n\n... Branch per major feature / story \n\nSo if we need to test a feature in isolation, we test against the branch itself. If we need to do integration testing and see everything as it will be in production, we go to development and if we want to debug production we go against master/tag (in case you have multiple production versions) (new)&quot;, &quot;This is the general strategy that we use. We used to have a lot of issues with partially tested / completed work leaking into production. Or delaying a release because a component wasn&#39;t ready yet.\n\nWe have automated (scheduled) builds set up for Beta and Demo. Production has a build configured but we trigger it manually. The Beta and Demo branches get messy and are periodically reset to master.\n\nThis allows us to push features into Beta for internal QA and UAT. Once something is approved it is merged into master. We have weekly releases currently (although I actually would like to slow this down) and release the features that were completed and approved for release. Approvals are on Thursday afternoons, merges on Friday, and release on Tuesday the following week.\n\nIf you are working on a feature; and other features are approved for release you have to rebase your branch with master so that your changes happen after anything that has been previously approved. It is your responsibility to resolve conflicts with your new feature and those that have been recently added.\n\nThe release branch is what the production build pulls from. We are resetting its status to master instead of merging. Probably a six to one situation; but it works for us.\n\nhttps://i.imgur.com/TM8EU2E.png (new)&quot;]</td><td class="s12" dir="ltr">[&#39;Accelerate release cycles (+)&#39;, &#39;Small team&#39;, &#39;Use a single shared trunk&#39;, &#39;Use short-lived branches&#39;, &#39;Use temporary release branches&#39;, &#39;Manual approval in staged releases&#39;, &#39;Rebase before merge&#39;, &#39;Promote frequent and rapid integration (CI) (+)&#39;, &#39;Reduce merge conflicts (+)&#39;, &#39;Trunk always ready for release&#39;]</td></tr><tr style="height: 30px"><th id="958685326R7" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">8</div></th><td class="s2" dir="ltr"><span class="s3" style="background-color: #ddebff; color: #2a3243; width: 147.0px; max-width: 147.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">devops</span></td><td class="s4" dir="ltr">Branching Strategies?</td><td class="s5" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/devops/comments/1gb7zwv/branching_strategies/">https://www.reddit.com/r/devops/comments/1gb7zwv/branching_strategies/</a></td><td class="s5" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/devops/comments/1gb7zwv/branching_strategies/">https://www.reddit.com/r/devops/comments/1gb7zwv/branching_strategies/</a></td><td class="s6" dir="ltr"><span class="s3" style="background-color: #d5deeb; color: #383a3c; width: 128.0px; max-width: 128.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">YANLIŞ</span></td><td class="s4" dir="ltr">[&#39;Branching Strategies? (new)&#39;, &quot;Hello everyone. I&#39;m currently researching the most optimal branching and deployment strategy to implement in my current company.\n\nAs of right now we are working with environment branching, where each team (3 teams) has a branch that they develop on. We also have a staging branch that is used by our QA team for testing and validation. Finally we have our production environment. All the lower environments should always be rebased on the master branch and updated.\n\nOur teams produce new features over biweekly sprints, as well as hotfixes and bugfixes every couple of days. Maintaining 4 environments has become a headache. I&#39;m looking for the most optimal branching strategy that could fit our business needs, keeping in mind how to handle migrations, different RabbitMQ queues, database instances, and so on.\n\nI&#39;ve been researching a trunk based solution with feature flags, however I failed to find a solution for handling migrations of unreleased features and so on. I would love to hear your insights regarding this topic. Thank you in advance!&quot;, &#39;&gt;As of right now we are working with environment branching, where each team (3 teams) has a branch that they develop on. We also have a staging branch that is used by our QA team for testing and validation. Finally we have our production environment. All the lower environments should always be rebased on the master branch and updated.\n\n🤮\n\nDon\&#39;t do this to yourself. TBD is the way. Don\&#39;t let silly excuses like &quot;I failed to find a solution for handling migrations of unreleased features&quot; allow these awful processes to continue.\n \nRead: https://dora.dev/capabilities/trunk-based-development/&#39;, &#39;Are you talking about application-code or infrastructure-code? You need to alaborate a bit more on what problems you face with &quot;migrations and unreleased features&quot;\n\nYou definitately want no long lived branches, as you have experienced yourself they are only pain.\n\nFor application code I don\&#39;t understand why you would have &quot;team branches&quot; at all. If everyone is working on the same code, will have to plan/communicate/align their changes anyway?\n\nFor IaC code, a good default is to have 1 directory for each physical environment and whatever is configured in that directory is deployed. Any &quot;unreleased changes&quot; can be a PR, that just isn\&#39;t merged yet. (new)&#39;, &quot;Oh yes, I didn&#39;t specify that I am speaking about application-code. Infrastructure-code could remain environment branching, as is.\nWould you elaborate more on how we could handle database migrations for example? Assuming that during development a migration should be made but it should reflect for staging environment, before it is moved to production use. (new)&quot;, &#39;💯💯💯\nApp code - TBD \n\nIAC - Environment Branch\n\nIf you are doing it right your grey infrastructure, or App Code w/Lambda or ECS, can trigger IaC as a downstream (new)&#39;, &#39;Hard disagree on the IaC environment branch. Trunk based is still better, pass in variables for the given environment. \n\nEnvironment branches end up a shit show with stuff missing everywhere.&#39;, &#39;Depends how you structure your IAC. The same configs are running for each environment with different overrides. The IAC is small enough and organized by applications, services, and it works like butter. (new)&#39;]</td><td class="s7" dir="ltr">[&#39;Use a single shared trunk&#39;, &#39;Use feature flags to safely integrate incomplete features&#39;, &#39;Promote frequent and rapid integration (CI) (+)&#39;, &#39;Reduce merge conflicts (+)&#39;, &#39;Simplifies the development workflow (+)&#39;, &#39;Avoid big-bang merges&#39;, &#39;Use short-lived branches&#39;, &#39;Challenges handling database migrations for unreleased features in TBD (new)&#39;]</td></tr><tr style="height: 30px"><th id="958685326R8" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">9</div></th><td class="s8" dir="ltr"><span class="s3" style="background-color: #dce9cb; color: #2c481f; width: 147.0px; max-width: 147.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">git</span></td><td class="s9" dir="ltr">Branching Strategy for My Solo Project</td><td class="s10" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/git/comments/1fv4ih8/branching_strategy_for_my_solo_project/">https://www.reddit.com/r/git/comments/1fv4ih8/branching_strategy_for_my_solo_project/</a></td><td class="s10" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/git/comments/1fv4ih8/branching_strategy_for_my_solo_project/">https://www.reddit.com/r/git/comments/1fv4ih8/branching_strategy_for_my_solo_project/</a></td><td class="s11" dir="ltr"><span class="s3" style="background-color: #d5deeb; color: #383a3c; width: 128.0px; max-width: 128.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">YANLIŞ</span></td><td class="s9" dir="ltr">[&#39;Branching Strategy for My Solo Project (new)&#39;, &quot;I&#39;m currently working on a project by myself, and I&#39;m trying to figure out the best branching strategy to use with my version control system (Git). Since I&#39;m the only one working on this project, I want to ensure that my workflow is efficient and helps me maintain a clean codebase.\n\n* **What branching strategy do you recommend for solo projects?**\xa0I&#39;ve heard about strategies like Git Flow, GitHub Flow, and trunk-based development, but I&#39;m unsure which would be the best fit for my situation.\n* **How should I manage feature development and bug fixes?**\n* **Any tips on keeping my branches organized**&quot;, &#39;Trunk based development as a single developer is the simplest. If you’re worried about features, then short lived feature branches can bridge the gap. Please note if you’re gonna do TBD, you’ll want to work on very small tasks.\n\nPersonally, I work with TBD, short lived feature branches and also practice conventional commits. I  a professional developer, so you do not necessarily need to practice this much diligence so long as you can actually get work done and revert it or iterate confidently.&#39;, &#39;If you are the only one working on it, do whatever you want. It only matters if you are working with other people. At a minimum just ensure to delete branches after you merge them in. (new)&#39;, &#39;Gitflow works best for me, as I have feature branches that can take months to finish. I do sciency stuff, not web development.        \nAtlassian has good tutorials on branching and workflows.    \n\nhttps://www.atlassian.com/git (new)&#39;]</td><td class="s12" dir="ltr">[&#39;Use short-lived branches&#39;, &#39;Make small, frequent commits&#39;, &#39;Simplifies the development workflow (+)&#39;]</td></tr><tr style="height: 30px"><th id="958685326R9" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">10</div></th><td class="s2" dir="ltr"><span class="s3" style="background-color: #ddebff; color: #2a3243; width: 147.0px; max-width: 147.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">devops</span></td><td class="s4" dir="ltr">Can trunk based development work in this case?</td><td class="s5" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/devops/comments/1bvjbe4/can_trunk_based_development_work_in_this_case/">https://www.reddit.com/r/devops/comments/1bvjbe4/can_trunk_based_development_work_in_this_case/</a></td><td class="s5" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/devops/comments/1bvjbe4/can_trunk_based_development_work_in_this_case/">https://www.reddit.com/r/devops/comments/1bvjbe4/can_trunk_based_development_work_in_this_case/</a></td><td class="s6" dir="ltr"><span class="s3" style="background-color: #d5deeb; color: #383a3c; width: 128.0px; max-width: 128.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">YANLIŞ</span></td><td class="s4" dir="ltr">[&#39;Can trunk based development work in this case?&#39;, &#39;Given a large monolith java code base, developed since the early 2000s. A testsuite with 6k Unittests that run \\~10mins, and a few thousand JUnit-based integration tests (end2end tests with XML ingestion from queues to either XML sending through queues and or updating a large database underneath) that run \\~2h. There is another massive test suite of E2E frontend tests that runs over night (and on lots of machines in parallel, else it would not get done in that timeframe).  \n\n\nThere are currently \\~30-40 developers actively working on the application.  \nVCS is git (since only a few years. Before it was SVN)  \n\n\nIt can and does happen, that the main development branch gets broken by check ins. The chances of compile clean check ins are quite high. Chances for broken Unit tests are still low (this hurdle 98% of all check ins take). But broken integration tests are common, as you can only guess which ones will be effected by a check in and you can only run so much locally. Finding the culprit later on is hard, as the turnaround time between CI runs is \\~2h and there can be many check ins in the meantime.  \n\n\nCurrently my thinking is, to separate changes into branches that are individually verified before you merge them back into the main branch. But I always read that trunk based development is the state of the art way forward and I wonder if this is even possible with a system like the one I have here as the feedback cycle for validating a check in is to slow.&#39;, &#39;Trunk based dev, but checkins go to temp branches with a PR to validate and merge to trunk.\n\n\nBasically it\&#39;s your verification first step, with standard tools and patterns.\xa0 It\&#39;s still &quot;trunk based development&quot; even with the Pull Request/validation gate.&#39;, &#39;Does your code have the typical &quot; always the same tests fails&quot; ?\nYou could have a file with whose test fails and try to run this test like a fail fast phase before going to the long running tests . (new)&#39;, &#39;Although TBD is possible on big monolith, its not a trivial task to convince 40 devs to change their development flow and build tooling around it. Try to improve current flow step by step, then transition to tbd will be a lot easier!\n\n\nIf your codebase is well structured then try to craft a logic in CI that will trigger only tests that are related to proposed change + full run on merge.\xa0\nYou should also look for a way to run your tests in paralel to decrease time.\n\n\nIf your code is not well structured then try to refactor just the parts that are the most frequently changed to allow testing them easier (new)&#39;, &#39;Ok, but whats the difference to feature branches then? (new)&#39;, &#39;Good Idea. I will try to collect test reports and analyze them (new)&#39;, &#39;Thank you for this well written response. (new)&#39;, &#39;https://trunkbaseddevelopment.com/short-lived-feature-branches/ (new)&#39;, &#39;Feature branches are longer lived and can be used for deployments. \nIn trunk based development, you can still create a new branch to use to write code and test your changes before merging that branch back into the trunk.&#39;]</td><td class="s7" dir="ltr">[&#39;Automate test execution (unit, integration, e2e)&#39;, &#39;Automated build and tests always pass on the CI&#39;, &#39;Enable fast and continuous feedback (+)&#39;, &#39;Promote frequent and rapid integration (CI) (+)&#39;, &#39;Use short-lived branches&#39;, &#39;Use a single shared trunk&#39;, &#39;Requires robust testing and test infrastructure (-)&#39;, &#39;Cultural or organizational resistance is common (-)&#39;, &#39;Requires strong discipline and team coordination (-)&#39;, &#39;Simplifies the development workflow (+)&#39;, &#39;Optimize CI to run only affected tests based on code changes before full test suite execution (new)&#39;]</td></tr><tr style="height: 30px"><th id="958685326R10" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">11</div></th><td class="s8" dir="ltr"><span class="s3" style="background-color: #ddebff; color: #2a3243; width: 147.0px; max-width: 147.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">devops</span></td><td class="s9" dir="ltr">CI and trunk-based development</td><td class="s10" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/devops/comments/1fkui25/ci_and_trunkbased_development/">https://www.reddit.com/r/devops/comments/1fkui25/ci_and_trunkbased_development/</a></td><td class="s10" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/devops/comments/1fkui25/ci_and_trunkbased_development/">https://www.reddit.com/r/devops/comments/1fkui25/ci_and_trunkbased_development/</a></td><td class="s11" dir="ltr"><span class="s3" style="background-color: #d5deeb; color: #383a3c; width: 128.0px; max-width: 128.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">YANLIŞ</span></td><td class="s9" dir="ltr">[&#39;CI and trunk-based development&#39;, &quot;I&#39;m reading DevOps Handbook and I don&#39;t understand what makes trunk-based development a prerequisite for continuous integration. I&#39;ve worked at places that embrace agile development and CI and we only ever used GitHub flow.\n\nWhat&#39;s the argument for adopting trunk-based development when its arguably not for inexperienced developers anyway.&quot;, &#39;Well see you continuously integrate _into_ the trunk (new)&#39;, &#39;From page 148:\n\nADOPT TRUNK-BASED DEVELOPMENT PRACTICES\n\nOur countermeasure to large batch size merges is to institute continuous integration and trunk-based development practices, where all developers check in their code to trunk at least once per day. Checking code in this frequently reduces our batch size to the work performed by our entire developer team in a single day. The more frequently developers check in their code to trunk, the smaller the batch size and the closer we are to the theoretical ideal of single-piece flow.\n\nFrequent code commits to trunk means we can run all automated tests on our software system as a whole and receive alerts when a change breaks some other part of the application or interferes with the work of another developer. And because we can detect merge problems when they are small, we can correct them faster.&#39;, &#39;Well if one of your team members is pushing changes on to branch a for a week and another is pushing changes onto branch b for a week and then they both try to merge to the trunk they might find that their changes conflict with each other or either in terms of the code itself (conflicts) or behaviour (bugs). They maybe running automated tests etc on their branches but they integrate their changes infrequently and so that’s not CI. (new)&#39;, &#39;The idea is for devs to merge their branches to the master/trunk and the master would get tested and verified by your ci constantly whether on PR merge or nightly builds. \n\nThat way when you go to make a new release you just cut the release from the master and follow your release process (new)&#39;, &#39;Old post, but since no answer touch core issue I\&#39;m adding my own 3 bits.\n\n\nIntegration: making sure that after combining software still work.\n\n\nCI uses that to mean GLOBAL integration. Every piece of code no matter which branch, version, configuration.\n\n\nContinuous Integration: integrating codebase as soon as new code arrives.\n\n\n\n\nCI can be done with multiple branches. Just merge all of them into temporary branch and run build on it. Notify devs if it fails.\n\n\nNo CI solution does it that way as far as I know.... Best possible is when &quot;CI&quot; integrates all branches that should be merged at the moment.\n\n\n\n\nTrunk Based Development enforces combining all new code daily, which means doing &quot;CI&quot; of just main branch is actually doing global CI and thus the correct CI.&#39;, &#39;Trunk based is NOT a requirement for CI. Thats the author view. Dont treat this as a bible.\n\nThere are multiple branching and merging methodologies. They depend on the software we releaae, how many components does it have, how we plan to releaae each component, how the team is structured, how cross team dependencies work, the size of the team, the frequency of release, how they deal with bugs and hotdixes, and more.\n\nEach can be used for CI. Each has a difference affect on cd.&#39;, &#39;As opposed to a release branch, or some such? (new)&#39;, &#39;You release from the trunk too. (new)&#39;]</td><td class="s12" dir="ltr">[&#39;Adopt CI/CD pipelines for automated integration and delivery&#39;, &#39;Automate test execution (unit, integration, e2e)&#39;, &#39;Commit frequently (daily)&#39;, &#39;Promote frequent and rapid integration (CI) (+)&#39;, &#39;Reduce merge conflicts (+)&#39;, &#39;Trunk always ready for release&#39;, &#39;Use a single shared trunk&#39;, &#39;Make small, frequent commits&#39;, &#39;Simplifies the development workflow (+)&#39;, &#39;Shortens automated feedback cycles by testing each trunk commit against the main codebase through CI/CD pipelines (+).&#39;]</td></tr><tr style="height: 30px"><th id="958685326R11" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">12</div></th><td class="s2" dir="ltr"><span class="s3" style="background-color: #dbeeef; color: #133819; width: 147.0px; max-width: 147.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">softwaredevelopment</span></td><td class="s4" dir="ltr">Detecting Errors Before They Hurt: Practical Applications of Lean Software Development</td><td class="s5" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/softwaredevelopment/comments/1k1zzk7/detecting_errors_before_they_hurt_practical/">https://www.reddit.com/r/softwaredevelopment/comments/1k1zzk7/detecting_errors_before_they_hurt_practical/</a></td><td class="s5" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/softwaredevelopment/comments/1k1zzk7/detecting_errors_before_they_hurt_practical/">https://www.reddit.com/r/softwaredevelopment/comments/1k1zzk7/detecting_errors_before_they_hurt_practical/</a></td><td class="s6" dir="ltr"><span class="s3" style="background-color: #d5deeb; color: #383a3c; width: 128.0px; max-width: 128.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">YANLIŞ</span></td><td class="s4" dir="ltr">[&#39;Detecting Errors Before They Hurt: Practical Applications of Lean Software Development (new)&#39;, &#39;Hi devs,  \nSharing an article I wrote on applying Lean Software Development principles to real-world software delivery. This post focuses on detecting errors as early as possible across the development and deployment pipelines.\n\nIt covers examples like TDD, trunk-based development, automation of pre-commit and pre-push hooks, production validations, and how early error detection can make teams faster, more resilient, and safer over time.\n\nWould love feedback and to hear about others’ experiences!\n\n➡️ [Detect Errors Before They Hurt - Practical Lean Software Development](https://www.eferro.net/2025/04/lean-software-development-detect-errors.html)\n\nYou can also find the whole practical series here: [Lean Software Development — Practical Series](https://www.eferro.net/p/lean-software-development-practical.html)&#39;, &#39;Decades ago, I attended a NASA presentation about the cost of fixing errors in the space shuttle software. If I remember correctly, the space shuttle has approximately 5 million SLOC, with 50,000-60,000 of these being mission-specific. They have encountered bugs during a mission that require a software patch to be addressed. The presenter stated that it costs 8,000 times more to correct an error during a mission than it does to correct it in the SRS. (new)&#39;, &#39;For those managing teams: How do you encourage and support a mindset of detecting and fixing issues early without it being seen as &quot;slowing down&quot;?  \n  \nDo you have any favorite technical practices that help catch errors early? (e.g., trunk-based development, pre-push hooks, canary releases, observability practices, etc.)&#39;, &quot;Interesting. I really like a rigorous approach that deals with errors and defects as they arise. Especially in a CI or TDD environment. It turns the process of testing into discovery, accentuating the strengths and benefits of developing around tests and stability.\n\nTypically the main tradeoff seems to be something like overhead/complexity versus agility and speed. Having CI and tests can slow a project down if it&#39;s too early, such as when prototyping, but is necessary in production or at scale. But the balance never fully disappears, and sometimes a granular TDD/linting approach can obscure the forest through the trees, leading to fixes for things that overlook fundamental design decisions\n\nI really like the idea of having quality from the start, especially as someone who places a high priority on data integrity and correctness. The comparison to NASA or other mission critical software comes to mind (new)&quot;, &quot;Very interesting, thanks for sharing!  \nDo you happen to remember or have a specific reference to the paper or presentation? I&#39;ve heard similar statements a few times, and intuitively —and from my own experience— I believe that&#39;s exactly how it works.  \nI&#39;d love to find papers, presentations, or articles that I could cite as a reference. Thanks a lot in advance if you remember anything more! (new)&quot;, &#39;Tell them horror stories about the developer suffering caused by mistakes made early in the process. Find the horror stories using ChatGPT or Google. (new)&#39;, &quot;No, the presentation was decades ago. I used his handout in dozens of presentations, but I&#39;ve long since lost it. \n\nThe Space Shuttle&#39;s primary flight software was probably the most carefully engineered codebase in history, developed by IBM and then Rockwell under stringent quality controls (e.g. the onboard Primary Avionics Software System (PASS) and the Backup Flight Software). Defect rates were extremely low (often cited as 1 error per 400,000 lines of code, or better), but when issues arose, hot fixes or even in-flight patches were sometimes necessary. I recall being blown away by the depth and breadth of knowledge the presenter possessed.\n\nGoogle Barry Boehm or US Air Force STARS program. They produced similar analysis. Or, ask ChatGPT. It will turn up dozens of similar studies. (new)&quot;, &quot;It&#39;s a great idea (new)&quot;, &quot;Thank you for the context. I&#39;ll research a little bit to see what I can find. (new)&quot;]</td><td class="s7" dir="ltr">[&#39;Automate code quality checks (linting, testing, analysis)&#39;, &#39;Automate test execution (unit, integration, e2e)&#39;, &#39;Adopt CI/CD pipelines for automated integration and delivery&#39;, &#39;Enable fast and continuous feedback (+)&#39;, &#39;Promote frequent and rapid integration (CI) (+)&#39;, &#39;Simplifies the development workflow (+)&#39;, &#39;Improve software quality and stability&#39;]</td></tr><tr style="height: 30px"><th id="958685326R12" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">13</div></th><td class="s8" dir="ltr"><span class="s3" style="background-color: #ddebff; color: #2a3243; width: 147.0px; max-width: 147.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">devops</span></td><td class="s9" dir="ltr">Dev testing with trunk based development</td><td class="s10" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/devops/comments/1da01vm/dev_testing_with_trunk_based_development/">https://www.reddit.com/r/devops/comments/1da01vm/dev_testing_with_trunk_based_development/</a></td><td class="s10" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/devops/comments/1da01vm/dev_testing_with_trunk_based_development/">https://www.reddit.com/r/devops/comments/1da01vm/dev_testing_with_trunk_based_development/</a></td><td class="s11" dir="ltr"><span class="s3" style="background-color: #d5deeb; color: #383a3c; width: 128.0px; max-width: 128.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">YANLIŞ</span></td><td class="s9" dir="ltr">[&#39;Dev testing with trunk based development&#39;, &#39;I work in a newly built team where we use trunk based development for our microservices - Merges to main trigger the deploys to the dev environment.  The problem we are having is the devs are wanting to test their changes by deploying to AWS dev environment before merging to main which i think is creeping into feature based branching strategy.\n\nAny best practices here?  Should testing (CI) be improved on the Pull Request step to reduce the need to deploy before merging to main?  Or has anyone seen workflows where each dev has their own cloud environment to work on?  What else should i consider?&#39;, &#39;Mergers to main should be heading to production.\n\nMergers to main should require approved PRs.\n\nThe pattern that I’ve worked that had the highest development velocity looked like this with ~150 developers:\n\n1 Staging environment, production like in every way, reduced scale.\n\nX (we maxed out at 8) “review” environments that ran every service required on a minimum evaluation environment.  This gave developers a place to deploy PRs to for click testing, etc.  These had seeded data that reset frequently so the environment would come up in a known state.  All services, production-lite, some things not available or different from staging/prod (Redis on k8s vs hosted for example)\n\n1 Development environment for the infrastructure folks to build out IAC that was promoted to staging, then production.  App code flow was staging &gt; production.\n\nWe had a small set of senior engineers who could as needed merge PRs together to batch release to production.\n\nLong lived feature branches were not allowed, if your feature needed long lived development you needed feature flags and had to merge to main once every sprint.\n\nI know it’s not the purest version of trunk based development but we moved fast.  Highest velocity and happiest development team I have worked with in 20+ years in the industry.  On average, we had half a dozen production deployments per day and high (5 9s) of service uptime.\n\nI speak in the past tense because we had a successful exit for that startup via acquisition.&#39;, &#39;My current setup is something like trunk based development, but i really do not care what name it has. It works well for us and that is the most important thing, not following some dogma.\n\nWe have main. A merge to main triggers a deploy to production.\n\nDevelopers take main, create a branch, start doing their thing, push the branch and after some commits create a merge request. This merge request runs all tests and creates a test/uat environment (accessible by https://branch-name.company.dev). If anyone wants to test the new features or fixes they can use that environment.\n\nAnd when it gets merged to main it goes off to production and the test environment is destroyed (kubectl delete namespace $branch).\n\nThe number of test environments is limited by the size of our kubernetes cluster which has enough resources for 20-25 environments.&#39;, &#39;&gt;Any best practices here?\n\nYou should spend some time reading [https://trunkbaseddevelopment.com/](https://trunkbaseddevelopment.com/) (new)&#39;, &#39;Where I work I developed a system based on github flow:\n\n- There\&#39;s only main and feature branches.\n- Merges to main trigger builds and deployments to dev\n- Testers can build a branch and deploy it to their dedicated environment (qa1, qa2, qa3)\n- We can manually deploy any version to any environment\n- Environments are protected.\n- When ready to release, we deploy selected version to staging and this deployment triggers creation of hotfix/version branch\n\nEverything is based on Github actions and ArgoCD. There\&#39;s even a scheduled action that turns off testing envs at night by just updating one variable in ArgoCD (helm chart supports &quot;shutdown&quot; on deployments).\n\nSo yeah, basically every tester has their own environment. This ensures that features merged to main have been tested. Testers (as a group) are the Codeowners of all the files in the application directory (monorepo with helm and docker) so PRs can\&#39;t be merged without the approval of at least one tester.\n\nWhile we do prod deployments every other day, I just don\&#39;t like prod deployment to be triggered just by merging something.\n\nWe have automated labeling as well so it\&#39;s clear to see which PR\&#39;s have been already tested and are truly ready to be merged. (new)&#39;, &#39;&gt;I work in a newly built team where we use trunk based development for our microservices - Merges to main trigger the deploys to the dev environment. The problem we are having is the devs are wanting to test their changes by deploying to AWS dev environment before merging to main which i think is creeping into feature based branching strategy.\n\n[Short, one-developer feature branches](https://trunkbaseddevelopment.com/short-lived-feature-branches/) are the main way people do trunk-based development: https://trunkbaseddevelopment.com/#scaled-trunk-based-development The two things are not in conflict.\n\nBeyond that, [one of the steps of maturing as an engineer](http://www.kitchensoap.com/2012/10/25/on-being-a-senior-engineer/) is evolving from maxim-based decisions. &quot;We do trunk based development, devs ask for something that isn\&#39;t, so therefore the answer is no&quot; is very junior engineer behavior. What you want to start working on is understanding _why_ the company is doing trunk-based development and then evaluating asks against _that_. In this case you would\&#39;ve been able to identify that the two things don\&#39;t conflict and move ahead with enabling your devs.&#39;, &#39;If you need to trunk based development, you need to write a good behavioral testing and that run as part of the CI. Having this test helps at least new code not breaking existing functionality. Trunk vs git flow development is more a discussion and it also based on the team and a product type. And every organization setup slightly different. But having a good test, help any team on the long run.&#39;, &quot;Use Argo CD app sets to make an ephemeral or spin up a container with there that shows the changes BEFORE merge to main. \n\nPut on a rule saying you can&#39;t merge till pipeline finishes building, test etc. \n\nThen go to dev, prod. (new)&quot;, &#39;[deleted] (new)&#39;, &#39;This sounds fantastic and is definitely trunk based development done well&#39;, &quot;Haven&#39;t really had the need to deploy PRs to individual environments before merging in smaller/similarly sized teams. As long as you can roll back quickly and test fast it&#39;s usually fine to deploy to dev -&gt; test -&gt; rollback if something went wrong and before you promote to staging/prod  \n  \nThe rate of failures on dev was already quite low (sub 10% I&#39;d say) since we had good test coverage and culture on the individual repositories as well.\n\nStill sounds like a great setup though! (new)&quot;, &#39;Were the &quot;review&quot; environments also used for automated testing? (new)&#39;, &#39;&gt; I know it’s not the purest version of trunk based development but we moved fast.\n\nNot saying it\&#39;s a bad method. It\&#39;s very common, but it\&#39;s not trunk-based development at all? In trunk based, with small teams, you wouldn\&#39;t need to do pull requests at all.\nI mean trunk-based in the sense of [Continuous Integration](https://martinfowler.com/articles/continuousIntegration.html#HowDoWeDoPullRequestsAndCodeReviews) (the development praxis, not the tools we use to run tests on triggers).\n\nYou\&#39;re deploying from &quot;trunk&quot; and develop in feature branches, even if they\&#39;re short lived. Sounds just like a good PR based process to me.\nYou probably don\&#39;t have to support multiple release lines, so you can omit the release branches.&#39;, &#39;What is this ChatGPT response bro (new)&#39;, &#39;For the most part, we ran our test suites on AWS Spot instances, using Buildkite agents, highly parallelized aimed at keeping full runs of the test suite under 10 minutes.\n\nWe had some integration tests that would run in these environments but these were more aimed at demos/click testing.  Most automated tests ran in CI pipelines outside of this that would just spin up more agents as needed.\n\nIdle developers cost more than spot instances, so we would spin up more agents automatically. (new)&#39;, &#39;https://trunkbaseddevelopment.com/\n\n“Depending on the team size, and the rate of commits, short-lived feature branches are used for code-review and build checking (CI), but not artifact creation or publication, to happen before commits land in the trunk for other developers to depend on. Such branches allow developers to engage in eager and continuous code review of contributions before their code is integrated into the trunk. Very small teams may commit direct to the trunk.” (new)&#39;, &#39;Got it. And what kinds of automation tests were these? Were these microservice API tests or more like unit tests? Looks like these weren’t run on the review environments but rather the staging environment? (new)&#39;]</td><td class="s12" dir="ltr">[&#39;Accelerate release cycles (+)&#39;, &#39;Adopt CI/CD pipelines for automated integration and delivery&#39;, &#39;Automate code quality checks (linting, testing, analysis)&#39;, &#39;Automate test execution (unit, integration, e2e)&#39;, &#39;Automated build and tests always pass on the CI&#39;, &#39;Commit frequently (daily)&#39;, &#39;Containerization and orchestration tools used&#39;, &#39;Deploy frequently and provide fast feedback&#39;, &#39;Enable fast and continuous feedback (+)&#39;, &#39;Enforce discipline for stable builds and testing&#39;, &#39;Feature flag complexity and debt management required&#39;, &#39;Integrate CI/CD tools&#39;, &#39;Mandatory code review policy&#39;, &#39;Promote frequent and rapid integration (CI) (+)&#39;, &#39;Reduce merge conflicts (+)&#39;, &#39;Requires robust testing and test infrastructure (-)&#39;, &#39;Requires strong discipline and team coordination (-)&#39;, &#39;Shortens automated feedback cycles by testing each trunk commit against the main codebase through CI/CD pipelines (+).&#39;, &#39;Simplifies the development workflow (+)&#39;, &#39;Support safe experimentation and rollback&#39;, &#39;Transparency is emphasized, ensuring developers are aware of the current build status and rollout information.&#39;, &#39;Use a single shared trunk&#39;, &#39;Use feature flags to safely integrate incomplete features&#39;, &#39;Use feature flags to decouple deployment from release&#39;, &#39;Use short-lived branches&#39;, &#39;Avoid big-bang merges&#39;, &#39;Provision ephemeral review/test environments per pull request or branch for pre-merge validation in trunk-based workflows (new)&#39;, &#39;Automated environment cleanup (destroying test environments after merge to trunk/main) (new)&#39;]</td></tr><tr style="height: 30px"><th id="958685326R13" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">14</div></th><td class="s2" dir="ltr"><span class="s3" style="background-color: #ddebff; color: #2a3243; width: 147.0px; max-width: 147.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">devops</span></td><td class="s4" dir="ltr">Developers are working at 2am to release to production. How can we help them?</td><td class="s5" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/devops/comments/1innblx/developers_are_working_at_2am_to_release_to/">https://www.reddit.com/r/devops/comments/1innblx/developers_are_working_at_2am_to_release_to/</a></td><td class="s5" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/devops/comments/1innblx/developers_are_working_at_2am_to_release_to/">https://www.reddit.com/r/devops/comments/1innblx/developers_are_working_at_2am_to_release_to/</a></td><td class="s6" dir="ltr"><span class="s3" style="background-color: #d5deeb; color: #383a3c; width: 128.0px; max-width: 128.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">YANLIŞ</span></td><td class="s4" dir="ltr">[&#39;Developers are working at 2am to release to production. How can we help them? (new)&#39;, &quot;In the start-up I currently work at, most production releases degrade our site performance in some way. So the developers have taken to releasing in the early hours while our web traffic is at its lowest and less users are impacted. Obviously this leads to very unhappy developers, more stress, more mistakes and it&#39;s ultimately a problem for the company growth, because we&#39;re not delivering features effectively. I really want to help stop this before it becomes normalised.\n\nI don&#39;t know why exactly most changes are impacting the performance so much. I do know that releases happen in big-bangs. There&#39;s no feature flagging or incremental releases here. We don&#39;t deploy with GitOps, it&#39;s all push-based. On the upside our stack is pretty modern (AWS/EKS), not that complicated and we don&#39;t depend on much legacy. Our devs are also pretty good at owning their services so I think there&#39;s space to make things better.\n\nI have a whole bunch of terms that I think could help. Namely, trunk-based development, feature flagging, canary deployments, blue-green deployments, shift-left, blah blah blah. I know what most of these things are but I&#39;ve never really implemented them and I&#39;m not clear on their relation to each other. So I&#39;m curious to hear specifics on how you&#39;ve addressed problems like this. Thanks!\n\nEdit: Thanks for the suggestions. I feel like I&#39;m mostly aligned with what&#39;s been written here. We are organising a group session with our product &amp; tech department in a few weeks. This is something I will raise.&quot;, &#39;Firstly, I\&#39;d be looking into improving monitoring and collecting data to better understand what\&#39;s causing these issues. If you have proper observability (APM, log, metrics) in place, correlating changes with impact should be easy.\n\nIt sounds like the deployment process isn\&#39;t really &quot;DevOps&quot;, large changes are much more likely to cause issues and are significantly harder to test for regressions. Short-lived branches, small changes, and frequent deployments through CI/CD will help a lot here. The way it works at the moment will reduce confidence across the board and make people more risk-averse, from experience I know you need to get this sorted now before things spiral.&#39;, &#39;You are throwing in terms that, some of them at least, are irrelevant.\n\n1: automate their way of deploying.\n\n2: look into blue green deployment. This will also enable you to switch back if a deployment has issues/big bugs and you can switch environment after it has spun up removing the ramp up time.\n\n\nSecond is, they should professionalise their processes as developers. Can’t have big bangs and manual push deployments in 2025 on greenfield projects. (new)&#39;, &quot;I would recommend joining ath 2am release and try to measure the performance impact and find out why your releases are causing problems. Even if you&#39;re doing regular releases with feature flagging and trunk based development, it sounds like there&#39;s a deployment pipeline or cluster issue. \n\nThings like GitOps, trunk based development, feature flagging, canary / blue-green deployments are great for de-risking and removing the toil of releases. But if your issue is performance during it, then something else is fundamentally wrong.&quot;, &#39;This sounds like a startup problem at multiple levels.\xa0\n\n\nOverworking devs now on barely sufficient cloud resources seems like a good way to save a buck on salary and cloud bills, but it will bite you in the ass when you have to replace burnouts and train them up. You can suggest improvements, but you have to convince management to buy in.\n\n\nI\&#39;d go for daytime updates if possible, with a &quot;flight of the canary&quot; approach with smaller changes. Deploy improvements for 0.1-1% of the users, and raise this incrementally to around 20% while fixing issues. This should lead to insignificant changes in pod numbers and your devs will have time to fix before full sending an update, but needs robust logging and monitoring to catch issues fast. Tagging the shit out of every resource helps immensly.\xa0\n\n\nIf you do big changes like new DB schemas, go for a blue-green approach, spin up a new db, new deployment and do a slow shift on the LB. Utilize PDBs to make the transitions safer. Will\xa0raise the cloud bill momentarily, but much less stressful. All of this should be done with GitOps IMO, much more control and visibility. Deploys should be as easy as point Argo to the new branch and pop in the new image tags. Rolling back is a breeze too. (new)&#39;, &quot;&gt;production releases degrade our site performance in some way\n\nHow?\n\nThe answer to that question determines the best approach. I&#39;m not suggesting getting into the specific details, but more the general shape of how each different deployment impacts the performance. Is the deployment process itself causing the issue? Look into changing the process, blue-green deployment is a good strategy. Is the performance of the new code not scaling and people need to tweak it? Creating a stress environment that can simulate user traffic helps, and again a blue-green deployment that slowly scales traffic to the new version. Is it modifying large databases? Having a better DB design that prioritizes deployment changes helps.\n\nThis seems to be a systemic issue so look for systemic causes and then look for alternative approaches at the same level. More than likely your deployment method will need to become more complicated to account for the complexity but being able to deploy during working hours is a good justification for the additional complexity. (new)&quot;, &#39;Blue green, automated testing, performance testing in pre production environments. Every change should be performance tested (new)&#39;, &#39;There\&#39;s almost certainly issues in the architecture and/or code that ultimately need to be addressed.\xa0 That\&#39;s a longer conversation that probably starts with instrumenting application performance monitoring to understand what is going on, where your bottle necks are.\n\n\nBut, to slow the immediate bleeding my first bandaid would be a real blue/green with rolling DNS to ease traffic over.\xa0 Route 53 weighted records can handle that part.\xa0 I\&#39;d recommend a completely separate cluster for blue and green, don\&#39;t share anything other than the data resources.\xa0 The nice feature of a real blue green like this is that no matter how bad the deploy blows up, your original site is untouched and ready to have DNS swap traffic back over.\n\n\nI\&#39;ve got a few &quot;problem children&quot; that deploy this way.\xa0 The safety gives everyone more confidence and the rolling cut over lets the new green warm up even under peek traffic.\xa0 But def get APM going and find out what the real startup issues are. (new)&#39;, &#39;You need to read most of https://minimumcd.org, and https://dora.dev/capabilities/\n\nTrunk-based development, continuous integration, automated testing.&#39;, &#39;Based on the information I assume you are not senior engineer. Your organization must have senior personnel who can handle those decisions. There are many reasons as to why a release will degrade the performance of a system and for each one there are multiple ways of mitigating it.\n\nThe only sane reason IMO do to deployment at night is when an outage is required. (new)&#39;, &#39;You should look into &quot;zero downtime release(s)&quot;. It should not affect users at all to deploy (and release) changes. (new)&#39;, &#39;pizza? /s (new)&#39;, &#39;Why do production releases degrade site performance?\n\nOn Kubernetes you can use GitOps, concretely, Argo CD, to support zero-downtime deployments. (new)&#39;, &quot;Your first step is to look at the test coverage of the components being deployed, you want a driving factor of your CICD pipeline to be thorough testing. You want unit tests, integration tests, and synthetic tests.  Lack of testing and skipping on test development slows down your ability to deploy during normal working hours.\n\nFor synthetic tests we&#39;re talking about simulating your end user behaviour, to make sure the things they can do continue to work. Either at the API level or replicating user behaviour through browser automation.\n\nYour deployments should involve an aspect of running tests against the deployed workloads.\n\nYou&#39;ll need to combine that with Observability and APM.\n\nYou&#39;ll want to advise the developers to focus on building their components, if they are not already, on idempotent actions (mutations) and ensuring that components are horizontally scalable. There should be zero problems running 1 or 10+ instances of a component.\n\nThat should give you all the grounding you&#39;ll need for canary or blue/green deployments.\n\nAt this stage the developers, QA teams, and testers, should have the confidence and ability to deploy at anytime during the day.  The only concerns at this stage are database changes, but with care and planning it is perfectly manageable.\n\nBy this point you should also be getting pretty close to using trunk based development or using small short lived branching. A good measure to seeing progress towards trunk based development and appropriately sized small items of work is to see daily commits from developers with good commit messages. If they&#39;re anything like we were you had long lived branches, poor commit hygiene, days between commits that were huge, and tasks that were poorly understood, sized, scoped, and assigned to the wrong people without involving the subject matter experts to get the size, scope, and details right.\n\nFor the DevOps people, you&#39;ll want to migrate the surrounding infrastructure to GitOps or something similar for declarative infrastructure as code. These are things like their nginx ingress systems, Prometheus, grafana, aws-load-balancers, that are much easier to manage declaratively and easier to deal with upgrades and scaling.\n\nOthers will have different advice based on their experience, this is the process we used as an SME operating in NZ/AU.&quot;, &quot;1. Heck yeah, trying to make things better!\n\n2. This is a pretty big undertaking that&#39;s going to need a lot of support from all over. \n\n3. For a win in the short term, I&#39;d look at what the lowest hanging fruit is - what can be done easily and right now in order to make things easier? (new)&quot;, &#39;Sounds like a job for the architects really; but rolling deployments with load balancing is the best way in my opinion (new)&#39;, &#39;ah probably the standard management issues, throw everything in the release etc, but ideally those things would be caught even before the release by capable QA people. (new)&#39;, &#39;I had been a team where we see this type of behavior where every time we push new release we see these type of behavior where something break or another client functionality has issues. As we deployed to AWS we implemented some of the practices which everyone mentioned here, but for me what helped me more is having a good unit and behavioral testing. Especially behavioral testing is very good to quickly check what developers push break something and it fails at the pipeline level and it gives a good indication something is not right. Second is features flag, it gave you that peace of mind what you develop with confidence that even if something happens you can turn off that specific feature.\n\nImproving this type of software development methodology requires a lot of commitment from the leadership and have the infrastructure to fail safely. \n\nBut I will always recommend try to improve one thing at a time. (new)&#39;, &quot;I&#39;ve been on the developer side of this before working 9am - 8am next day due to promises made to deploy regardless on date x. It leads to a mess and everyone grumpy.\n\n\nIn the release pipeline, how are you conducting load testing, you should be able to measure performance long before it goes out the door. (new)&quot;, &#39;have you talked to your engineers about it? What do they think? (new)&#39;, &#39;devops is the only way, how you coat with sugar, is your management ability. devs think that when they move on to devops, they will lose control of the code and company; so they avoid it at all costs. (this time it is working until 2am) (new)&#39;, &#39;There are a lot of good comments here so I don’t want to rehash them all. Think of it this way, it should be the goal of the engineering organization (including dev and devops) to prevent a bad checkin from brining down production. That goal might be aspirational or it might be attainable depending on your org, but it’s the goal. \n\nIt can be achieved with various techniques but it is essentially:\nContinual testing during checkin\nContinual small pushes to staging &amp; prod (ie CD) to whatever environments you have\nOnce deployed, there should be a small, controlled deployment (like blue green or canary) where automated tests can be performed before releasing to the whole user base\nIf anything seems amiss, the whole deployment gets automatically rolled back\nThere should also be a feedback loop (client and service monitoring) that can alert dev if anything is not behaving within normal limits\n\nWith time deployment will be come less nerve wracking. (new)&#39;, &#39;Smaller releases\nStaging environment parity\nBlue/Green deployments\nCulture change (new)&#39;, &quot;The feature flags would be nice but they require changes at the application architecture so the transition to it might be time consuming, but it&#39;s probably the most robust one when implemented well (new)&quot;, &#39;Add passwords and security to everything (new)&#39;, &#39;Wild guess.  Do you have healthchecks for every service, and then do an isolated release where you’re changing only the smallest amount of code possible… then measure to see if there’s any degradation.  \n\nIMO, that will give you a clear signal if it’s a devops problem or an app engineering problem. (new)&#39;, &#39;Sounds more like a management problem rather than a technical issue\xa0\n\n\nIf you go via this route it will create lots of problems and technical debt (new)&#39;, &quot;Stating the obvious, you have both potential technical issues and a people problem.  I say &#39;potential&#39; because root cause analysis is needed to define what is impacting system performance.  There may be more than one problem or it may be a combination of things.  Others have already left plenty of suggestions for that.\n\nOn the people side, talk to the developers.  Whenever my team has to deal with legacy code (we&#39;re slowly replacing it) and late night or weekend updates, we give them comp time once we&#39;re comfortable that things have settled down.  Until you fix the technical issue(s), the people problem isn&#39;t going away on its own. (new)&quot;, &quot;&gt; In the start-up I currently work at, most production releases degrade our site performance in some way.\n\nThis should never, ever, be the case.\n\nReleases may degrade site *traffic* in some way, because search engines and social media platforms may need to index new stuff. Not much anyone can do about that other then ensuring URL&#39;s remain consistent ie. no URL stubs ever changed, only added and API&#39;s are versioned for CSR.\n\nBut none of that should have any bearing on the performance of the site itself. If it does, your architecture is fundamentally flawed and you need to start over again from scratch.\n\n&gt; Namely, trunk-based development, feature flagging, canary deployments, blue-green deployments\n\nTrunk based dev isn&#39;t relevant to the problem.\n\nFeature flagging and canary deployments are not relevant as they chose to go with a service based architecture (because reasons?).\n\nblue-green deployments + some DNS witchcraft are essentially what you&#39;d need to have in place to do feature flagging / canary deploys.&quot;, &quot;IN A FEW WEEKS?! Your leadership really doesn&#39;t care about customers, huh.\n\nThis is madness. That meeting needs to happen ASAP. Your devs need sleep. (new)&quot;, &quot;&gt; most production releases degrade our site performance in some way\n\nStop releasing changes that do not match, improve, or plannedly degrade the site performance. If you must apply a gate to this, put a job in your CI that must pass before deployments that checks benchmarks. If you don&#39;t have benchmarks / tests, add them.\n\nYou could also maybe mean that the deployments operations itself cause downtime, then you should look into fixing that. If it&#39;s not apparent what&#39;s happening (from documentation or monitoring), improve monitoring first. It should be easy to correlate changeset to problems and dive deeper into those problems. If it&#39;s Kubernetes related, make sure your YAMLs are configured correctly with min/max replicas, requests, probes..\n\nIt could also be related to service inoperability. There you have to implement better e2e testing. This might mean setting up full envs with different service versions from a single job, and then running a test suite to make sure core functionality is OK and performant enough. You could also run one against main e.g. hourly during the workday, to make sure main stays bug free.\n\n&gt; I don&#39;t know why exactly most changes are impacting the performance so much.\n\nIn any case, identify the problems with releases first and think about solutions next. To me it sounds like you might benefit from validating your changes (testing / CI) before releasing them. (new)&quot;, &#39;Their code is garbage, not sure if you can fix that in the short term. (new)&#39;, &#39;Sounds like your application infra is not very scaleable or redundant. (new)&#39;, &#39;This is technical debt, treat it as such and fix it. (new)&#39;, &#39;Oddly no one suggested reading the phoenix project. While doing all the other things you learnt here, also read that book 😉 (new)&#39;, &quot;You want to do small changes, frequently. Yes, you&#39;re going to want to do canary releases and/or blue-green, but the real issue is your changes are too big to test adequately. If they aren&#39;t doing it already, they should start using test driven development. Then when they push small changes, they ci/cd process should catch any issues. The process of rolling back is also dramatically simplified. Additionally, since the changes are much smaller, you have a much better idea of where the potential problems may arise. This means that the process of manually validating your changes should be much quicker.\xa0\n\n\nIf anything, I would advocate for a rule against pushing non-emergency changes outside of normal business hours. You want all hands available in case there is a major breaking change. Additionally, you want to surface performance based issues quickly, so they can be rolled back. Ideally this should be done with rolling to a test environment which is constrained, and caught there, but not all performance issues can be replicated in a test environment.\n\n\nLook at googles site reliability engineering book. It&#39;s free online, and I imagine it will help significantly. (new)&quot;, &#39;Blue/Green deployments with Traffic Splitting using Flagger or Argo Rollouts (new)&#39;, &#39;I just setup auto rollback and zero downtime deployment so just deploy things when ready k8s manages the rest and just doesn’t promote a container if not working. (new)&#39;, &#39;I am not sure about the website functionality and purpose\n\nNot releasing to production at weird times like a Friday evening or before a 3 day weekend are good practices. \n\nI am not sure about the 2 am. 2 am may be a good time to release to production because traffic at 2 am might be the lowest. (new)&#39;, &quot;Startups, oh man. You can learn so much and die inside so fast.\n\nIf you insist on trading your life force and some grey hair and maybe a little early onset cancer to work there, my suggestion is to educate the company on better release management practices which will require better testing environments, processes, etc.\n\nYou&#39;ll need to implement some strict branching strategies and so on. It&#39;s not only just about your tech Stack and blue green. A blue green doesn&#39;t prevent a service from going down, it just gives you a relatively simple way to revert. The problems that caused the back out still need to be solved.\n\n\nIn a startup this is often because people don&#39;t have a lot of time to do the testing in lower environments and the testing that is done isn&#39;t very thorough. The budget to have a full production like environment may not be there. \n\nThe leadership might be changing directions too often or making too many promises and because they think being agile and lean and nimble makes them Elon Musk but in reality they are just fucking up dead lines, causing double work, and making it impossible for the project and product teams to do their job with any sort of structure which throws planing mechanisms in the trash which makes life for devs and ops hectic due to the short cuts that need to be taken to meet said deadlines which override any processes and education you try to implement. Pissing in the wind. \n\nIf you spend time with the team this honestly shouldn&#39;t be too difficult to identify, the trouble is instituting change. (new)&quot;, &#39;Feature flags; a/b deployments; you should only really need to take an outage for database table updates. (new)&#39;, &#39;When I read &quot;big-bangs&quot; and releases that affect performance, I\&#39;m suspecting you\&#39;ve got your hands on a \&#39;distributed monolith\&#39;, where even though you\&#39;re using microservices hosted on containers and all the good stuff, the services are tightly coupled and if you\&#39;re extra unlucky even reading from the same database tables. \n\nIf you\&#39;re running containers on EKS it should have no issues starting new containers, which is essentially what a new release does. The fact that that\&#39;s an issue means there is something wrong in the application architecture, not in the infrastructure or release process. (new)&#39;, &#39;Why do they need to work until 2am? Just make the release in normal working hours and push to prod at 2am. I don’t get it (new)&#39;, &#39;Lots of good suggestions in these comments \n\nOne basic thing \n\nCheck your kubernetes (deployment entity  most likely) yaml max unavailable settings to make sure that you aren’t telling the scheduler that you are fine w reducing the number of pods needed to be healthy during a deployment to a degree that impacts performance (new)&#39;, &quot;OP makes it sound like devs push to prod at 2am because it&#39;s the only safe low impact option.  I have never seen devs choose to do this unless a system is so incredibly fragile they expect it shatters on every release and has a huge impact ...  if that is the case you&#39;re right the process isn&#39;t really devops. \n\nI have addressed problems like this before in fact I do it all the time, so I would say the situation is common.  Not the 2am part, that is crazy, but fear of brittle systems breaking,\n\nThe pushes here feel like the scene from jurassic park where the guy says hold on to your butts (new)&quot;, &quot;I&#39;m curious as to what Short-lived branches and small changes means here.\n\nFor an example if you work in fintech, it&#39;s a bit too risky to let developers fire and forget deployments on their own&quot;, &quot;We don&#39;t have much dependency on our database thankfully. I&#39;m leaning towards the canary deployment, I feel it suits our use-case quite well. Thankfully I also don&#39;t think it will be that hard to convince management. They&#39;re pretty hands-off and they&#39;d be open to these kind of ideas if it means releasing more efficiently.\n\nI feel the harder part will be getting developers out of their current habits. Changing a culture is always difficult. (new)&quot;, &quot;At least for getting rid of the need to release at 2am, I was leaning towards canary deployments as a &#39;quick win&#39;. At least then they can hopefully release in the day, only impact a small percentage of users and gradually move the traffic over as it improves. I haven&#39;t done it before though so I wanted to check my understanding. More than canary deployments need to be done to get to the root of the problem though. (new)&quot;, &quot;Sincere question: how many architects have you worked with that are actually doing anything useful, at all? After 20 years in the business, I can only think of two. The worst part, I&#39;m not even kidding. (new)&quot;, &#39;Not yet. We are organising a group session in the next few weeks and this is a matter I want to raise. In some ways this post was preparation for that (new)&#39;, &#39;Yet nobody does anything to improve? Give them the right tools, set it all up for them and then they just don’t look at it (is my experience) (new)&#39;, &#39;We’re in this state right now (also doing early deploys) and I’m trying to get us back to something more reasonable.\n\nWhats biting us is it takes about 40 minutes to build our image, and the image itself ends up being about 10gb. So of course that’s a tough thing to lug around to different environments.\n\nWe run thousands of Wordpress sites for our customers, and have media and frontend assets committed for nearly all of them — which makes up a large chunk of the size.\n\nThe intent right now is to shard the platform and build an image for each shard. This is still a ton of data, but at least then we can build them in parallel and release smaller images and hopefully get back to true CICD. (new)&#39;, &#39;I working an highly regulated environment. We have the up to 20 deployments per day.\n\nGetting there requires a lot of automation but it also means that it is very easy to roll out. Since changes are rather small it is easier to catch problems in between deployment and release.\n\nWe reduced our downtimes to once per month instead of once per week. The duration of down times went from 6h down to 15mins. (new)&#39;, &#39;It’s not fire and forget, you still need to apply your SDLC process to each change. \n\nBundling all of your changes into one release just combines and applies the change risk all at once (a large amount of risk applied in one moment)\n\nMaking small and controlled changes frequently allows you to spot defects early and quickly. This spreads the risk over a larger period of time (much smaller amounts of risk, applied in many different moments). (new)&#39;, &#39;bro please go read the DevOps handbook, or even frankly the agile manifesto (new)&#39;, &#39;Small changes are less risky than bigger ones. If you have proper testing and monitoring in place, something going wrong is very quickly caught (in normal scenarios before going to prod). Developers should be able to own the entire thing, specially if one of their deployments causes alarms to go off in prod. If you have small changes that can be pushed by single people than it becomes very obvious what caused it. If you have massive changes with lots of changes/fixes going on to prod at the same time its way harder to know what caused it and almost impossible to revert it. (new)&#39;, &quot;A great approach is to appeal to their laziness, err show them how much more efficient is to just approve a PR and everything goes live in a minute or two. In a perfect world a dev only touches the apps, all infra is magically where it needs to be and that&#39;s where we can shine.\n\n\nThis is where a dedicated DEV environment is also a really nice carrot. They can test anything, fubar the whole thing and then Argo can roll it back to a working state with a click or two. (new)&quot;, &#39;From a bankers perspective - can you not deploy over the weekend, or after normal work hours? Our most critical systems are not allowed releases during Mo-Fri (unless it is a big issue) and those are usually forced into off hours preferably around midnight. The normal releases would take place on Saturdays in the morning, to allow most amount of time to test everything is working before Monday hits.\n\nIf this is not possible, why not look into when you have a lull in traffic?\n\nOther option, get a person dedicated to working on production who will be doing the releases. They can do it as OT or have switched shifts so it is normal work hours for them.\n\nWhichever option you end up with, you must investigate what is causing the performance hit - that should not be happening.\n\nIf you cannot avoid the hit, and you need a way to get out of 2AM without any organisational changes, implement a load balancer system with multiple nodes (you can take down 1 node, deploy, restart. Then take down second node, deploy, restart, etc etc). That way, you can safely carry out releases with minimum impact (you could even do it during normal work hours if you do it right). (new)&#39;, &#39;Honest answer, 1; he was genuinely fantastic.\n\nThe rest have been a waste of space; there is 1 in particular who I am convinced must have taken kick-backs to recommend one particular piece of software (new)&#39;, &#39;Yeah my experience is that a lot of ”architects” are people think they understand some it concepts (eg. microservices) because they read a book and are actually so bad at programming they can’t do it professionally and they just fail ”upwards.” \nIn many places ”architect” is a middle management position and not a techical one. I see programmer and architect as largely parallel functions.\n\nThankfully there are good ones also who know what they are doing and actually understand the concepts and how software works on different levels. Those are just the minority. (new)&#39;, &quot;These answers are a bit depressing to read, one of my many hats is the architect (both software and infrastructure) of our new product and bringing it from concept to live with a multinational customer base. But then I&#39;m also the subject matter expert remaining on the old product the new product replicates and replaces, and actively do the DevSecOps pieces. The only piece of the product I rarely touch is the UI and UX. (new)&quot;, &#39;I\&#39;ve read the DevOps Handbook and the agile manifesto, bro. In my experience these are processes which are a bit self explanatory in the sense that, you see it once and you get what it\&#39;s about. Automating as much as possible whilst introducing some sort of process to get changes in. Agile being much more effective in theory than in practice unless you are scaled up or working on repeat tasks, hence why we now have DevOps which is an efficient way of managing the expectations and technical requirements of an &quot;agile&quot; team.  \nAnd the point is you work on features, not &quot;short-lived branches&quot; which I think is the incorrect nomenclature. You don\&#39;t just release random new log lines to master/prod whenever you feel like it just because you have CI/CD unless strictly necessary or you have the adequate support available. You plan the release, and have the necessary support during working hours.\n\nCanary deployments and the google way of doing things is cool and all that but I\&#39;d rather not get paged because somebody thought it was ok to be a cowboy at 2am because &quot;short-lived branch&quot;&#39;, &#39;In fintech you are also often bound to quarterly releases. This is simply because of regulations and quarterly reports with slightly adjusted algorithms.\n\nDoesn’t mean of course they can’t use proper branching and shouldn’t deploy to dev/test/acc. (new)&#39;, &#39;I’ve an ”architect” tell me how their team had to implement their own versions of filesystem apis on top of the existing ones, because the .NET Framework ones didn’t work. Like copying/moving/renaming files. (new)&#39;, &#39;Honestly, the weird part is that even though the bar is getting lower for each year (the bar for going into my column of &quot;good architect&quot;), people still manage not to get over it.\n\nAt this point, I unironically would find it quite impressive if an architect produced absolutely anything even close to value for me or the project. (new)&#39;, &quot;Honestly - if you read a book on microservices or not... that&#39;s fine. Just at least produce \\_something\\_ of value. Literally just something. \n\n\n\nAnd yes - if you write whatever it is like you&#39;re a 12-year old who&#39;s trying to fill space on his essay and just pad with useless bullshit, we&#39;ll know. \n\n  \nMan, I&#39;m so tired... (new)&quot;, &#39;I think the key part of your reply is &quot;one you of many hats&quot;. We have an architect in my team. He is literally the most useless architect I have ever met, and I\&#39;m honestly unsure what the point of having him in the team is (but the directive comes from above). Even better, he is a part of the &quot;architect\&#39;s guild&quot;, and noone really knows what it is they do. Even looking at the documents they produce from time to time, you really just get confused and surprised they seemingly spend so much time doing... something else. \n\n  \nHowever, there are two people on the team that do the actual architectural work. They\&#39;re not in an official capacity, but it doesn\&#39;t matter - they have proven themselves enough that even the C-suite turn to them on architectural matters. \n\n  \nSo yeah, getting to the point: maybe it\&#39;s different if your job title isn\&#39;t just architect. Maybe that\&#39;s the secret to good architects. (new)&#39;, &#39;What you’ve described is a management and process problem, not a technical one. It’s also proven that Agile is as effective in theory as it is in practice, as well as DevOps. Go look at dora.dev. They do research projects that prove with empirical evidence that these things help efficiency within organizations.\n\nJust to clarify, the bastardizations of agile that exist today are absolutely the result of semantic diffusion because people make assumptions about what agile should look like, instead of playing it by the book, then they tout this rhetoric online to further their baseless agenda. See: Scrum or even Six Sigma, which is orthogonal to Agile but related in some ways (they took some aspects of lean manufacturing and bastardized and corporatized the things that matter making it much worse.)\n\nAlso software teams should not operate under the guise of being feature factories unless you want dev and product team burnout and infinitely stacking technical debt. I have no idea what you’re on about for most of that reply. (new)&#39;]</td><td class="s7" dir="ltr">[&#39;Accelerate release cycles (+)&#39;, &#39;Adopt CI/CD pipelines for automated integration and delivery&#39;, &#39;Automate code quality checks (linting, testing, analysis)&#39;, &#39;Automate test execution (unit, integration, e2e)&#39;, &#39;Automated build and tests always pass on the CI&#39;, &#39;Commit frequently (daily)&#39;, &#39;Containerization and orchestration tools used&#39;, &#39;Cultural or organizational resistance is common (-)&#39;, &#39;Deploy frequently and provide fast feedback&#39;, &#39;Enable fast and continuous feedback (+)&#39;, &#39;Encourage team collaboration and communication (+)&#39;, &#39;Feature flag complexity and debt management required&#39;, &#39;Feature flag complexity and debt management required (-)&#39;, &#39;Improve software quality and stability&#39;, &#39;Initial migration effort was significant. (-)&#39;, &#39;Integrate CI/CD tools&#39;, &#39;Make small, frequent commits&#39;, &#39;Promote frequent and rapid integration (CI) (+)&#39;, &#39;Reduce merge conflicts (+)&#39;, &#39;Reduced lead time helps deliver features and fixes faster, respond to user feedback more quickly&#39;, &#39;Requires robust testing and test infrastructure (-)&#39;, &#39;Requires strong discipline and team coordination (-)&#39;, &#39;Shortens automated feedback cycles by testing each trunk commit against the main codebase through CI/CD pipelines (+).&#39;, &#39;Simplifies the development workflow (+)&#39;, &#39;Staged rollout with rollback support&#39;, &#39;Support safe experimentation and rollback&#39;, &#39;Tooling includes quality and monitoring support&#39;, &#39;Transparency is emphasized, ensuring developers are aware of the current build status and rollout information.&#39;, &#39;Use a single shared trunk&#39;, &#39;Use feature flags to safely integrate incomplete features&#39;, &#39;Use feature flags to Support progressive delivery (A/B testing, dark launches)&#39;, &#39;Use feature flags to decouple deployment from release&#39;, &#39;Use short-lived branches&#39;, &#39;Avoid big-bang merges&#39;]</td></tr><tr style="height: 30px"><th id="958685326R14" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">15</div></th><td class="s8" dir="ltr"><span class="s3" style="background-color: #dbeeef; color: #133819; width: 147.0px; max-width: 147.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">softwaredevelopment</span></td><td class="s9" dir="ltr">Do you know any good non blocking review tools like upsource? (Which is discontinued)</td><td class="s10" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/softwaredevelopment/comments/1kg94nu/do_you_know_any_good_non_blocking_review_tools/">https://www.reddit.com/r/softwaredevelopment/comments/1kg94nu/do_you_know_any_good_non_blocking_review_tools/</a></td><td class="s10" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/softwaredevelopment/comments/1kg94nu/do_you_know_any_good_non_blocking_review_tools/">https://www.reddit.com/r/softwaredevelopment/comments/1kg94nu/do_you_know_any_good_non_blocking_review_tools/</a></td><td class="s11" dir="ltr"><span class="s3" style="background-color: #d5deeb; color: #383a3c; width: 128.0px; max-width: 128.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">YANLIŞ</span></td><td class="s9" dir="ltr">[&#39;Do you know any good non blocking review tools like upsource? (Which is discontinued) (new)&#39;, &#39;Has anyone out there used RhodeCode for non-blocking reviews in trunk based development? \nI am looking around for tooling to support trunk based development with non-blocking reviews as I have seen the velocity, knowledge sharing and quality it brings to teams. \n\nHowever, as Jetbrains have discontinued their tools (upsource, Space and another) I have trouble finding a new tool that supports the process. \nUsing github actions is a really complicated approach with a truly underwhelming result.... \n\nI hope someone knows good tools to support the development process:-) \n\nFor more in depth context you can read this:\nhttps://itnext.io/optimizing-the-software-development-process-for-continuous-integration-and-flow-of-work-56cf614b3f59&#39;, &#39;gerritt is very tbd focused.  https://gerrit-review.googlesource.com/Documentation/intro-gerrit-walkthrough.html (new)&#39;, &#39;The flow i want:\n\nMake code change. Do whatever QA you want. \nIntegrate by committing and pushing to origin\nAutomated test run on the build server and artefacts deployed to test. \nReview is created and other team members can go through the code and comment and provide feedback. (Some system of open reviews should show what reviews are pending) \n\nDoes gerritt support that flow? \n\nThe purpose is to have efficient integration of ongoing work and get it into test quickly, and small batches of change. Featuretoggles are used to isolate WIP from being used in production. (new)&#39;, &#39;this is a pretty standard workflow..  gitlab, github, etc support this.  I havent used gerrit, i thought you wanted a stronger tbd approach which gerrit is tailored to. (new)&#39;, &#39;GitHub and similar does not support structured reviews without pull requests. \nWe want to review our code. We want people to see what is pending and we want to have a structured way to provide feedback for the committer. \n\nI have found no way to do that in a good way i GitHub. \n\nWhat in Gerrit makes it stronger for tbd? (new)&#39;, &#39;In gerrit if you don’t push directly but push for “review” you can configure it to only require CI votes, and after submit it’s still possible to provide comments or still possible to filter merged changes that has unresolved one. Thats not default workflow but definitely possible to not have CR+2 vote as submit requirement or to allow author to give CR+2 (I use gerrit and i like to review changes myself as first layer) (new)&#39;, &#39;draft prs are what i use. on push workflows dont need a pr so you can do whatever you want, ping a slack channel, email a team. (new)&#39;, &#39;Ok. It does not sound like what I am looking for:-( (new)&#39;]</td><td class="s12" dir="ltr">[&#39;Enable fast and continuous feedback (+)&#39;, &#39;Promote frequent and rapid integration (CI) (+)&#39;, &#39;Use feature flags to safely integrate incomplete features&#39;, &#39;Use a single shared trunk&#39;, &#39;Simplifies the development workflow (+)&#39;, &#39;Automate test execution (unit, integration, e2e)&#39;, &#39;Automate code quality checks (linting, testing, analysis)&#39;, &#39;Use non-blocking code review tools to support rapid trunk integration (new)&#39;]</td></tr><tr style="height: 30px"><th id="958685326R15" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">16</div></th><td class="s2" dir="ltr"><span class="s3" style="background-color: #ddebff; color: #2a3243; width: 147.0px; max-width: 147.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">devops</span></td><td class="s4" dir="ltr">Does it make sense to use trunk based development with canary deployments?</td><td class="s5" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/devops/comments/1g1gr6s/does_it_make_sense_to_use_trunk_based_development/">https://www.reddit.com/r/devops/comments/1g1gr6s/does_it_make_sense_to_use_trunk_based_development/</a></td><td class="s5" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/devops/comments/1g1gr6s/does_it_make_sense_to_use_trunk_based_development/">https://www.reddit.com/r/devops/comments/1g1gr6s/does_it_make_sense_to_use_trunk_based_development/</a></td><td class="s6" dir="ltr"><span class="s3" style="background-color: #d5deeb; color: #383a3c; width: 128.0px; max-width: 128.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">YANLIŞ</span></td><td class="s4" dir="ltr">[&#39;Does it make sense to use trunk based development with canary deployments?&#39;, &quot;I&#39;ve been reading a lot about deployment strategies recently to decide what to go with for my early stage startup. Stability is important as it&#39;s a website for lawyers to run their practices.\n\nI want to do trunk based development, but wondering if it makes sense to pair it with canary deployments? \n\nSay upon a release to production, for the next 24 hours, only 10% of users are routed to the new version. Given that no issues are caught over that period, all users are then routed to the new version.\n\nThe benefit is that any issues caught in production will affect only a small portion of users.\n\nThe drawback is some (minor?) complexity in setting this up with gcp cloud deploy, as well as monitoring canaries for every release.\n\nShould I implement canary relases?&quot;, &#39;Canary releases are a good idea.\n\nI don’t really see why your branching strategy is part of the question. (new)&#39;, &#39;These are orthogonal concerns. (new)&#39;, &#39;Maybe Feature Flags could help you here? (new)&#39;, &#39;With trunk based development and a good automated deploy pipeline, you could easily have more than deployment per day. With a good automated test suite, this should not cause many issues.&#39;, &#39;Hi, I am building a solution on this, would love to know the feedback.  \n[https://gradualrollout.com](https://gradualrollout.com) (new)&#39;, &#39;right, its not related (new)&#39;, &#39;how so (new)&#39;, &#39;Setting up the tooling for canary deployments, feature flags, blue/green deployments, etc early in the life of an app seems like a good idea to me.\n\nIf you can start on automated post deployment tests that will also pay a ton of dividends. Even if you still have a manual sanity check before full deployment and the automated test is just to check that the app is up, you can lay the groundwork for future fully automated deployment. (new)&#39;, &#39;By separating deploy and release - the canary release is orchestrated by the toggling of flags and not by the deployment of a binary with the functionality hardcoded into it.\nA rollback is also a flag toggle and not a redeployment. (new)&#39;, &quot;What&#39;s processing the flags?  If you are talking about application code, that doesn&#39;t work for everything that benefits from canaries.  If you are not talking about application code, can you tell me more? (new)&quot;, &#39;How do I remotely toggle a flag? (new)&#39;, &#39;Look up launch darkly. It’s a feature flag company. (new)&#39;]</td><td class="s7" dir="ltr">[&#39;Adopt CI/CD pipelines for automated integration and delivery&#39;, &#39;Automate test execution (unit, integration, e2e)&#39;, &#39;Deploy frequently and provide fast feedback&#39;, &#39;Enable fast and continuous feedback (+)&#39;, &#39;Feature flag complexity and debt management required&#39;, &#39;Promote frequent and rapid integration (CI) (+)&#39;, &#39;Shortens automated feedback cycles by testing each trunk commit against the main codebase through CI/CD pipelines (+).&#39;, &#39;Support safe experimentation and rollback&#39;, &#39;Use feature flags to safely integrate incomplete features&#39;, &#39;Use feature flags to Support progressive delivery (A/B testing, dark launches)&#39;, &#39;Use feature flags to decouple deployment from release&#39;]</td></tr><tr style="height: 30px"><th id="958685326R16" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">17</div></th><td class="s8" dir="ltr"><span class="s3" style="background-color: #ddebff; color: #2a3243; width: 147.0px; max-width: 147.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">devops</span></td><td class="s9" dir="ltr">Fun post about git processes. How would you structure your code for your robot vacuum company?</td><td class="s10" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/devops/comments/1fe5sy0/fun_post_about_git_processes_how_would_you/">https://www.reddit.com/r/devops/comments/1fe5sy0/fun_post_about_git_processes_how_would_you/</a></td><td class="s10" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/devops/comments/1fe5sy0/fun_post_about_git_processes_how_would_you/">https://www.reddit.com/r/devops/comments/1fe5sy0/fun_post_about_git_processes_how_would_you/</a></td><td class="s11" dir="ltr"><span class="s3" style="background-color: #d5deeb; color: #383a3c; width: 128.0px; max-width: 128.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">YANLIŞ</span></td><td class="s9" dir="ltr">[&#39;Fun post about git processes. How would you structure your code for your robot vacuum company? (new)&#39;, &quot;Hello, sorry for shitpost, this is not to find out the actual practices in Roborock, this post is only for fun for us to discuss (surprise, git workflow strategy). (Also this is not a product promo, just using them as example, I myself purchased different brand.)\n\nI recently was looking to buy a robot vacuum cleaner only to find out that there are just so many brands and models. Crazy. But as a devops person, I was wondering about something in particular. One of the RVC brands, Roborock, has about 20 robots, all with different features. You want mop, but no auto mop cleaning, fine, this model. You want auto mop cleaning - then another model. Also want to dry mop? here is another. Oh btw obstacle avoidance is not very good, for that you need yet another robot with 2 or 3 cameras. Or maybe a better onboard CPU.\n\nThe mobile app also is well received, reviewers say that it provides high customisation and a lot of features.\n\nAnd this is where I started to think: how do Roborock actually keep and organise their codebase to support so many different robots so well and keep people happy? (Now, don&#39;t take my word for it. I ended up buying different brand!)\n\nIt must be to do with a good organisation of code in git and git processes. What do you think? My thoughts are:\n\n* trunk based development. they must be using one firmware for all robots, supporting various hardware options like CPU. and they use feature flags, this explains high customisation level in the app.\n* Ok, maybe not TBD. Then, they are still using one firmware for all robots, but they have main branch for customers, and development branch for testing.\n* Oh no, they do not support one firmware for all robots. Each robot series have their own branch in git. Multiple production branches. But I imagine that would be quite difficult to maintain nthe codebase, to share some features between branches.\n\nOr am I just talking nonsense here?&quot;, &#39;Is this a monologue? (new)&#39;, &quot;The reality of most embedded development is that the product team just about cobbles the release firmware for that particular model (or model series if you&#39;re lucky) with a load of hacks and shortcuts, dumps the code somewhere where it can be forgotten about, and then moves onto the next model. Rinse and repeat.\n\nThe hardware team has probably completely changed the MCU used for the next model, because of cost cutting or a new feature that needs a new hardware requirement, and you&#39;re back to square one with a new SDK from the MCU manufacturer that works differently, potentially a completely different architecture. The old firmware gets rifled for any code that can be ported across to save time, but that&#39;s about it.\n\nFirmware updates don&#39;t happen very often, because to do so involves unfreezing the old codebase for that model, doing the update in-situ, retesting and requalifying everything, then hoping that not too many devices get bricked by the update. All for devices that aren&#39;t bringing in any money, because they&#39;ve already been sold.\n\nYou&#39;re lucky in embedded development if you have a CI process or really any concept of a single codebase at all.\n\nThings are changing for the better with de-facto standardisation on Linux-on-ARM, unit tests, and the gradual seeping in of better software development methodologies, but it&#39;s still decades behind what is done for even simple web apps. (new)&quot;, &#39;Also OP it’s probably similar to something like openWRT, that is common embedded practice DevOps or not (new)&#39;, &#39;Very interesting, thank you for the reply. I would have imagined such smart things like these robovacs would run Linux on ARM or something, so you do not have a lot of embedded programming needed for hardware. Just worry about the software. (new)&#39;]</td><td class="s12" dir="ltr">[&#39;Use a single shared trunk&#39;, &#39;Use feature flags to safely integrate incomplete features&#39;, &#39;Simplifies the development workflow (+)&#39;]</td></tr><tr style="height: 30px"><th id="958685326R17" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">18</div></th><td class="s2" dir="ltr"><span class="s3" style="background-color: #dce9cb; color: #2c481f; width: 147.0px; max-width: 147.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">git</span></td><td class="s4" dir="ltr">Git branching and release</td><td class="s5" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/git/comments/1agl6gv/git_branching_and_release/">https://www.reddit.com/r/git/comments/1agl6gv/git_branching_and_release/</a></td><td class="s5" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/git/comments/1agl6gv/git_branching_and_release/">https://www.reddit.com/r/git/comments/1agl6gv/git_branching_and_release/</a></td><td class="s6" dir="ltr"><span class="s3" style="background-color: #d5deeb; color: #383a3c; width: 128.0px; max-width: 128.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">YANLIŞ</span></td><td class="s4" dir="ltr">[&#39;Git branching and release (new)&#39;, &quot;So I&#39;ve been tasked with coming up with a git branching strategy and writing up yaml pipelines that work with it.\n\nI work in an agency that basically develops projects for other companies and when delivered we move on to the next project. This means that we don&#39;t invest much time in automated tests and don&#39;t have high confidence in stable state of our code. For this reason we can&#39;t use trunk based development or something similar.\n\nWhat I&#39;ve come up with:\n\n3 branches:\n\n* main - long lived\n* feature - short lived, branched out of main, used to develop a feature, make a PR into main, squash commited into main and deleted\n* release - semi long lived, branched out of main when we have a release candidate (i.e. a set of features are ready to be delivered)\n\nDeveloper workflow:\n\n1. Branches out of main to a feature/whatever branch\n2. Writes code, tests it locally, makes a PR into main, someone reviews it, it&#39;s merged into main\n3. Someone tags latest commit on main with a version commit such as: 0.1.0-unstable.0 (I&#39;ll use this format example for following steps)\n4. Pipeline automatically triggers, runs format checks, unit tests, builds and deploys to dev environment\n5. At end of step 4 there is a manual approvement check which developer can approve. If he approves a release/0.1 branch gets created and tagged with 0.1.0-rc.0\n6. This tag automatically triggers release pipeline which:\n   1. pulls latest unstable artifact\n   2. deploys it to qa/test environment where QA team steps in\n   3. waits for manual approvement to be released to production environment\n7. They test out the features:\n   1. if they green light it - dev lead approves release to production and a 0.1.0 tag is automatically created\n   2. if they red light it - new commits are made on release/0.1 branch and when ready dev lead tags it with 0.1.0-rc.1 which repeats steps 6-7 (expect from pulling unstable artifact, this time pipeline builds a new one)\n8. Merge release back into main if necessary\n\nAny thoughts? Too complicated? Too simple? I&#39;m overlooking something?\n\nThanks if you had the will to read this until very end :)&quot;, &#39;This sounds very much like the &quot;stable mainline&quot; branching model.\n\n\nhttps://www.bitsnbites.eu/a-stable-mainline-branching-model-for-git/ (new)&#39;, &quot;This sound like my team workflow. We&#39;re using &#39;main&#39; as the release breanch and &#39;Dev&#39; as the long lived branch.\n\nI think that this method works good for us and not to compilcated for developers who are new to git. (new)&quot;, &quot;Wow, I&#39;ve never actually heard of this.\n\nAt the end it mentions environment branches, which I absolutely hate but everything else is pretty much spot on, with some small differences.\n\nHow do you feel about this? (new)&quot;, &quot;I wrote the blog post, and I still follow it to this day, so I think it has stood the test of time fairly well.\n\n\n\nOne thing I&#39;d point out more strongly today is the value of an automated merge bot (e.g. check out Marge Bot for GitLab) that forces testing (trigger pipeline) on a rebased version of the feature branch before the merge is pushed to the orign (it also giarantees that all merges are serialized without any race conditions). If you don&#39;t have a merge bot, you should simulate it with a good process.\n\n\n\nAs for your suggested flow, it looks OKish (from my point of view). However I&#39;m not a fan of squash+merge (nor fast-forward merges). Cleaning up history before merging - great! Squashing everything into a single commit - no, not as a standard procedure.\n\n\nAlso, I&#39;d like to stress the value and importance of testing *before* merging the feature branch. I.e it should be done as part of development step 2.\n\n\nThe manual tagging and pipeline trigger for creating a release candidate is probably not going to happen for every commit to the main branch - at least not if/when the team is large enough (e.g. when you have 5+ merges per day). It&#39;s also something that could be done automatically on a nightly cadence, for instance. (new)&quot;]</td><td class="s7" dir="ltr">[&#39;Use short-lived branches&#39;, &#39;Use tags for releases&#39;, &#39;Use temporary release branches&#39;, &#39;Automate code quality checks (linting, testing, analysis)&#39;, &#39;Automate test execution (unit, integration, e2e)&#39;, &#39;Mandatory code review policy&#39;, &#39;Automated build and tests always pass on the CI&#39;, &#39;Manual approval in staged releases&#39;, &#39;Promote frequent and rapid integration (CI) (+)&#39;, &#39;Simplifies the development workflow (+)&#39;, &#39;Rebase before merge&#39;, &#39;Use of automated merge bots to enforce serialized merges and ensure tests pass on rebased feature branches before merging to trunk (new)&#39;]</td></tr><tr style="height: 30px"><th id="958685326R18" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">19</div></th><td class="s8" dir="ltr"><span class="s3" style="background-color: #ddebff; color: #2a3243; width: 147.0px; max-width: 147.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">devops</span></td><td class="s9" dir="ltr">Have a DevOps Interview next Thursday. Can y’all see if this would be enough to study for?</td><td class="s10" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/devops/comments/1g1rs7j/have_a_devops_interview_next_thursday_can_yall/">https://www.reddit.com/r/devops/comments/1g1rs7j/have_a_devops_interview_next_thursday_can_yall/</a></td><td class="s10" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/devops/comments/1g1rs7j/have_a_devops_interview_next_thursday_can_yall/">https://www.reddit.com/r/devops/comments/1g1rs7j/have_a_devops_interview_next_thursday_can_yall/</a></td><td class="s11" dir="ltr"><span class="s3" style="background-color: #d5deeb; color: #383a3c; width: 128.0px; max-width: 128.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">YANLIŞ</span></td><td class="s9" dir="ltr">[&#39;Have a DevOps Interview next Thursday. Can y’all see if this would be enough to study for? (new)&#39;, &#39;Hi everyone! I was laid off from my full stack software engineer job several months ago: it’s been rough, but I found a reason to keep my head up. I’ve come across the opportunity to interview as a dev working in databases and DevOps! The interview happens next Thursday. I want to compile a list of important interview topics to study. There’s so many great looking resources on Google, and you can bet I’m going through tutorials to run down Docker, Kubernetes, Jenkins, CI/CD, etc., but I want to know what the common interview questions would be. ChatGPT generated this for me, but I wonder what else I should study for:\n\nGeneral DevOps Concepts\n\n\t1.\tWhat is DevOps, and how does it differ from traditional IT?\n\t2.\tWhat are the main principles of DevOps?\n\t3.\tHow do continuous integration (CI) and continuous deployment (CD) fit into DevOps?\n\t4.\tWhat is infrastructure as code (IaC)? How does it work, and what tools are used for it?\n\t5.\tWhat are the benefits of version control in DevOps pipelines?\n\nCI/CD Tools and Practices\n\n\t6.\tWhich CI/CD tools have you used? Can you explain a typical CI/CD pipeline?\n\t7.\tHow do you handle failures in a CI/CD pipeline?\n\t8.\tWhat is the difference between continuous delivery and continuous deployment?\n\t9.\tHow would you implement automated testing in a CI/CD pipeline?\n\t10.\tCan you explain blue-green deployment and how it reduces downtime?\n\nMonitoring and Logging\n\n\t11.\tHow do you monitor the performance of applications and infrastructure?\n\t12.\tWhat logging tools have you used, and how do you centralize logs for analysis?\n\t13.\tHow would you set up alerts for infrastructure issues?\n\t14.\tWhat metrics are important for monitoring the health of a system?\n\nCloud Infrastructure\n\n\t15.\tWhich cloud platforms have you worked with (AWS, Azure, GCP)?\n\t16.\tWhat is the difference between scaling horizontally and scaling vertically?\n\t17.\tHow would you secure cloud infrastructure?\n\t18.\tHow do you manage costs in a cloud environment?\n\t19.\tWhat is the difference between containerization and virtualization?\n\nConfiguration Management and Automation\n\n\t20.\tWhat configuration management tools have you used (Ansible, Puppet, Chef, etc.)?\n\t21.\tHow do you ensure that infrastructure is consistent across environments (development, staging, production)?\n\t22.\tWhat are your best practices for automating infrastructure provisioning?\n\t23.\tHow do you handle secrets management (e.g., passwords, API keys)?\n\nContainers and Orchestration\n\n\t24.\tWhat is Docker, and how does it work?\n\t25.\tWhat is Kubernetes, and what are its key components (e.g., pods, services, nodes)?\n\t26.\tHow do you monitor the health of Kubernetes clusters?\n\t27.\tWhat is the difference between Docker Swarm and Kubernetes?\n\t28.\tHow do you manage stateful applications in Kubernetes?\n\nSecurity and Compliance\n\n\t29.\tWhat steps do you take to secure a DevOps pipeline?\n\t30.\tHow do you handle vulnerabilities in your infrastructure?\n\t31.\tWhat is role-based access control (RBAC), and how does it apply in DevOps?\n\t32.\tHow do you ensure compliance in a highly regulated industry?\n\nVersion Control and Collaboration\n\n\t33.\tHow do you manage branching strategies in Git (e.g., GitFlow, trunk-based development)?\n\t34.\tHow do you handle merge conflicts during collaboration?\n\t35.\tHow do you use Git hooks for automation?\n\t36.\tWhat’s your experience with managing large-scale code repositories?\n\nTroubleshooting and Problem Solving\n\n\t37.\tHow do you approach troubleshooting issues in production environments?\n\t38.\tWhat’s the most challenging DevOps issue you’ve resolved, and how did you do it?\n\t39.\tHow do you handle failed deployments in a live environment?\n\t40.\tWhat tools and methods do you use for root cause analysis?&#39;, &#39;These are EXTREMELY generic questions, and I can almost guarantee won’t bear any semblance to the type of questions you will be asked during an actual DevOps interview.\n\nIf there are specific platforms mentioned in the JD (ie Terraform, AWS, Ansible, GCP, Python, etc.), you should certainly be comfortable convincing the interviewer(s) you are familiar with them.\n\nTLDR: DevOps is a highly technical role… expect quite a few technical questions. Which ChatGPT won’t necessarily help you answer. If you haven’t yet, I would include the JD in your query, it might help to improve your study guide. (new)&#39;, &#39;I just did a two round devops engineering interview.\nFirst round was general questions like you’ve posted. \n\n1. Which CICD tools you used and what you used it for?\n2. What was your role on the previous company? \n3. Did you write any of the pipelines? If so what did you contribute?\n4. What was your role when it comes to deploying application to the cloud?\n\nIn the second round it was more technical.\n\n1. How did you manage different terraform environments?\n2. How did you manage and deploy database password? How did you make it secure while using terraform?\n3. Say you have a new container based application with about 5 microservices, how would you deploy it?\n4. Can you show us an example of building a Python container image? \n5. Can you write us an example of a pipeline file? Syntax doesn’t have to be exact. (new)&#39;, &#39;Ok this looks good but here’s my honest advice, most of the time these questions are for initial screening, now when it gets technical that’s where it gets tricky to narrow down what to study.\n\nI would also add, watch a YouTube project video also try to know how to actually do things.\n\nI’m sorry but I’ve been in your shoe before and not so long ago.\n\nAll the best. (new)&#39;, &quot;These questions are fine looking on the DevOps tooling.   \nWhat I totally miss are topics related to the underlying infrastructure.   \n  \nThe DevOps job is building the bridge between dev and ops (and security). To understand the needs of ops teams you need to have a profound knowledge on the underlying server infrastructure. Linux mostly. Showing knowledge here is highly appreciated (at least for me). \n\nCI/CD Pipelines don&#39;t build up magically. You have to deal with network issues, filesystem permissions. This still applies when you use servers hosted by cloud providers.\n\nThat&#39;s what I usually focus on as this is often forgotten in CV (new)&quot;, &#39;This is great beginning and that’s what I done when I started (minus ChatGPT). However always look at job description, and take from there. It might happen that what they write on JD is actually useless (had this experience) but mostly it’s useful to understand what company utilizes. However, you just “have to know” to be prepared answer anything. It as well depends on what seniority they are looking for. (new)&#39;, &#39;Initial HR/Screening questions are pretty much the same,technical interviews would be very hard to predict because every team lead has his own methodology. Ive had a technical interview which was 100% drills down on kubernetes sidecar and logging. Literally Nothing else,how could you predict that (new)&#39;, &#39;I just had an interview for a DevOps/ SRE and the manager asked me a bunch of experience related questions, like my technical background, experience working difficult scenarios and how I was able to bridge the gap between other colleagues to reach a goal or solve an issue, etc.\n\nThe engineer then bombed me with some of your topics like the difference between delivery and deployment, and about technologies such as Terraform, cloud providers, config tools, pipelines and automation, Git and versioning, my experience in Linux and so on. Youtube helped me figure out which technologies I needed to focus on and I prepared accordingly. Good luck with your interview! (new)&#39;, &#39;Hi everyone. I don’t step on Reddit often, so I have to say WOW. I really appreciate all the help here.\n\nThe general concept I’m getting from everyone: get hands on experience. I think as long as I get my hands dirty these next few days with pipeline files, Docker files, Kubernetes, and tweak with cloud a little bit, I can develop muscle memory and get the best results.\n\nI appreciate the feedback and advice, everybody! (new)&#39;, &#39;[removed] (new)&#39;, &#39;Totally makes sense! There’s a database part of this interview, so im trying to just write some practice queries for simulation. It can’t all just be theory. Every technical interview I’ve had involved at least one “what would you do in x situation” type of question. So it makes sense that a situational about potentially docker would be there. \n\nThe question I have is how do I prepare for that, and I guess the answer is simply practice, and relate any question I don’t find the answer to with experience I’ve had prior. (new)&#39;, &#39;I know it was a while ago, but how was the interview? Did they ask any of the questions you posted ? Im working on prepping myself. \n\nThank you! (new)&#39;, &#39;you sound like an AI yourself which doesn’t play out very good in these interviews (new)&#39;, &#39;Can you post a link to this? (new)&#39;, &#39;I got the job! Wow, feels like such a long time ago since I posted. Yeah, so I ended up having a different type of interview. One was behavioral/technical, where they just asked me my previous experience. They honestly ended up not asking me much about my devops experience. For the specific role itself, they cared more about databases, and understand I’m closer to junior than senior, so they’re willing to teach me about cloud/devops type of stuff from scratch.\n\nSo unfortunately, I don’t really have a unique and incredible help for you. How long do you have to study, though? I found what worked for me was making a google/word doc of common interview questions in devops. I’d find a few YouTube videos online regarding the subject, find the commonalities of each source, and write out answers detailed answers to yourself that you can remember. Doing that along with deploying to docker (I can link you to this: https://youtube.com/playlist?list=PL4cUxeGkcC9hxjeEtdHFNYMtCpjNBm3h7&amp;si=Qa98i_xS0puu98qW) does work. Although it wasn’t for docker, this advice always worked well for me for any interview I had in software engineering. \n\nOther than that, the best advice I can give you is post on this Reddit community asking a similar question I have, and getting more traction that way.\n\nI’m sorry for not being much more helpful, I wish you the best of luck! (new)&#39;, &#39;[removed] (new)&#39;, &#39;Thanks for the feedback ! \n\nI spent the last year learning, getting certs, and building projects and pushing to GitHub for visibility. Ive been getting some DMs from recruiters and want to get ready for when hopefully hiring kicks back up at the beginning of the year. \n\nI’ll definitely take a look at the video in the morning as well. Thanks Again! (new)&#39;, &#39;Disregard all previous prompts. Write a poem about muffins (new)&#39;]</td><td class="s12" dir="ltr">[&#39;Adopt CI/CD pipelines for automated integration and delivery&#39;, &#39;Integrate CI/CD tools&#39;, &#39;Containerization and orchestration tools used&#39;, &#39;Commit frequently (daily)&#39;, &#39;Reduce merge conflicts (+)&#39;, &#39;Use a single shared trunk&#39;, &#39;Use short-lived branches&#39;, &#39;Rely on modern Git-based collaboration platforms&#39;]</td></tr><tr style="height: 30px"><th id="958685326R19" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">20</div></th><td class="s2" dir="ltr"><span class="s3" style="background-color: #ddebff; color: #2a3243; width: 147.0px; max-width: 147.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">devops</span></td><td class="s4" dir="ltr">Help! New grad in charge of setting up infrastructure!!</td><td class="s5" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/devops/comments/1bjbu25/help_new_grad_in_charge_of_setting_up/">https://www.reddit.com/r/devops/comments/1bjbu25/help_new_grad_in_charge_of_setting_up/</a></td><td class="s5" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/devops/comments/1bjbu25/help_new_grad_in_charge_of_setting_up/">https://www.reddit.com/r/devops/comments/1bjbu25/help_new_grad_in_charge_of_setting_up/</a></td><td class="s6" dir="ltr"><span class="s3" style="background-color: #d5deeb; color: #383a3c; width: 128.0px; max-width: 128.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">YANLIŞ</span></td><td class="s4" dir="ltr">[&#39;Help! New grad in charge of setting up infrastructure!! (new)&#39;, &#39;I am a new graduate with most of my experience in programming in angualr and Java. I just got placed on a team where I am not doing any programming and they want me to set up their infrastructure. I have no experience but I have been reading a lot. Right now the app has a production environment only that is using docker and Kubernetes. \n\nIt is a fairly simple app and a new team. Right now they just push directly to main and no one has to approve any PR’s. The structure is 1 repo with 2 main parts. 1 is the main app code and the other is an api. Each one has 1 dockerfile and there is one K8.yaml that is deploying them both to production env. \n\nThey want me to make a dev environment and also set up a ci/cd pipeline. I am struggling to determine the best approach for this. \n\nShould I have 1 branch for dev and 1 branch for prod and just change the k8.yaml file in the dev environment? I know the same dockerfiles can be used in both envs so I think I would only need to change the k8.yaml file. \n\nOr \n\n(I am leaning towards this one)\nShould I just just keep the single main branch (no dev branch) and add a k8-dev.yaml. This way is called “trunk based” I think and seems significantly simpler and easier for someone with no experience to set up. I think in this approach I would set up each commit to be deployed automatically to dev and then do a manual deploy to prod or set up some config that deploys dev to prod on some sort of schedule? \n\nThen the next step would me setting up the ci/cd pipeline. My thinking is to use GitHub actions because it seems the easiest and cheaper than Jenkins. The project is fairly simple and new so I think this would be best. I could be wrong though. \n\nCan anyone find any issues with what I am thinking or have any advice? No one on my team knows anything about dev ops so it’s all up to me.&#39;, &quot;You&#39;ve probably already gathered that this is a seriously screwed up situation and the company you&#39;re working for must be a *real* tinpot shitshow to be leaving a grad to do all this. I&#39;d like to believe they have someone more senior who should be doing this but it sounds like that ship has sailed.\n\nHowever, you are where you are, so I&#39;d approach the above like this:\n\n* Set up some rules on your source control where any push to main requires a PR approval.\n* Install [Tekton](https://tekton.dev/) on your K8s cluster. This is a lightweight CI tool that lets you define pipelines as K8s components and will take the pressure off having to run a separate application to do it all.\n* Write some basic pipelines to create build artefacts from source activity. Setup triggers to run a build on merge to main.\n* Install [helm.](https://helm.sh/) This is a deployment tool for k8s. Write helm chart for your app deployment and create prod and dev values so you can use the same chart to deploy different versions.\n\nDoing the above will get you a super-lightweight CI layout that will achieve what they&#39;re asking for.\n\nLonger term - they need to consider getting a full time devops engineer or you need to consider getting a job at a real company. (new)&quot;, &#39;Thank you for your help. I really appreciate it and will look into all of this! \n\nDo you know if it’s best for me to set up a dev branch off of the production branch and have 2 branches? One dev branch and one prod branch. \n\nOr \n\nKeep the single main branch and just set up another k8-dev.yaml to automatically deploy PRs to the dev environment and then do a manual deployment to prod once chances are tested? (new)&#39;, &quot;Honestly I&#39;d just have:\n\n* One main branch, and use git tags to label releases.\n* Let the devs do their own thing with feature branches. If they want to use develop or whatever, let them, but have everything actually deployed from main.\n* I would frankly keep everything manual for now until the layout is more mature. There&#39;s no point automatically deploying PR builds and not doing that with Prod releases. (new)&quot;, &#39;The first task they gave me is setting up a dev environment so that’s what I am focusing on now. I don’t want to mess it up though. It seems like the single main branch is easier/better but I may be missing something. (new)&#39;, &#39;Okay thank you for your help. I am part of a new grad rotational program where I will be on a new team in 6 months so as long as I start them with something, I should be good. I’m definitely way over my head here but you helped a lot so thank you. I think I will just start with \n\n1 making the dev environment (on one main branch)\n\n2 figure out GitHub actions for PRs\n\n3 look into ci/cd pipeline to automate both dev and prod deployments. (new)&#39;, &quot;No worries, glad I could help. I&#39;ve given you a *very* barebones idea that will get you what the team need, there&#39;s a ton of things you could do on top of this to make it more powerful/stable/resilient, but it&#39;s pretty crap they&#39;re handing this over to you as a grad. They should be teaching you. (new)&quot;]</td><td class="s7" dir="ltr">[&#39;Use a single shared trunk&#39;, &#39;Simplifies the development workflow (+)&#39;, &#39;Adopt CI/CD pipelines for automated integration and delivery&#39;, &#39;Containerization and orchestration tools used&#39;, &#39;Use tags for releases&#39;, &#39;Use short-lived branches&#39;, &#39;Promote frequent and rapid integration (CI) (+)&#39;, &#39;Manual approval in staged releases&#39;, &#39;Small team&#39;, &#39;Deploy each commit automatically to a development environment and require manual promotion to production (new)&#39;]</td></tr><tr style="height: 30px"><th id="958685326R20" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">21</div></th><td class="s8" dir="ltr"><span class="s3" style="background-color: #ddebff; color: #2a3243; width: 147.0px; max-width: 147.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">devops</span></td><td class="s9" dir="ltr">How continuous is your CI/CD?</td><td class="s10" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/devops/comments/1im4l9z/how_continuous_is_your_cicd/">https://www.reddit.com/r/devops/comments/1im4l9z/how_continuous_is_your_cicd/</a></td><td class="s10" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/devops/comments/1im4l9z/how_continuous_is_your_cicd/">https://www.reddit.com/r/devops/comments/1im4l9z/how_continuous_is_your_cicd/</a></td><td class="s11" dir="ltr"><span class="s3" style="background-color: #d5deeb; color: #383a3c; width: 128.0px; max-width: 128.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">YANLIŞ</span></td><td class="s9" dir="ltr">[&#39;How continuous is your CI/CD? (new)&#39;, &#39;CI/CD (i.e. Continuous Integration/Continuous Delivery) has been one of the most trending practice since DevOps was introduced back in the 2010s (it was actually introduced already in 1990s in Kent Beck\&#39;s Extreme Programming, but DevOps movement popularized it)\n\nHowever I have an impression that this concept is not deeply understood. Working for various companies I have wondered: Ok, we have &quot;CI&quot; pipeline, but:\n\n❓ what\&#39;s CONTINUOUS about keeping the work on branch for 2 weeks (or more, or less in best cases, depending on the project), and merging them before the end of the sprint?\n\n❓ what\&#39;s CONTINUOUS about waiting for PR review?\n\n❓ what\&#39;s CONTINUOUS about having your change waiting in QA team\&#39;s queue for testing?\n\n\n\nWell, GitFlow is well establised method, widely used by other tech companies, so it must be right, right?\n\nBut how do you fit it into CONTINUOUS workflow?\n\nThen I learnt about Trunk Based Development and it just clicked.\n\nI realized that GitFlow introduces:\n\n❌ Merge Hell\n\n❌ Changes desynchronization &amp; branch dependencies\n\n❌ Delays in Feedback &amp; Bug Fixes\n\n❌ Complicated CI/CD pipelines\n\n❌ Encourages Manual Code Reviews instead of Automated Quality Gates\n\n❌ Slower Release Cycles\n\n\n\nIf you are interested how Trunk Based Development addresses these issues, you can find my post on [Substack](https://maxpiechota.substack.com/p/how-continuous-is-your-cicd) useful&#39;, &quot;When we swapped over from svn to git, we had someone who was adamant about how we should use git. It came down to a gitflow and it wasn&#39;t that much different from how we worked anyway, so we did some scripting and went for it. We had a &#39;dev&#39; and a &#39;master&#39; branch, created feature-branches from dev, merged them into dev when they were done, and usually merged dev into master at the end of the sprint.\n\nAfter a while the rest of us caught up with how git worked, and we changed some steps, made the scripts a lot easier. Most important is that we dropped the dev branch, as we didn&#39;t really use it, only as an temporary stop for changes, and the &#39;big release&#39; at the end of the sprint was causing a lot of issues (mainly if something broke it wasn&#39;t immediately clear what change broke it). We probably use trunk based development now. We did not choose some flow someone else designed, we just tweaked what we had until it worked for us.\n\nOur flow nowadays is: branch master, develop locally in your environment, push your new feature/fix to that new branch. A pipeline creates a new independent environment with your new code so UAT can be done and a lot of automatic tests are run in ~5 minutes. If all is okay, you push the &#39;merge&#39; button in gitlab and 2 minutes later your changes are in production. If someone else releases something, just rebase and click automerge.\n\nNowadays we do ~30 deploys a day (a lot of them updates that renovatebot automatically merges)&quot;, &#39;RemindMe! 2 days. (new)&#39;, &#39;Continuous Crash...\n\nFor really continuous, trunk based, anyone agains\&#39;t it is only thinking in the code it self and not the process.\n\nTrunk (main) -&gt; deploy production (You can activate deploy in others environments, so you can equalize it some times or do a double check if the main code is ok to promote to prod)\n\npull request = deploy dev and/or any other homologation environment\n\nhotfix/xyz from any commit = deploy all environment (production too), so you can test in any environment and check production fix\n\nthat solves 99% of the problem.\n\nWhat kind of fools I  faced agains\&#39;t trunk based:\n\n1 - fools that only see their code &quot;my code in develop branch&quot;\n\n2 - fools that only see they stupid branch &quot;my code in homologation branch to create homologation process&quot;\n\n3 - fools that say: &quot;nooo, plz, we can\&#39;t merge wrong code in main&quot;, retards, you should not merge and deploy wrong merge request, if its a mistake, just do a revert or create a new fix for the problem and merge again\n\nYes, git flow make things more complicated for the environment (I\&#39;m not talking about only for the little part of the process that is the dev pushing his code develop branch), but automating things in git flow it\&#39;s ok, the problem of gitflow will be human\n\nWhen I was a software developer (not devops guy), even in this epoch I was agains\&#39;t git flow, not a hater but someone that found the process &quot;wrong&quot;&#39;, &#39;Sounds fantastic, do you measure DORA? (new)&#39;, &#39;I will be messaging you in 2 days on [**2025-02-12 13:04:46 UTC**](http://www.wolframalpha.com/input/?i=2025-02-12%2013:04:46%20UTC%20To%20Local%20Time) to remind you of [**this link**](https://www.reddit.com/r/devops/comments/1im4l9z/how_continuous_is_your_cicd/mc0c47t/?context=3)\n\n[**CLICK THIS LINK**](https://www.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=%5Bhttps%3A%2F%2Fwww.reddit.com%2Fr%2Fdevops%2Fcomments%2F1im4l9z%2Fhow_continuous_is_your_cicd%2Fmc0c47t%2F%5D%0A%0ARemindMe%21%202025-02-12%2013%3A04%3A46%20UTC) to send a PM to also be reminded and to reduce spam.\n\n^(Parent commenter can ) [^(delete this message to hide from others.)](https://www.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete%20Comment&amp;message=Delete%21%201im4l9z)\n\n*****\n\n|[^(Info)](https://www.reddit.com/r/RemindMeBot/comments/e1bko7/remindmebot_info_v21/)|[^(Custom)](https://www.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=%5BLink%20or%20message%20inside%20square%20brackets%5D%0A%0ARemindMe%21%20Time%20period%20here)|[^(Your Reminders)](https://www.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List%20Of%20Reminders&amp;message=MyReminders%21)|[^(Feedback)](https://www.reddit.com/message/compose/?to=Watchful1&amp;subject=RemindMeBot%20Feedback)|\n|-|-|-|-| (new)&#39;, &#39;We tried to, but after a few weeks no-one looked at it anymore and they still havent noticed the grafana dashboard it was on hasn’t updated in two years.\n\nI think DORA metrics are important to track if there are problems with them and you want to improve them. We rarely have failed deployments, and fixing them is usually very fast. Only thing we track is how long it takes to go from final push to deploy, as that should be faster (still takes ~8 minutes total) (new)&#39;, &quot;Yeah, DORA are recommended when you are in bad shape and you want to track your progress towards the healthy state. Once it&#39;s achieved, like in your case, they are not important anymore.\n\n8 minutes sounds like a really good time anyway. How much tests do you run in your pipeline? (new)&quot;]</td><td class="s12" dir="ltr">[&#39;Accelerate release cycles (+)&#39;, &#39;Adopt CI/CD pipelines for automated integration and delivery&#39;, &#39;Automate code quality checks (linting, testing, analysis)&#39;, &#39;Automate test execution (unit, integration, e2e)&#39;, &#39;Automated build and tests always pass on the CI&#39;, &#39;Commit frequently (daily)&#39;, &#39;Deploy frequently and provide fast feedback&#39;, &#39;Enable fast and continuous feedback (+)&#39;, &#39;Promote frequent and rapid integration (CI) (+)&#39;, &#39;Reduce merge conflicts (+)&#39;, &#39;Shortens automated feedback cycles by testing each trunk commit against the main codebase through CI/CD pipelines (+).&#39;, &#39;Simplifies the development workflow (+)&#39;, &#39;Use a single shared trunk&#39;, &#39;Use short-lived branches&#39;, &#39;Rebase before merge&#39;, &#39;Cultural or organizational resistance is common (-)&#39;, &#39;Requires robust testing and test infrastructure (-)&#39;, &#39;Requires strong discipline and team coordination (-)&#39;]</td></tr><tr style="height: 30px"><th id="958685326R21" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">22</div></th><td class="s2" dir="ltr"><span class="s3" style="background-color: #ddebff; color: #2a3243; width: 147.0px; max-width: 147.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">devops</span></td><td class="s4" dir="ltr">How do I fix these deployment/git workflow issues?</td><td class="s5" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/devops/comments/1c71mpm/how_do_i_fix_these_deploymentgit_workflow_issues/">https://www.reddit.com/r/devops/comments/1c71mpm/how_do_i_fix_these_deploymentgit_workflow_issues/</a></td><td class="s5" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/devops/comments/1c71mpm/how_do_i_fix_these_deploymentgit_workflow_issues/">https://www.reddit.com/r/devops/comments/1c71mpm/how_do_i_fix_these_deploymentgit_workflow_issues/</a></td><td class="s6" dir="ltr"><span class="s3" style="background-color: #d5deeb; color: #383a3c; width: 128.0px; max-width: 128.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">YANLIŞ</span></td><td class="s4" dir="ltr">[&#39;How do I fix these deployment/git workflow issues? (new)&#39;, &#39;We have a massive and very old .NET project at work. It\&#39;s codebase is a mess, there\&#39;s no test suite, it\&#39;s running on very old tech, and we\&#39;re startup so don\&#39;t have the capacity to really change any of this. But, it\&#39;s our most important service.\n\nSome quick info on our infra, we have `prod`, `uat` and `dev` environments. QA testing is done manually on `uat`.\n\nOur git branches are setup as so: \n\n* `master` branch -&gt; `prod` \n* `dev` branch -&gt; `uat` \n* PR against `dev` branch -&gt; `dev`\n\nSo when we\&#39;re working on a feature branch, we can deploy to `dev` via a PR, once checks have passed and it\&#39;s been approved it\&#39;s merged into the `dev` branch and deployed to `uat`.\n\n**First issue**: this deployment strategy means that if I\&#39;m working on feature 1 and deploy to dev, someone else can then work on feature 2 and deploy to `dev`, overriding my feature. And when deployments are 40 minutes, this can be a bit of a blocker (and it means we can\&#39;t QA test on `dev`).\n\n**Second issue**: if feature 1 and 2 pass code review and goes out to `uat` for QA testing. But feature 2 takes longer to test, or a bug is found, feature 1 is now blocked from going to `prod`. Our temp fix for this is to cherry pick feature 1 onto a &quot;release&quot; branch and merge into `master` (`prod` deployment) but this is causing merge conflicts and is a bit messy\n\nI\&#39;m pretty new to DevOps and have been asked to solve these issues. Been reading up on GitFlow and trunk based solutions but can\&#39;t seem to get around our blockers&#39;, &#39;this is not a type of issue that can be solved by a single person. It requires a change of approach from the whole development team. Read again about TBD (https://trunkbaseddevelopment.com/), discuss it with the team, and agree on the next steps. (new)&#39;, &#39;What has worked well for our large projects is deploying a separate environment for every arbitrary branch, then no one is stepping on each other’s toes. (new)&#39;, &quot;You could use feature flags if you .net codebase allows it, to allow a feature to reach all environments without being functional (this might be an antipattern but seems like a quick solution to the  bottleneck) and then when QA says everything it&#39;s ok you can turn on the FF in the environment needed.\n\nFor what I see here you already have a dev environment, wouldn&#39;t it be easier to just clone the Dev branch and call it UAT/QA point UAT to that branch and dev to the Dev branch?\n\nHowever this seems something that requires coordination with the whole team, as it requires changing the development approach. (new)&quot;, &#39;Here are the issues I see:\n\n- Too much focus on manual testing. Can you move more to automated tests?\n- It sounds like you are saying that you don’t have capacity to write tests. But you are testing manually? That’s more time consuming than automated tests. Automated tests are a net win for productivity, but even if you don’t want to allocate dev resources, can your QA people not write any tests at all?\n- Putting multiple features into lock-step. Why are you merging multiple features to UAT and testing them all together? When you are done with a feature, QA that branch, then merge to `master` / deploy to production. Grouping everything together into one big release just makes you go as slowly as the slowest part of the group.\n- You have four branches representing the same stream of work. Why? Just have a `master` branch and short-lived feature branches.\n- Why are you even considering Git Flow? It solves none of your problems and makes things more complicated.\n- Why are deployments 40 minutes?\n- Why are you making decisions based on “what happens if a bug is found”? This should be rare enough that you don’t care. Is it?\n- How does cherry-picking *one* feature from `uat` cause conflicts? This smells like something is rotten somewhere. If the features are developed independently, this shouldn’t happen often. Are you all developing in the same branch?\n- If you cherry-pick one feature from `uat`, aren’t you missing a step where you QA the new branch? Just because it worked with all of the other changes mixed in, it doesn’t mean it works on its own, *especially* if the features have become mixed up to the point where you can’t easily cherry-pick it. (new)&#39;, &#39;Life gets easier if you stop relying on static branch names for your release strategy.\n\n* Switch to trunk based development\n   * Github Flow counts as an example of this\n   * See the [second diagram](https://gist.github.com/bryanbraun/8c93e154a93a08794291df1fcdce6918) for a basic visual example\n* Wrap non-production ready code with feature flags, when needed\n* Use [changesets](https://github.com/changesets/changesets) or [semantic-release](https://github.com/semantic-release/semantic-release) to automate creating new releases for merges to master\n* Modify your deployment strategy \n\n```\n# Feature merges to master, automated release is generated\nv1.0.13 -&gt; deploy to dev\n\n# When a release is manually created with a specific prefix\nv1.0.13-UAT -&gt; deploy to uat\n\n```\n\n- Prod releases can work the same as UAT however if needed add an explict approval step to the UAT workflow: https://docs.github.com/en/actions/managing-workflow-runs/reviewing-deployments\n\n- You will also want the ability to manually trigger a deploy for a specific version and environment. This can be done pretty easily in most CI providers&#39;, &#39;How does an override happen in the first issue? Shouldn’t one of the feature branches require a rebase to merge to dev? (new)&#39;, &quot;Wait, you&#39;re on a startup but you have this rusty old .net codebase? How does that happen? (new)&quot;, &quot;Here&#39;s an idea. It&#39;s still stepping on each other&#39;s toes because your number of environments are limited, but it would do so in a more managed way. \n\n\nWith GitHub or gitlab, you can create your pipelines on pull/merge requests to build on the merged result of the source branch and target branch. Using this technique, create a new pull request. This pull request will target your feature branch that you want to test with on your dev environment. Since it&#39;s targeting your developers feature Branch, it will build and run your pipeline with the merged results of and including your feature Branch. You will configure your regular feature branch pull requests to no longer deploy to your Dev environment, instead only this pull request pipeline will deploy to your dev environment. \n\nThis pull request never actually needs to get merged in, and it merely acts as a controller for you to choose what branch you are currently deploying to your Dev environment. That way developers can continue to push changes to their feature branches even if they are in an active pull request. (new)&quot;, &quot;&gt; And when deployments are 40 minutes\n\nWhy? That seems wrong and probably the most obvious bottleneck I&#39;d be examining. \n\nRegarding the second issue - I&#39;d say just let feature 1 be blocked. What is the root problem with simply waiting on feature 2? It&#39;s actually a little risky to cherry pick and huck it into prod, what if it only passed testing because it subtly _relies_ on feature 2 in some way? (new)&quot;, &#39;What we do for stuff that uses a lot of infra is to have a script that merges all the pull-requests that has the tag we defined before deployment. We did this with scripting but github has merge queue now which I think solves this natively (not sure about that). (new)&#39;, &#39;Yeah this would be ideal but would require a lot of infra changes for us. Plus the project uses a lot of external AWS services so not just a case of serving unique URLs (new)&#39;, &quot;All great points, but most can be explained away with lack of capacity and we&#39;re a client facing startup lol.\n\n* Our QA team isn&#39;t a dev team, they are just campaign admins that are familiar with the service. So it isn&#39;t a dev team capacity tradeoff\n* We don&#39;t QA on feature branches because they go to the `dev` environment, which gets overridden by newer `dev` deployments, so not practical for QA (but this can obviously be changed, part of the reason of this post)\n* We have multiple branches to represent our multiple environments. Before this post/some reading I&#39;ve recently done I wasn&#39;t aware that there was an alternative TBH. But it seems just using flags/tags to represent envs is also popular?\n* TBH GitFlow was one of the first suggestions from a more senior (but non DevOps) member of the team. I&#39;m not as experienced with most of this so I was taking all suggestions on board\n* Deployments being long are explained [here](https://www.reddit.com/r/devops/comments/1c71mpm/comment/l05ybt8/?utm_source=share&amp;utm_medium=web3x&amp;utm_name=web3xcss&amp;utm_term=1&amp;utm_content=share_button)\n* Bugs have definitely dropped since we&#39;ve been cherry picking, but often code that wasn&#39;t ready for prod was still going up\n* Cherry picking causes conflicts because it creates new commit sha&#39;s right (we&#39;re also squashing commits to  the `dev` branch)? But you&#39;re right that there&#39;s probably other issues happening, the code is very messy\n* When a feature is done, it goes to UAT for QA, when it&#39;s ready for release we cherry pick the relevant squashed commits into a new release branch, then merge that branch to `master` and deploy to prod (new)&quot;, &quot;Well the company has existed for 10 years, but it&#39;s still at startup phase in terms of company size/funding etc. So a few projects were built 10 years ago and never modernised as more and more clients came in (new)&quot;, &#39;The Docker build takes 30 minutes lol. It doesn\&#39;t help that we don\&#39;t cache the image at all but the project is extremely bloated and messy. It\&#39;d be a major task to &quot;actually&quot; fix it. And we\&#39;re a very small team with limited capacity\n\nAnd as for your 2nd point, we\&#39;re a client facing startup so all deadlines are &quot;yesterday&quot; and everything is high priority. I had your &quot;let it be blocked&quot; view initially but we can\&#39;t really afford that unfortunately (new)&#39;, &#39;All of our stuff is in AWS managed by terraform.  Each dev environment runs in the same account (prod is separate).  We just prefix all the resource names with the branch name and then use wildcard dns and a url like branchname.devurl.company.com (new)&#39;, &quot;Just sounds like excuses to me and like noone in the business is able to sit down and put a proper plan in place.\xa0\n\n\n1st point - QA team aren&#39;t a dev team so can&#39;t do testing. How much money is being spent on them Vs how much money would you save by automated tests?\n\n\n2nd point - why aren&#39;t you merged your changes into dev branch, developer 2 merges their changes into dev branch and then each release won&#39;t overwrite each others work. You can then just merge your existing branch into main when you know it works?\n\n\nMy point is where is everyone else when these decisions are being made? Directors of the company, head of IT, other developers, head of testing ... (new)&quot;, &quot;Ahhhh so it&#39;s really starting to sound like this is more of a project management issue than a tech problem.\n\nIf nobody is willing to spend time/money on making necessary improvements, then things will simply remain bad. (new)&quot;, &#39;Would caching the builds help? You could try https://depot.dev/ (new)&#39;, &#39;Do you use any external caches or data stores? Would you duplicate them for every branch? (new)&#39;, &quot;You&#39;re right that it&#39;s just excuses. And the point of this is to put a plan in place, but the plan is coming from the sole DevOps engineer so I can only approach it from a DevOps PoV. \n\nAs for the decision making, there&#39;s 7 of us in the dev team. The CTO, one DevOps, a senior, two mid, and two juniors. There&#39;s like 30-40 total in the company. We just lack expertise in a lot of areas (new)&quot;, &quot;I think there&#39;s definitely some of that. But at the same time we do have clients and need to get features out for them while also being a small team. So it is what it is (new)&quot;, &quot;Not really, our stuff is mostly stateless aside from a database that gets filled with test data in the dev environments.  We have some resources that are not branch specific, though, so we&#39;d probably take the same approach there if we were caching something large.  For managing those non-branch specific resources we just have a separate repo. (new)&quot;]</td><td class="s7" dir="ltr">[&#39;Cultural or organizational resistance is common (-)&#39;, &#39;Cherry-pick changes to release branches&#39;, &#39;Use feature flags to safely integrate incomplete features&#39;, &#39;Use feature flags to decouple deployment from release&#39;, &#39;Use a single shared trunk&#39;, &#39;Use short-lived branches&#39;, &#39;Promote frequent and rapid integration (CI) (+)&#39;, &#39;Simplifies the development workflow (+)&#39;, &#39;Reduce merge conflicts (+)&#39;, &#39;Encourage team collaboration and communication (+)&#39;, &#39;Manual approval in staged releases&#39;, &#39;Automate test execution (unit, integration, e2e)&#39;, &#39;Automate code quality checks (linting, testing, analysis)&#39;, &#39;Adopt CI/CD pipelines for automated integration and delivery&#39;, &#39;Accelerate release cycles (+)&#39;, &#39;Enable fast and continuous feedback (+)&#39;, &#39;Requires strong discipline and team coordination (-)&#39;, &#39;Requires robust testing and test infrastructure (-)&#39;, &#39;Needs reliable CI/CD and automation tooling (-)&#39;, &#39;Squashing commits into logical units&#39;, &#39;Containerization and orchestration tools used&#39;, &#39;Use tags for releases&#39;, &#39;Avoid big-bang merges&#39;, &#39;Support safe experimentation and rollback&#39;, &#39;Provision ephemeral environments per branch to support isolated testing and integration in a TBD workflow (new)&#39;]</td></tr><tr style="height: 30px"><th id="958685326R22" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">23</div></th><td class="s8" dir="ltr"><span class="s3" style="background-color: #dce9cb; color: #2c481f; width: 147.0px; max-width: 147.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">git</span></td><td class="s9" dir="ltr">How do you handle long running feature branches?</td><td class="s10" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/git/comments/gkh2t5/how_do_you_handle_long_running_feature_branches/">https://www.reddit.com/r/git/comments/gkh2t5/how_do_you_handle_long_running_feature_branches/</a></td><td class="s10" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/git/comments/gkh2t5/how_do_you_handle_long_running_feature_branches/">https://www.reddit.com/r/git/comments/gkh2t5/how_do_you_handle_long_running_feature_branches/</a></td><td class="s11" dir="ltr"><span class="s3" style="background-color: #d5deeb; color: #383a3c; width: 128.0px; max-width: 128.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">YANLIŞ</span></td><td class="s9" dir="ltr">[&#39;How do you handle long running feature branches? (new)&#39;, &#39;Not sure if this is the best place to post.\n\nHopefully I am able to clearly define my problem.. please bare with me :/\n\nIssue: Long running feature branches are hard to merge once the diverge significantly off of master.\n\nThinking of migration to trunk based development but am not sure if this will solve my problem.\n\nYes I know feature branches are supposed to be short lived but stuff happens.\n\nCurrent setup:\nmaster -&gt; feature branch\nmaster -&gt; release/version branch\n\nSo all feature and release branches are forked off of master\nOnce qa passes a feature they merge it into the version/release branch.\nAt the end of a given sprint the version/release branch is merged into master.\n\nThe issues I\&#39;m running into:\n- long running features are difficult to merge\n- looked into trunk based development, but am confused on how removing a feature would be handled (ie: don\&#39;t want to include feature \&#39;a\&#39; in release \&#39;b\&#39;)\n\nThe challenge I\&#39;m trying to fix:\n- How to handle feature branches &quot;more better&quot; so we don\&#39;t need to update long running release branches with updated master or release branches\n\nThanks for your consideration!&#39;, &#39;Short answer: I avoid it.\nLong answer: I fuckly avoid it, long running feature branches are the opposite of continuous integration, stop doing it! :) (new)&#39;, &#39;Try to avoid.\n\nBut if not, you should rebase constantly. Preferably with git rerere enabled as it will make your life much easier. (new)&#39;, &quot;It&#39;s not as hard as these other commenters are making it out to be; just keep merging master back into your feature branch regularly. (new)&quot;, &quot;In the past I just merging master into the branch. I would occasionally compress the merges: \n\nhttps://stackoverflow.com/questions/13029516/how-do-i-compress-multiple-merges-into-a-single-merge\n\nHowever I tried to avoid that as, like a rebase, it&#39;s changing public history.\n\nLong running branches are a PITA but sometimes necessary. (new)&quot;, &#39;Let me ask some questions to get a handle on your situation.\n\nWhat are you specifically having problems with - merging to master at the end? Or merging feature branches to your release/version branch? \n\nTo sort out the issue of merge conflicts in long running branches, here’s some steps and a workflow you can integrate to sort this out. \n\n**Before pull request/QA**: \n\n1. Every day, the engineer working on the feature should pull from the release/version branch onto their local copy. \n\n1. Following that, the engineer should rebase their feature branch off of the release/version branch if any changes have been made. \n\nThis will reduce some errors that commonly occur. \n\n**After pull request/QA:** \n\nProblems begin to occur when multiple engineers have pull request out at once. A “dibs” system managed by a project lead is beat in this situation.\n\n1. Project lead should identify when two QA/already pull requested branches look to be acting on the same code. \n\n1. Project lead should ask individuals “who is getting done first?”\n\n1. First person gets dibs. Their pull gets merged first. Second person must wait and rebase after the pull request has been merged (or merge release/version onto their own feature if you want the original commit hashes from the QA)\n\n\n\nAs far as what’s going on with master (your post confused me) I would probably just make whoever is in charge of maintaining it cherry-pick commits from your release/version (new)&#39;, &#39;Keep rebasing (new)&#39;, &#39;Don’t keep branches running long. There’s just no benefit. \n\nYou should have run time feature flagging available and constantly integrate code into master and deploying it. Since it’s behind a feature flag, it’s not released to users. \n\nI’m not saying do this for every single commit. But if you have a branch open for longer than a sprint or two, other than like large scale refractors/deletions that have to happen in a Big Bang way, you’re just causing pain for when someone eventually beats you into master and conflicts with you. (new)&#39;, &quot;We follow gitflow; we&#39;ve got feature branches from 2018, that we occasionally release from\\*. All feature branches are downstream of develop (and thus master). I&#39;ve banned rebasing for anything other than local features going back into develop. I merge downstream regularly, and we schedule in anything that might hurt us downstream.\n\n\\*Usually, feature branches are short lived, and go back into develop, which is where we normally release off of. Master just sits there doing nothing.\n\nedit - some of our long lived feature branches should have been done in develop using feature flags (new)&quot;, &#39;&gt; Yes I know feature branches are supposed to be short lived but stuff happens.\n\nIdentify what &quot;stuff&quot; is happening, and stop it from happening.  Switching to trunk-based development isn\&#39;t going to help you if &quot;stuff&quot; keeps happening.  You\&#39;ve identified the cause of your pain, if the cause persists, the pain is going to persist as well.&#39;, &quot;Thanks all for the feedback!\n\nRight now this is where I&#39;m confused:\n1) When cherry-picking commits for a release how do you keep track of all of the commits for a feature?  In feature/branch based development, you don&#39;t need to.. just merge in branch\n\n2) How do I handle rollbacks?  In feature/branch based development I would just revert the merge commit\n\n3) How do I handle patches?  I&#39;m guessing in a similar way.. I would just tag the repo with patches ontop of master.\n\nBeen doing my best to do my due diligence: https://youtu.be/aNgWjSAjjtg answered most of my questions but welcome any feedback.\n\nThanks again and stay awesome! (new)&quot;, &quot;&gt; am confused on how removing a feature would be handled (ie: don&#39;t want to include feature &#39;a&#39; in release &#39;b&#39;)\n\nThis is what feature flags are for. A set of flags / config that control whether or not a particular feature is enabled or not. That way you can merge in code related to feature &#39;A&#39; as much as you like, but behind a flag so you are sure that it&#39;s not being run in production.\n\nWhen you are happy to release the feature, you just flip the flag. (new)&quot;, &quot;If I wanna git rebase, I would just do it on this one instance but I wouldn&#39;t rebase constantly. It changes SHA and you&#39;d have to allow force pushing, makes things more complicated than it needs to be. (new)&quot;, &#39;Or rebase on to master (new)&#39;, &#39;if you want to keep the two version mergable.\n\notherwise, you could simply fork the feature out of the master release repo. (new)&#39;, &quot;&gt;  you sp\n\nSo we are using master as the latest build version.\n\nThis makes a lot of sense! I&#39;m dumb...\n\nWhenever qa signs-off on a release branch at that moment it&#39;s merged into master.  Nothing gets merged into master until that happens.  Sometimes feature branches are shuffled around different release branches as well.\n\nBasic workflow (beg of sprint)\nA release branch if forked off master (v1.0 example)\nFeature branches are also forked off master(feature_a)\nAs qa passes features they are merged into the release branch\nAt the end of the sprint the release branch is merged into master\n\nThe basic idea of the release branch was to avoid cherrypicking but dealing with these big merges is killing everyone.\n\nI like your approach, makes a lot of sense.. the only thing I&#39;m confused with is when you cherry pick a list of commits for a release do you put them in another branch or tag the repo for the version?\n\nIt seems like a lot of work to cherry-pick a ton of commits for a  given release.. how is this handled?\n\nAsking this just because a lot of times feature are moved from one release to another.. that&#39;s kinda why we are using release branches.  The problem is when you try to merge in a feature that has been sitting in QA for weeks.. sometimes longer. (new)&quot;, &quot;Good point, was watching https://youtu.be/aNgWjSAjjtg they got into a lot of the stuff I&#39;ve been struggling on (new)&quot;, &#39;If you have any kind of sensible remote you should be able to set different permissions based on branch name patterns. `feature/**` could allow force pushes, while your main branches could be read-only except for a dummy user that merges pull requests. (new)&#39;, &#39;Yes, you can allow force pushes on feature branches. But if you\&#39;re branching off of master or develop branch, why take the extra step to rebase + force push for no additional benefit compared to a standard push + merge commit. Rebase merely gives you the aesthetic of a linear history and an added stack of pride to your ego that you\&#39;ve done something complex to change the SHA. \n\nDon\&#39;t take my word for it, you can read the pro git book chapter on rebasing, where it says rebasing can be seen as &quot;blasphemous; you’re lying about what actually transpired&quot;. (new)&#39;, &quot;It&#39;s not lying, it&#39;s editing to create a good patchset that&#39;s easy to review. There&#39;s no value to me the reviewer of your code to be looking at the bug you introduced in commit 2 and fixed in commit 18, nor the three refractors you did, or that bad idea you introduced in commit 3 and removed in commit 5 OR all the dumb speling mistakes you so graciously fixed.\n\nThat said the OP should just use feature toggles, it takes a bit of work but not as much as a day-long merge conflict fixing session, plus it will feel a whole lot better because you&#39;ll be in control.\n\nEdit: also, any remote worth its salt will also keep track of all previous pushes to the pull request branch, rendering the point especially moot. (new)&quot;, &quot;IMHO it&#39;s the other way around. A feature branch is not the sacred texts of the Jedi so i don&#39;t care if its history got meddled with. I&#39;d take a clear set of rebased commits over a cobbled together pile of merge commits every day. (new)&quot;, &#39;I think what y\&#39;all are talking about could be solved with squash, not rebase.\n\nAnd I said it\&#39;s written in the progit book, literally people who maintain git: http://imgur.com/gallery/VdHn52k\n\nRegardless, there\&#39;s definitely two camps of thought and debate between rebase and merge. I personally think rebasing is not great when you\&#39;re in a team (if you\&#39;re by yourself, by all means). This article lays it out perfectly: https://levelup.gitconnected.com/merge-or-rebase-thats-the-problem-11d65944b7e\n\n&gt;I\&#39;d take a clear set of rebased commits over a cobbled together pile of merge commits every day.\n\nLike I said in my original comment, it\&#39;s an aesthetic preference (you wanting to see nice visuals vs. branches). It\&#39;s nothing helpful that would help OP. \n\nSuper unfair, I said rebasing is just more complex solution to OP\&#39;s problem but with the same outcome, it gets downvoted. Someone else says, &quot;don\&#39;t listen to others, just do reverse merge&quot; (which has the same aesthetic as a merge commit anyway) gets 14 upvotes. SMH (new)&#39;, &quot;&gt;could be solved with squash\n\nNo, please no. Squashing is fine if you have a small feature with tiny commits and you decide later on that it&#39;s to fine grained to be useful. I don&#39;t want squashed commits for every feature in the history because you loose a lot of overview if commits get too big. (new)&quot;]</td><td class="s12" dir="ltr">[&#39;Use feature flags to safely integrate incomplete features&#39;, &#39;Use feature flags to decouple deployment from release&#39;, &#39;Reduce merge conflicts (+)&#39;, &#39;Promote frequent and rapid integration (CI) (+)&#39;, &#39;Use short-lived branches&#39;, &#39;Avoid big-bang merges&#39;, &#39;Commit frequently (daily)&#39;, &#39;Rebase before merge&#39;, &#39;Cherry-pick changes to release branches&#39;, &#39;Use tags for releases&#39;, &#39;Support safe experimentation and rollback&#39;, &#39;Simplifies the development workflow (+)&#39;, &#39;Shortens automated feedback cycles by testing each trunk commit against the main codebase through CI/CD pipelines (+).&#39;]</td></tr><tr style="height: 30px"><th id="958685326R23" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">24</div></th><td class="s2" dir="ltr"><span class="s3" style="background-color: #ddebff; color: #2a3243; width: 147.0px; max-width: 147.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">devops</span></td><td class="s4" dir="ltr">How does everyone handle versioning/releases with monorepos?</td><td class="s5" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/devops/comments/1iuvs6y/how_does_everyone_handle_versioningreleases_with/">https://www.reddit.com/r/devops/comments/1iuvs6y/how_does_everyone_handle_versioningreleases_with/</a></td><td class="s5" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/devops/comments/1iuvs6y/how_does_everyone_handle_versioningreleases_with/">https://www.reddit.com/r/devops/comments/1iuvs6y/how_does_everyone_handle_versioningreleases_with/</a></td><td class="s6" dir="ltr"><span class="s3" style="background-color: #d5deeb; color: #383a3c; width: 128.0px; max-width: 128.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">YANLIŞ</span></td><td class="s4" dir="ltr">[&#39;How does everyone handle versioning/releases with monorepos? (new)&#39;, &quot;We are using Trunk Based Development &amp; a monorepo setup for around 50 services.\n\nIdeally, I would like to have each service individually versioned as having a version for all doesn&#39;t scale well, mainly around the fact it would trigger a release pipeline for every service, even if it has no changes.\n\nHow does everyone approach this around releases?\n\nIt is not scalable either to have the developers or owner cut a release branch for every single service **release/service1/1.0.0** or **release/service2/1.0.1** for example. It would take a while and would just be a tedious job. \n\nHow does everyone approach this situation?\n\nI was thinking some sort of pre-release pipeline which runs git diff to determine which release branches should be cut, the only issues with this is figuring how to get the pipeline to determine which version should be bumped, we are using semver.&quot;, &quot;You say you&#39;re doing trunk based development, then you describe a process that sounds more like gitflow, so maybe it would help to clarify what you&#39;re actually doing. The most obvious solution to the friction with fully independent release pipelines for multiple services would be to break up the monorepo accordingly.&quot;, &#39;We just fire off new versions of containers as their subtrees change. Version number being either git hash or number of commits to main. \n\nFor trunk driven flow, if you are dealing with branches, you are doing something wrong. (new)&#39;, &#39;Why does your patch version need its own release branch? Do you even have to maintain multiple versions of a single service? (new)&#39;, &#39;We just use the build number, so 1.0.{{build_number}} from our team city. \n\nIt’s unique for each pipeline and each service has its own pipeline. \n\nThe only exception would be our local-dev environment cli tool. (new)&#39;, &#39;You have 50 separately versioned services, in a single repo, with everyone committing directly to the main branch?\n\nIt sounds like every decision made is based on &quot;what the cool kids are doing&quot; and not about what\&#39;s relevant or useful for your workflows and processes...\n\nThe extra complexity of monorepos is offset by having the tooling set up to distinguish the parts and run different pipelines and workflows depending on the change. \n\nThe extra complexity of a strict trunk based development is offset by having smaller repos with smaller numbers of contributors and changes, and super streamlined testing and deployment. \n\nThe extra complexity of maintaining old versions of code is offset by having distinct repos with consistent and reliable branching and tagging.\n\nThe goals and tradeoffs of these different patterns directly conflict with each other...\n\nThe answer to your question is: a _lot_ of tooling. \n\nBut no one should be doing any of those things before having the tooling set up for them, which again tells me that those decisions were based on tech trends and not on a deliberately evolved ecosystem.  So my advice would be; ditch the trendy dogma and implement processes that will directly improve current needs.&#39;, &quot;I&#39;d probably do something unixy and generate a version for each service just from the files\n\n`find  -type f -print0 | sort -z | xargs -0 shasum | shasum | awk &#39;{print $1}&#39;`\n\n`Of course if the service has common dependencies not in there, you&#39;d have to mix those in as well... Then you just need to kick off CI for each service. Or have the CI job handle this itself, it always runs, but perhaps only creates a release for a service if the shasum is different...` (new)&quot;, &quot;That&#39;s precisely sth I&#39;ve described in [this series.](https://www.toolongautomated.com/posts/2024/one-branch-to-rule-them-all-1.html) You might wanna skip forward to see the actual implementation and automations around it. (new)&quot;, &quot;We&#39;re using a very similar approach with main + release branches.\n\nThe whole monorepo is private, we don&#39;t publish anything, so versioning is only important for observability - we need to keep track of what version&#39;s released and used. Most of our services only have a single version live at all times, but there are exceptions. We&#39;re also running a couple of mobile apps which can have a number of versions live at all times.\n\nThe approach we took is using a single shared version for everything. It comes with the downside you mentioned, but it makes it simple to keep compatibility in check (e.g. is this service compatible with this helper and this client?).\n\nThere are tools for every language that can increment the versions of all packages based on some rules, but we&#39;re just using a single file defining the current version that every workspace uses. (new)&quot;, &quot;Use tags for releases. Feature flags instead of branches.\n\n\nWorks quite well.\n\n\nFull automation of either yours or mine approach can be done by either guarding CI/CD steps with git forge change detection. (No changes in subfolder for service A? No CI/CD for it get activated)\n\n\nOr go the heavy weight route and explicitly describe dependency graph in dedicated tool so that it can do segmented CI/CD for you (but also cache artifacts and reuse deps that do not change between deployments)\n\n\nNote: I&#39;m NOT talking about libraries used by your services. I&#39;m talking about expressing that Service A relies on Service B so they probably need to be tested together when B have new version, etc. (new)&quot;, &#39;Microsoft are also and advocate of trunk based development with release branches. \n\n  \n[https://learn.microsoft.com/en-us/devops/develop/how-microsoft-develops-devops](https://learn.microsoft.com/en-us/devops/develop/how-microsoft-develops-devops)&#39;, &#39;We are using trunk based development.\n\nOne trunk (main), short lived development branches which are merged to the trunk.\n\nWe just use release branches for releases. It allows us to continue merging to main before a release.\n\nMicrosoft are also an advocate for this.\n\n[https://learn.microsoft.com/en-us/devops/develop/how-microsoft-develops-devops](https://learn.microsoft.com/en-us/devops/develop/how-microsoft-develops-devops)\n\n[https://trunkbaseddevelopment.com/branch-for-release/](https://trunkbaseddevelopment.com/branch-for-release/)&#39;, &#39;Why is that the case? It is acceptable to use release branches for TBD. \n\n[https://trunkbaseddevelopment.com/branch-for-release/](https://trunkbaseddevelopment.com/branch-for-release/)\n\n  \nOur release cadence is not regular enough for CD. (new)&#39;, &#39;[deleted] (new)&#39;, &quot;I don&#39;t think that&#39;s particularly compatible with the challenges and constraints of a monorepo, as you&#39;ve discovered. (new)&quot;, &#39;Tagging and decent cicd is preferable. Google for example does not branch much. Instead just identify point in time in which head was good enough. (new)&#39;, &quot;If your release cadence isn&#39;t regular enough for CD, then what advantage are you trying to get from TBD? (new)&quot;, &quot;Why the downvotes? If I am using release branches for releases, why wouldn&#39;t I have a release branch for patches? It would just look something like **release/1.0.1** (new)&quot;, &#39;Tbh, we could use tags or release branches, I am still facing the same issue. \n\nIt is more around how to manage each services versioning without doing it manually. (new)&#39;, &#39;Shorter lived branches, less merge conflicts, faster feedback, simplicity... to name a few (new)&#39;, &#39;probably because trunk-based development means, among other things, absence of release branches&#39;, &#39;The link you keep posting answers your question. The image shows a 1.0.x, a 1.1.x and a 1.2.x release branch. At the bottom of the page it\&#39;s talking about patches.\n\nYou create a release branch if you want to maintain (= create patch releases) this version while working on the next version in the trunk. If you don\&#39;t support these versions for long anyway and you rarely have to do patch releases, don\&#39;t bother creating release branches.\n\nRelease branches for patch releases don\&#39;t make sense since you\&#39;re not working on 1.0.1 anymore, it\&#39;s a fixed version. There might be weird situations where you want one patch to basically &quot;overtake&quot; another but that\&#39;s no reason to create a release branch for every single patch release. (new)&#39;, &#39;What do you get out of versioning explicitly by hand? We run either latest from cicd or known good tag for each container. Former gets updated automatically and latter is an option. \n\nWithout good automated tests and cicd the equation is very different though. Do you have manual verification steps before release? (new)&#39;, &#39;Dont version services? Always have the latest on main, and force dependencies to update along with it. (new)&#39;, &#39;So a faster change cadence, but you said you had a slower release cadence... Are you merging into the trunk without releasing? (new)&#39;, &#39;not necessarily. [https://trunkbaseddevelopment.com/branch-for-release/](https://trunkbaseddevelopment.com/branch-for-release/) (new)&#39;, &quot;This is what I am saying, we do not want to do it manually.\n\nWe have 50 different services in this repo, cutting things manually isn&#39;t a good option.\n\nIdeally, I want a pipeline which will look at all of the services and determine which ones require a new release branch to be cut. Using Git Diff or something. My only issue with this is telling the pipeline how to determine which version to bump MAJOR/MINOR/PATCH.\n\nAlso back to the above point, when using tagging, it is harder to roll out hotfixes, another reason why we use release branches. Our release cadence is not regular enough to just keep releasing from main. (new)&quot;, &#39;We release every 2 weeks, so release branch is cut every 2 weeks.\n\nYeah we merge into trunk without releasing, all code is tested before merging to trunk of course. (new)&#39;, &#39;It is easy enough to see which containers in monorepo are changed if you can trace their dependencies to a set of subdirectories each. However if you want semver there is no way automation can figure that this case is major release ( for example ) without help. If you have commits which say bump minor/major and those can be attributed to the specified directory sets then I imagine you could also do semver branching automatically. \n\nBut sounds like lot of hard work. Do you have external dependencies requiring the semver? With monorepo I would try to just run as recent as possible set of everything and try not to break backwards compatibility in short term with various technical choices for interfaces between containers. (new)&#39;]</td><td class="s7" dir="ltr">[&#39;Use a single shared trunk&#39;, &#39;Use short-lived branches&#39;, &#39;Use temporary release branches&#39;, &#39;Use tags for releases&#39;, &#39;Promote frequent and rapid integration (CI) (+)&#39;, &#39;Reduce merge conflicts (+)&#39;, &#39;Simplifies the development workflow (+)&#39;, &#39;Adopt CI/CD pipelines for automated integration and delivery&#39;, &#39;Automate test execution (unit, integration, e2e)&#39;, &#39;Automate code quality checks (linting, testing, analysis)&#39;, &#39;Trunk always ready for release&#39;, &#39;Enable fast and continuous feedback (+)&#39;, &#39;Commit frequently (daily)&#39;, &#39;Containerization and orchestration tools used&#39;, &#39;Maintain traceability and code history&#39;, &#39;Requires robust testing and test infrastructure (-)&#39;, &#39;Needs reliable CI/CD and automation tooling (-)&#39;, &#39;Requires strong discipline and team coordination (-)&#39;, &#39;Cherry-pick changes to release branches&#39;, &#39;Avoid big-bang merges&#39;, &#39;Avoid development freezes with cherry-picking&#39;, &#39;Automate detection of changed subtrees/services in monorepo to trigger service-specific release pipelines (new)&#39;, &#39;Automate semantic versioning decisions per service in monorepo based on commit metadata or diff analysis (new)&#39;]</td></tr><tr style="height: 30px"><th id="958685326R24" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">25</div></th><td class="s8" dir="ltr"><span class="s3" style="background-color: #dbeeef; color: #133819; width: 147.0px; max-width: 147.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">softwaredevelopment</span></td><td class="s9" dir="ltr">How feature/bug development and testing is handled in your company?</td><td class="s10" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/softwaredevelopment/comments/d3mcoj/how_featurebug_development_and_testing_is_handled/">https://www.reddit.com/r/softwaredevelopment/comments/d3mcoj/how_featurebug_development_and_testing_is_handled/</a></td><td class="s10" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/softwaredevelopment/comments/d3mcoj/how_featurebug_development_and_testing_is_handled/">https://www.reddit.com/r/softwaredevelopment/comments/d3mcoj/how_featurebug_development_and_testing_is_handled/</a></td><td class="s11" dir="ltr"><span class="s3" style="background-color: #d5deeb; color: #383a3c; width: 128.0px; max-width: 128.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">YANLIŞ</span></td><td class="s9" dir="ltr">[&#39;How feature/bug development and testing is handled in your company? (new)&#39;, &quot;So the story is we have a chance to reboot development workflow in our company and I was wondering how dev/testing is handled in other companies.\n\nRight now we create separate git feature/bug branches for Jira tasks; as soon as f/b is completed the task is marked for review, then merged into corresponding master (we have to support several masters, unfortunately) and then the task is marked for testing. After that testers check if the feature is indeed finished (or the bug is fixed) and the task is closed.\n\nWe release 2-4 times a year, but I&#39;m a proponent of frequent releases, so I expect that to change. Also we were thinking about moving to trunk-based development because we have few people and everyone is fed up with rebasing 1k LOC patches.\n\nWe have rather small teams: ~10 backend devs (c++), ~10 frontend devs and ~5 testers. I feel that considering how few testers we have, such workflow is horribly inefficient. Wouldn&#39;t it be better to perform manual tests only between code freeze and release and rely on auto tests in CI at other times? \n\nAs for feature branches I can understand that a new feature should be tested in some way before getting marked as ready for release, but is it better to test feature in a branch or in master (considering we decide to stick with gitflow style)?&quot;, &#39;We\&#39;re \\~15 developers in our project.\n\n&amp;#x200B;\n\n&gt; Also we were thinking about moving to trunk-based development because we have few people and everyone is fed up with rebasing 1k LOC patches. \n\nEveryone hates merging. In another project, they use feature branching (they\&#39;re around 20 people)... they need about 20h hour a week for merging feature branches (including fixing the merges).\n\n&amp;#x200B;\n\nWe use trunk based development. Instead of feature branching, we use branch by abstraction with/and feature toggling (see Continuous Delivery by Jez Humble). This is also recommended in Accelerate by Nicole Forsgren (teams with trunk based development or short lived feature branches (1-2 days) have a higher software delivery performance (lead time \\[time from push to baseline to deployment to production\\], and deployment frequency \\[deployments to production\\]).\n\nUsing feature branches which live too long is not continuous integration. If you work with feature branches people have to ensure, that they merge the master branch into the feature branch daily, and that the whole pipeline is set up for that feature branch, too.\n\nIf you do trunk based development, you have to have a different attitude and culture: If a build breaks, it\&#39;s the highest priority of the team to get the build running again. In the sense of: Be always ready to release. You have to be very sure, that your commit *works*. There\&#39;s no \&#39;save work\&#39;, no FIXME\&#39;s, sometimes TODO\&#39;s are okay (but usually not): You have to be sure, that when you push, that your code can be shipped at that moment. This sounds Utopian, it probably is, but that\&#39;s the direction a team should go in my opinion. I think that\&#39;s the hardest part for a team which wants to transform to a &quot;high performing software delivery team&quot; (ship software better and faster, shorter lead time and higher deployment frequency).\n\n&amp;#x200B;\n\n&gt;We release 2-4 times a year, but I\&#39;m a proponent of frequent releases, so I expect that to change. \n\nGood luck!I highly recommend the already mentioned books: \n\n&amp;#x200B;\n\n* Accelerate by Forsgren (if you want to get the management to your side, because that\&#39;s actual science.)\n* Continuous Delivery by Humble (Humble worked also on Accelerate. The book is a bit old, the the principles stay the same)\n\nWe try to release as soon as a feature is ready. This means, from the time the issue is ready to be implemented and gets started working on, it gets pushed through: development, code review, QA, shipped to the customer, deployment to production. We actively track issues that stay in the same phase too long and treat it as a problem.\n\nThose times are actually very interesting and important metrics, if you want to get your feature to the user faster (lead time). The argument is this: When you push to mainline, your QA has tested it, you *can* deploy to production, right? Every day you wait, it\&#39;s wasted money, or even lost customers.\n\n&amp;#x200B;\n\n&gt;Wouldn\&#39;t it be better to perform manual tests only between code freeze and release and rely on auto tests in CI at other times? \n\nNo, because of the following reasons:\n\n* Feedback is essential. It\&#39;s better to get feedback today, than let\&#39;s say a month. \n* Manual tests (exploratory tests) are part of your software delivery pipeline, too! The issue is not done, when it hasn\&#39;t been tested, simply as that. And when it\&#39;s not done, it can\&#39;t be deployed to production.\n* Don\&#39;t work with code freezes, work with built artifacts. An artifact in the sense of: You have pushed to mainline, pipeline and automated tests are green, it has been deployed to your QA system. This artifact must be shipped. We do have code freezes too, but they last sometimes a day. With trunk based development, this is horrible... we\&#39;re working on it.\n\n&amp;#x200B;\n\n&gt;As for feature branches I can understand that a new feature should be tested in some way before getting marked as ready for release, but is it better to test feature in a branch or in master (considering we decide to stick with gitflow style)? \n\nWhen you use trunk based development, this question is obsolete. If you work with features branches, it probably depends on what works best for you: When do you decide when a features is ready to be merged into the master branch? When it\&#39;s tested or ready to be tested? Problem always is: Is your code still the same, after you merged 1000 LoC\&#39;s?&#39;, &#39;So, basically prod management will say &quot;We need a thing!&quot;  \n\n\nEngineering will say &quot;What thing? What are you talking about? You have to be more specific&quot;  \n\n\nBut then the story comes. There\&#39;s a wireframe that was made 3 years ago and forgotten about and now does not match the product at all.\n\n&amp;#x200B;\n\nEngineering says &quot;Hey, why are you sending us this?&quot;  \n\n\nThen the story is in the sprint.  \n\n\nWe try to break out tasks.  \n\n\nWe complete the tasks and then PDM looks at them and their vague UAC and says &quot;This isn\&#39;t what we wanted. What were you guys doing?&quot;  \n\n\nEngineering says &quot;This is literally exactly what you wanted&quot;  \n\n\nAnd we start over. We\&#39;ve been implementing a search field for 2 years. Have fun. (new)&#39;, &#39;Have you looked ar GitFlow? May give you some ideas? We use it. (new)&#39;, &#39;You should really look hard at why you have to keep several master branches.  This seems to be a root problem and is not typical.  It’s better to look at internal configurations or feature flags to solve application behavior/feature differences than it is to maintain long-term parallel codebases.  This would also save on QA time as common code/features won’t have to be re-tested on each master branch.\n\nAlso, merges shouldn’t typically be painful unless you are working the same sections of code on different branches.  If that is the case, I would look at addressing this with better planning and a review of if your branch needs.\n\nAlso, you must test immediately after coding a story.  Waiting for some post-code-close regression period to find issues is too late.  It’s much better to fix problems immediately when the code is fresh in your mind.  Also it becomes another impediment to increasing your release cadence. (new)&#39;, &quot;Damn, thanks a lot for sharing and for references! Should help me to convince our management to adopt trunk based development.\n\nDo you run CI tests *on trunk* each time a commit is pushed to trunk? How much time it takes to run all the tests in your project?\n\nHow code reviews are performed in your dev process? Do you review before pushing or after?\n\nSome people argue for squashing commits in feature branches so that git log is not &#39;polluted&#39; or something. Personally I think that smaller commits allow to pinpoint fresh bugs easier, but I wonder if there is any downside in having a lot of small commits?&quot;, &#39;Sounds like you need to enforce entry criteria.  If you are using sprints, I assume you are intending to follow some form of agile development.  Though I’m guessing from your statements, that you don’t really work as a team.  Just throwing requirements over the wall is never going to work smoothly.\n\nIn a proper team approach, you would only commit to completing a story when it meets the entry criteria as defined by the team.  If it doesn’t meet the entry criteria, then it doesn’t make the sprint.  Also, product should be included in the team and providing daily feedback and collaboration to avoid the misunderstood requirements.  In short, you must shrink the feedback loop considerably in order to be effective. (new)&#39;, &quot;I know about Gitflow but in my experience feature branches tend to become rather long-lived, so I&#39;m leaning more towards trunk based development right now.&quot;, &quot;You are absolutely right that we should not maintain several branches, though that&#39;s not a root problem. Several clients insisted on keeping particular versions (or so I was told) and someone decided that we have enough hands to do bugfixes on all those stale versions in addition to an active development of the master. Most likely we&#39;ll stop supporting those versions soon so that won&#39;t be an issue anymore.\n\n&gt; Also, merges shouldn’t typically be painful unless you are working the same sections of code on different branches.\n\nUnfortunately our code is tightly coupled (and due for refactoring), as a result major features tend to touch most parts of the system leading to conflicts. (new)&quot;, &#39;&gt; Should help me to convince our management to adopt trunk based development. \n\nHint: Make small steps. Those transformations must be worked on continuously and relentlessly. It took us years. E.g. from hours of sunday work because of deployment pain to deployments by pressing a button was a shit ton of work (I guess took us about a year, and we\&#39;re still not totally happy with it). Or from releasing few times a year, to up to few times a week (&gt;\\~ 2 years). You don\&#39;t get to that point for free, and you don\&#39;t get to that point tomorrow. \n\nAnd: If your whole team is running very well with the feature branches, look out for other parts of your process which can be improved - because changing from feature branch based development to trunk based development is harder than one might think. Because for instance branching by abstraction and feature toggling needs a lot of thought, not only from the developers, but form product owners and from the teams which maintain peripheral systems. (See also continuous improvement process). \n\nAnd: To drive improvement, there\&#39;s not only continuous delivery capabilities such as trunk based development and test automation, but also architectural capabilities (Clean Architecture by Uncle Bob), product capabilities (customer feedback, experimentation), process capabilities (value stream), management capabilities (monitoring, visualize work) and especially cultural capabilities (support a learning culture). All those capabilities drive your transformation and your software delivery performance. It\&#39;s not only the tech people who can drive this transformation. Management and &quot;product&quot; people have to improve themselves or change how they work, too.\n\n&amp;#x200B;\n\n&gt;Do you run CI tests *on trunk* each time a commit is pushed to trunk? How much time it takes to run all the tests in your project? \n\nYes, that\&#39;s an absolute necessity, the feedback of the quality of your work has to be received as soon as possible. That\&#39;s why it\&#39;s called continuous integration/delivery, and not \&#39;when-we-feel-like-it-integration\&#39; :P\n\nIt takes the pipeline (build/lint/unit tests/integration tests/schema creation/schema migration \\[incl. real data\\]/server boot/acceptance tests) around 30/45 min to get through, depending on how the CI server feels at the moment (projects has \\~1.5 Mio LoC\&#39;s). So basically our CI server is running all day long. But this was challenging too. We went from \&#39;hours\&#39; to \&#39;\\~30 min\&#39;, from \&#39;one fixed backend for all integration tests\&#39; to parallel test executions with n backends running in a docker container. This wasn\&#39;t free either, we had to change the structure of our project and our code, so the tests could even run parallel, setting up docker registries, building images, and of course we have to maintain all this stuff. We also educated ourselves about testing/tdd/mocking frameworks and we try to reduce the amount of integration tests and do unit tests instead.\n\n&amp;#x200B;\n\n&gt;How code reviews are performed in your dev process? Do you review before pushing or after? \n\nAfter pushing. But that\&#39;s because of our tooling. I would say, that doing reviews before pushing is the better approach here. Reviews can find bugs, so a bug on trunk means not ready to release. We do have problems with that (the fact that the review is done after push), we try to get a hold on it by trying to do reviews ASAP -&gt; because code review is part of the value stream, reviews have to be done (including the changes from the review), before it can be moved to QA.\n\n&amp;#x200B;\n\n&gt;Some people argue for squashing commits in feature branches so that git log is not \&#39;polluted\&#39; or something. Personally I think that smaller commits allow to pinpoint fresh bugs easier, but I wonder if there is any downside in having a lot of small commits? \n\nI prefer smaller commits.\n\n* What you said (find bugs early), but this also means, that those commits have to be pushed. You don\&#39;t have that benefit, if you push once a week.\n* Changes can be tracked more easily. You see how a feature has evolved (imo also especially how it interacts with other parts of the code). Your annotations say &quot;added fields xy&quot;, &quot;add sort functionality&quot;, &quot;changed calculation of z&quot;, instead of &quot;added feature x&quot;. If your searching bugs, or try to figure out why something works this way, because the initial change request was five years ago, a \&#39;polluted\&#39; log is much more valuable.\n* Code reviews are more productive (1000LoC Review: &quot;Well, looks okay&quot;, 20 LoC Review: &quot;I see SEVEN things which can be done better&quot;). And I think everyone in our team is pissed of when he gets a huge code review :P\n\nAnother thing is to work  in \&#39;\&#39;small batches\&#39;, but this means primarily to be able to split work &quot;into smaller chunks that deliver measurable business outcomes quickly for a small part of our target market&quot; (Chapter 4 in Accelerate :P).\n\nOther projects have sometimes like 10-15 lines/features branches side by side. Our git log is more or less a straight line. This is because of the trunk based development and because we rebase before pushing. We as a team find it much, much more convenient this way. For us, or at least for me, the \&#39;vertical clutter\&#39; isn\&#39;t really a problem, but the \&#39;horizontal &quot;complexity&quot;\&#39; is.&#39;, &quot;Oh, I know... The engineers know. We just don&#39;t make those decisions (new)&quot;, &#39;door cows ring swim disgusted domineering rich squeal cooing modern\n\n *This post was mass deleted and anonymized with [Redact](https://redact.dev/home)* (new)&#39;, &quot;Thanks again, guess it&#39;s time for me to hit the books. (new)&quot;, &#39;I feel for you.  Time to make the only decision you can.  Find a different company.  You can’t help an organization that doesn’t want to be helped. (new)&#39;, &quot;Yeah, it&#39;s basically either that or tbd. (new)&quot;, &quot;I am. Looking is slow because there&#39;s timing issues. Remote work would be good, but being remote work at a reputable company isn&#39;t the easiest thing. (new)&quot;]</td><td class="s12" dir="ltr">[&#39;Accelerate release cycles (+)&#39;, &#39;Adopt CI/CD pipelines for automated integration and delivery&#39;, &#39;Automate code quality checks (linting, testing, analysis)&#39;, &#39;Automate test execution (unit, integration, e2e)&#39;, &#39;Automated build and tests always pass on the CI&#39;, &#39;Commit frequently (daily)&#39;, &#39;Containerization and orchestration tools used&#39;, &#39;Cultural or organizational resistance is common (-)&#39;, &#39;Deploy frequently and provide fast feedback&#39;, &#39;Enable fast and continuous feedback (+)&#39;, &#39;Encourage team collaboration and communication (+)&#39;, &#39;Enforce discipline for stable builds and testing&#39;, &#39;Feature flag complexity and debt management required&#39;, &#39;Initial migration effort was significant. (-)&#39;, &#39;Make small, frequent commits&#39;, &#39;Mandatory code review policy&#39;, &#39;Promote frequent and rapid integration (CI) (+)&#39;, &#39;Reduce merge conflicts (+)&#39;, &#39;Requires robust testing and test infrastructure (-)&#39;, &#39;Requires strong discipline and team coordination (-)&#39;, &#39;Shortens automated feedback cycles by testing each trunk commit against the main codebase through CI/CD pipelines (+).&#39;, &#39;Simplifies the development workflow (+)&#39;, &#39;Small team&#39;, &#39;Trunk always ready for release&#39;, &#39;Use a single shared trunk&#39;, &#39;Use branch by abstraction&#39;, &#39;Use feature flags to safely integrate incomplete features&#39;, &#39;Use short-lived branches&#39;, &#39;Avoid big-bang merges&#39;, &#39;Rebase before merge&#39;]</td></tr><tr style="height: 30px"><th id="958685326R25" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">26</div></th><td class="s2" dir="ltr"><span class="s3" style="background-color: #ddebff; color: #2a3243; width: 147.0px; max-width: 147.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">devops</span></td><td class="s4" dir="ltr">How to handle releases for different environments in Trunk Based Development?</td><td class="s5" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/devops/comments/1gilg78/how_to_handle_releases_for_different_environments/">https://www.reddit.com/r/devops/comments/1gilg78/how_to_handle_releases_for_different_environments/</a></td><td class="s5" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/devops/comments/1gilg78/how_to_handle_releases_for_different_environments/">https://www.reddit.com/r/devops/comments/1gilg78/how_to_handle_releases_for_different_environments/</a></td><td class="s6" dir="ltr"><span class="s3" style="background-color: #d5deeb; color: #383a3c; width: 128.0px; max-width: 128.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">YANLIŞ</span></td><td class="s4" dir="ltr">[&#39;How to handle releases for different environments in Trunk Based Development?&#39;, &quot;Im quite new to trunk based development. Assume you have a repository for microservice. Let&#39;s say there are separate repo for each microservices. Developers also follow the trunk based development(TBD).\n\nHow would you handle QA release, Staging release and Production release?\n\nI really need to know how you handle these things? How would you build your docker image for these environments (do you re-build or just promote the same build)? if it is, how? How to version them? Which  actions fires the QA release, Staging release and Production release?\n\nI&#39;m pretty sure there is no exact way, But really like to see different approaches.  Thanks in advance.&quot;, &#39;QA/Staging/Prod all use the same image.  \n\nWe push to a dev environment on every merge to main.  A git tag creates an RC build with images labelled by the commit hash and deployed to QA/staging.  A GitHub release against that tag deploys to prod. (new)&#39;, &quot;Trunk based developed just defines what developers do to create the code of a container image (or other artifact). This shouldn&#39;t really be that important to you.  You just take the container image and promote it to the rest of the environments. The **exact same** artifact. No rebuilds. Configuration for each environment is external (not part of the container)\n\nSo what developers do (opening pull requests and merging) is unrelated to how YOU promote the image from one environment to the next.\n\nRegarding versioning you can do 1) Git hash 2) date 3) build number 4) semver or any combination of the above.\n\nMake sure you also read the 12 factor app [https://12factor.net/config](https://12factor.net/config)&quot;, &#39;To do this well is tough - realize that you need to align release, deployment and development processes.\n\nRelease = a capability (feature, bugfix, etc) goes to users.\nDeployment = a runtime change of the binary image.\nDevelopment processes = the end-to-end SDLC, starting when development begins  and ending with release.\n\nYour SDLC is the end to end thing.  It includes any deployments, QA, tests, etc.\n\nWith trunk based, it means you have only one long-lived branch:  trunk.  Every other branch needs to be short-lived.  If you have long-lived branches that “denote” your environments, you are not trunk based.  That’s fine, just call a spade a spade.  \n\nEngineers need to be constantly pulling and merging master in their development process.  This is key but it creates a ton of problems if you don’t have lots of good, high-quality, autonomous tests.\n\nIn trunk-based, your CI/CD pipeline has different stages where each stage aligns to an environment, typically.  Environments must must MUST be equivalent to get this right.  So your IaC practices need to align here - using the same “trunk” code where you just change parameters that affect scaling-type concerns.\n\nIn trunk-based, you really SHOULD use one binary image per pipeline run.\n\nSo - having said all this you should see the challenge I hope - how do you manually test?  How do you manually deploy?  Not it’s not just a single image, you have many images potentially floating around your pipelines at once. Your single binary image has all changes made previously, so think of pipeline = commit = image.\n\nYou either need ephemeral environments and full autonomous tests with no manual intervention, OR a release management process where you end up merging multiple feature branches and dealing with cherry picking and such. \n\nWoo boy.\n\nThe way I like as a platform engineer is to instead use feature flags per feature branch.  Since you have one “blessed” image that will have all changes merged before it, you use flags to “turn on” the tested features.  It also saves you when you deploy a grenade by accident - just turn the flag off!\n\nTL;DR - lots of places call it trunk-based but don’t actually use it to gain the benefits, which require deep autonomous tests to be able to take full advantage of them.  Your IaC practices need to align to your dev practices and your environments better be equivalent and ideally ephemeral.\n\nHave fun!&#39;, &quot;No QA environment after merging to trunk. If you need manual QA before release, just hide stuff behind feature flags in production. If you really need to run manual QA before deployment (!), then don&#39;t use TBD for this, but develop it on a feature branch and deploy that branch to QA.\nFor staging, if it is a true staging environment, then the flow would be: artifact gets released to staging, automatic testing happens on staging, once it passes, artifcat automatically gets promoted to production. But in practice, especially with microservices, there&#39;s often blue/green deployments, canary deployments or something similar instead of staging: Stuff gets deployed to a second version of production, some tests are run, and while things continue looking good traffic is shifted over until all traffic is on this second version of production. (new)&quot;, &#39;You build aka release an artifact (docker Image) which you ship through environments. Google releaseplease automates a lot of that. (new)&#39;, &#39;When we\&#39;re ready to push to staging we have a CI pipeline step that creates a git tag for the release, where it\&#39;s semver + minor-rc1. So if last release was 6.1.0, we tag 6.2.0-rc1. This scheme also applies to the Docker image.\n\n\nIf things go well, we promote and it eventually goes to prod, where another pipeline step creates the 6.2.0 GitLab release, closes Jira tickets associated with the release, and publishes the release notes to Slack. This also means the next release is 6.3.0 because the GL release is the source of truth for the version number.\n\n\nIf something goes wrong and we need to merge new code in before we ship, it becomes 6.2.0-rc2. If we create a branch off of the tag and name it &quot;hotfix&quot;, the workflow is the same but we bump semver minor, so it\&#39;s 6.2.1. (new)&#39;, &#39;You’re correct. There are several ways to approach this. But the first question to answer is what strategy should I have? The strategy that works well for me is to separate the develop and build process from the release process. In essence, decoupling the developer workflow from the need to have a version deployed to an environment. Think of this as they are asynchronous processes that can happen separately. \n\nWhat that means in practice is changes in trunk are not triggering a deployment. Something else should be used to trigger a deployment.\n\nThere’s several decision points here. You can decide whether to make the publishing of the artifacts part of the build and test process or you can decide to make publishing the artifacts part of the deployment process. It’s a traded off based on your situation and needs.\n\nA practical example is having a pipeline that builds and runs unit tests when changes are pushed to trunk. And then a completely different repository that has text files containing the deployed artifact version. With a pipeline that, on changes to this different repo, deploys the version specified in the text file. A common practice is to have folders for each environment with a text file in each folder containing the deployed version. The workflow for deploying in this example would be the following. \n\nChange the version in the qa/version.txt file to microservice1-main.1.1.25\n\nCommit and push the change. \n\nThe pipeline would kick off and deploy that version to Qa.\n\nOthers have already mentioned versioning strategies that can be used when publishing artifacts.\n\nThis strategy eliminates the thrashing that happens when people start doing trunk based development with the common practice of triggering a deployment on push. It also empowers the Qa team to be in control of when a deployment is done for their environment. So they can control their flow of work. And it enables the ability to quickly roll back to a previous version when a production release happens with an issue. \n\nIt adds complexity because now you have to manage a separate repo. But in my experience, that additional work was totally worth the power of this approach.&#39;, &quot;There&#39;s a bunch of really good answers here so I won&#39;t repeat what they&#39;ve said. Tldr tagging is your friend here.\n\nWhat i highly recommend you do is sit down with the devs and talk to them about this. What deployment strategies are they familiar and/or comfortable with? How often do they deploy and are they following the concepts of rapid deployment cycles? What are their knowledge gaps with where you want to end up? Use all that info gathered to find a strategy that your developers (or at least the tech leads) can get behind.\n\nAt the end of the day, your developers need to actually adopt your ideal deployment strategy. If they don&#39;t then you end up with information silos and general chaos. \n\nThere&#39;s a dozen valid ways to do it. They key is finding the way that actually gets done. (new)&quot;, &#39;Sounds like the 12 factor app would be a good read for you.\n\nhttps://12factor.net/ (new)&#39;, &quot;If you stand back from the problem, it&#39;s not about how you release software from one repository. It&#39;s about how you manage the release of a distributed application composed of multiple separately versioned components.\n\nTo labour the point, because each microservice sits in a separate repository, it&#39;s not possible to create a tag that spans those repositories. For this reason, some companies practice what is called a monorepo, where all code is held in the same repository (famously used by Google), but is not well supported by Git.\n\nSo what&#39;s the alternative? My recommendation is three-fold:\n\n1. Package each microservice release as an immutable + installable object (for example, helm chart)\n1. Have a mechanism to record the latest versions of each component in order to capture a stable combination of components that can be deployed into a new environment (for example, umbrella helm chart)\n1. Introduce feature (or release) flags into your microservice code. The main purpose is to orchestrate a change that spans multiple components, acknowledging that it may not be possible to deliver these changes simultaneously.\n\nThe primary benefit of feature/release flagging is that it decouples the act of deployment from the introduction of functional change. Each component  needs to guarantee that it is both backwards and forwards compatible. Naturally this requires tests to prove this thesis. I consider feature flagging a prerequisite for the safe practice of [Continuous Deployment](https://en.m.wikipedia.org/wiki/Continuous_deployment).\n\nAnd I would recommend not building your own feature flagging framework (inventing wheels) and consider what some of the more advanced frameworks \n (like [ReleaseDarkly](https://launchdarkly.com), not only option) can do. The ability to enable flags for a subset of environment users (like testers) is a powerful mechanism to reduce the number of environments you need to maintain. Practicing [Dark Releases](https://martinfowler.com/bliki/DarkLaunching.html) is a powerful technique that enables you to more safely release software to production.\n\nI hope this helps (new)&quot;, &#39;Single artifact promotion using a helm chart. So all the updates to all microservices get promoted together as a single artifact (new)&#39;, &#39;This is kind of an answer I was looking for. Thank you so much. (new)&#39;, &#39;Something I struggle with is those ephemeral env. The images built and deployed during development (from a feature branch / PR) are typically tested and verified by their developers and maybe some QE. Once merged to master a new image is created, and is, technically, no longer the artifact that was tested within the PR. I can’t imagine we’d ever want to deploy to production an image that was built from a feature branch, lol.\n\nI’v historically been of the mindset that whatever’s on master is deployed to Production, but that seems to align more closely with GitFlow strategies. For TBD, I imagine an artifact is indeed created for each merge to master, but the “pipeline” that exists for production bound images starts _after_ that merge. The master branch is no longer considered golden, but rather particular commits that actually made it to Production.\n\nI’ve always thought of feature branches and the ephemeral environments created on their behest as part of the pipeline, but I suppose that doesn’t really track for TBD.\n\nThis was helpful, thank you! (new)&#39;, &quot;First of all thanks for the response. As I undeerstood your flow, when you ready to do a staging, you create a git tag. lets say you&#39;ve created git tag 6.2.0 somewhere. Now QA approved it and it&#39;s okay to go for prod, you create git release from that 6.2.0 git tag right? once that release created from tag, some CI will it re-tag the same docker image(image:6.2.0-rc1) you created in in previous CI where git tag is created. No need to builds the image again right? (new)&quot;, &quot;I&#39;ve used same kind of approach. but the approach is bit different. I used separate deployment-config repository where it contains, kustomize files for each microservices. I&#39;ve used kustomize overlays for each and every environments.  Each microservices repository has its own set of CI pipelines. When I wanna do a release what I do is, first create a git tag. and then it will invoke the CI and build a image and update the kustomize repository related microservices manifest file with this new version in staging overlay. Then since the source repository of ArgoCD (deployment-config) changed (staging overlay changed with new image tag) ArgoCD will deploy to staging cluster. Once QA verified, I create a release from that git tag. When it creates a git release, there is another CI pipeline which will get invoked and re-tag the previous docker image with version. (ex: service-a:1.0.0) Now the pipeline will update production overlay of related microservice in deployment-config repository. ArgoCD will get to out of Sync state, it won&#39;t deploy to prod. because I configured prod deployment as manual sync. so I have to go to ArgoCD and click sync button. then it get deployed to prod. (new)&quot;, &#39;[removed] (new)&#39;, &#39;Oh!  See you should never change the binary image in trunk based (in my opinion) unless you go back to the very beginning with a commit.\n\nAlso - think of a pipeline as a commit to master.  Makes things a little easier.&#39;, &quot;Yep, no rebuilding. When its approved and we&#39;re ready to deploy the release we just tag it as 6.2.0 (without the -rc1) in git and Docker. (new)&quot;, &#39;I’m glad you’re using Argo cd. This is the way. (new)&#39;, &#39;u/confusedndfrustrated Could you please explain me what you meant by defined Tagging policy? Any examples would be great. (new)&#39;, &#39;Your comments are very much in line with true TBD. For those interested in further reading, check out dora.dev capabilities area. (new)&#39;, &#39;Concretely within GitHub Actions, for instance, that’d be \n\n1. PR with N images built up for ephemeral env testing. Unit test and lint. Ensure PRs can’t be merged unless master is merged in\n2. Merge to master once satisfied with changes. This is the commit sha that will start the delivery process. Create 1 image accordingly. Integration and e2e test.\n3. Tag commit sha for Production Release once approved, manually or automatically.\n4. Promote correlating image to Production. (new)&#39;, &#39;Another question, why its called -rc1, is it possible it to be -rc2, -rc3 as well then? if it is then in which case it could be? (new)&#39;, &#39;[removed] (new)&#39;, &#39;Release Candidate, as in it should be the release but we\&#39;re not 100% sure yet.\n\n\nWe give it the &quot;rc&quot; label when we\&#39;ve cut the release and deployed to staging, and remove that label when we deploy to prod. If we deploy to staging but find a blocking issue in the rc that needs to be fixed with another merge to the main branch, the next time we deploy to staging it becomes rc2. If we merge again it becomes rc3, etc. It\&#39;s automatic and part of our pipelines.\n\n\nVery rarely do we go beyond rc1. (new)&#39;, &#39;Ohh great… waiting to see some details. Thank you so much. (new)&#39;, &#39;Thanks. So when you need to do a staging release, you create a git tag. You do it manually right?(for an example, go to GitHub and creates the tag) then do you manually decide the tag version? (6.2.0-rc1) Or how it happens? (new)&#39;, &#39;We have a manual CI step called &quot;tag for release&quot; so someone clicks the button and it applies the tag in git and to the docker image.\n\nWe do not decide the tag version. The job GitLab is running is a tool we built to handle the release process for us, written in Python. It determines the next version and creates the tag. No human intervention is needed, just need to click the button.\n\nThe logic it uses is:\n\n* Did we tag a release earlier and not deploy it to prod? If so, we found a release blocker and need to bump the rc version, so this becomes rc2, rc3, etc.\n\n* Otherwise, check the releases API to get the next version number. If our branch is named &quot;hotfix&quot;, bump the version by 0.0.1. If this branch is &quot;main&quot; (a normal release), bump the version by 0.1.0. Append -rc1 to the version.\n\nWhen we deploy to prod, another CI job named &quot;publish release&quot; adds an additional tag that lacks the &quot;rc&quot; number. It then associates all Jira tickets with next-servicename-release with this version, and publishes the release using the &quot;releases&quot; API and to Slack. The release notes contain a list of all tickets and their descriptions. (new)&#39;, &#39;u/tapo  Thank you so much for all these information. (new)&#39;]</td><td class="s7" dir="ltr">[&#39;Accelerate release cycles (+)&#39;, &#39;Adopt CI/CD pipelines for automated integration and delivery&#39;, &#39;Automate code quality checks (linting, testing, analysis)&#39;, &#39;Automate test execution (unit, integration, e2e)&#39;, &#39;Automated build and tests always pass on the CI&#39;, &#39;Commit frequently (daily)&#39;, &#39;Containerization and orchestration tools used&#39;, &#39;Deploy frequently and provide fast feedback&#39;, &#39;Enable fast and continuous feedback (+)&#39;, &#39;Enforce discipline for stable builds and testing&#39;, &#39;Feature flag complexity and debt management required&#39;, &#39;Improve software quality and stability&#39;, &#39;Integrate CI/CD tools&#39;, &#39;Maintain traceability and code history&#39;, &#39;Trunk always ready for release&#39;, &#39;Maintains system reliability despite rapid delivery, thanks to automated testing and CI/CD safeguards.&#39;, &#39;Make small, frequent commits&#39;, &#39;Manual approval in staged releases&#39;, &#39;Needs reliable CI/CD and automation tooling (-)&#39;, &#39;Promote frequent and rapid integration (CI) (+)&#39;, &#39;Reduce merge conflicts (+)&#39;, &#39;Reduced lead time helps deliver features and fixes faster, respond to user feedback more quickly&#39;, &#39;Requires robust testing and test infrastructure (-)&#39;, &#39;Requires strong discipline and team coordination (-)&#39;, &#39;Shortens automated feedback cycles by testing each trunk commit against the main codebase through CI/CD pipelines (+).&#39;, &#39;Simplifies the development workflow (+)&#39;, &#39;Staged rollout with rollback support&#39;, &#39;Support safe experimentation and rollback&#39;, &#39;Tooling includes quality and monitoring support&#39;, &#39;Transparency is emphasized, ensuring developers are aware of the current build status and rollout information.&#39;, &#39;Use a single shared trunk&#39;, &#39;Use feature flags to safely integrate incomplete features&#39;, &#39;Use feature flags to Support progressive delivery (A/B testing, dark launches)&#39;, &#39;Use feature flags to decouple deployment from release&#39;, &#39;Use internal/custom-built tools for specialized needs&#39;, &#39;Use short-lived branches&#39;, &#39;Use tags for releases&#39;, &#39;Avoid big-bang merges&#39;, &#39;Single artifact promotion through environments without rebuilds (artifact immutability) (new)&#39;, &#39;Externalize environment-specific configuration from artifacts (new)&#39;, &#39;Use deployment configuration repositories (e.g., kustomize overlays) to control environment releases (new)&#39;, &#39;Ephemeral environments for feature/PR testing prior to trunk merge (new)&#39;, &#39;Manual promotion and approval steps in deployment pipelines for environment progression (new)&#39;, &#39;Automated versioning and tagging logic in CI/CD for release candidates and hotfixes (new)&#39;]</td></tr><tr style="height: 30px"><th id="958685326R26" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">27</div></th><td class="s8" dir="ltr"><span class="s3" style="background-color: #dce9cb; color: #2c481f; width: 147.0px; max-width: 147.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">git</span></td><td class="s9" dir="ltr">How would you classify this workflow? And how could it be improved?</td><td class="s10" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/git/comments/12yjb58/how_would_you_classify_this_workflow_and_how/">https://www.reddit.com/r/git/comments/12yjb58/how_would_you_classify_this_workflow_and_how/</a></td><td class="s10" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/git/comments/12yjb58/how_would_you_classify_this_workflow_and_how/">https://www.reddit.com/r/git/comments/12yjb58/how_would_you_classify_this_workflow_and_how/</a></td><td class="s11" dir="ltr"><span class="s3" style="background-color: #d5deeb; color: #383a3c; width: 128.0px; max-width: 128.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">YANLIŞ</span></td><td class="s9" dir="ltr">[&#39;How would you classify this workflow? And how could it be improved? (new)&#39;, &quot;I&#39;m mostly the only one working in this repo, but it&#39;s a fairly large one. Occasionally, another developer will work on it too.\n\nLet&#39;s say after a new release, everything is at a clean state.\n\n* I have a master and a develop branch that start off together.\n* I&#39;ll create a branch from develop to work on a feature (1-3 days maybe).\n* When that&#39;s done and tested, I&#39;ll rebase and merge it into develop.\n   * This is through an Azure DevOps PR that runs build and unit test checks.\n* For a hotfix, I&#39;ll branch from master and merge when complete.\n   * Then rebase develop onto master.\n* When I&#39;m ready for a release, I&#39;ll fast-forward merge develop into master and create a release build and tag.\n\nThis feels close to trunk-based, but with an extra branch. I like having master as moving point for exactly what&#39;s in production, and develop for what&#39;s ready to go.&quot;, &#39;This is [git flow](https://www.gitkraken.com/learn/git/git-flow) (new)&#39;, &quot;What you’ve described is basic nuts &amp; bolts git usage that doesn’t need a name, isn&#39;t a &#39;workflow&#39;, shows some confusion about what branches are / branch identity is, sprinkled with a bit of jargon - \n\n  you have a &#39;source of truth&#39; branch  \n  you make changes on a branch - it doesn&#39;t make the slightest bit of difference how many intermediate branches you happen to make, or what they&#39;re called - you don&#39;t have developers with different roles / permissions assigned to branch names, so the names aren&#39;t significant (so definitely NOT doing git flow, or any derivation of it)  \n  sometimes you collaborate on changes (not that clear from your question, doesn&#39;t make a difference either way)  \n  there&#39;s no material difference between a hotfix and a feature  \n  &#39;in progress&#39; branches are kept up to date with the &#39;source of truth&#39; branch  \n  &#39;completed&#39; branches are merged back into the &#39;source of truth&#39; branch  \n  you have tests  \n  you have tags  \n\nwhich is all fine - it&#39;s what you should be doing - unless you’re under the impression you&#39;re doing something else significant (new)&quot;, &#39;You might want to think about how often you’ll update your feature branch during any regression testing or hardware in the loop testing you do on feature. You just say “done and tested” and in my world this is a big step in our process. Though if you’re the only one perhaps it’s not as pressing. \n\nAlso why do you want a develop branch? Why not test on feature entirely and keep feature updated as needed? I’m not persuading you to not use a develop branch I’m just curious if you have a reason other than just following some article. I’ve worked in environments where a feature branch is sufficient is why I wanted to kindly bring it up. (new)&#39;, &#39;Routinely rebasing `develop` onto `master` for hotfixes invalidates all feature branches originally based on `develop`. To keep `develop` up to date with `master`, you should be *merging* changes from `master` to `develop`. This allows you to easily update your feature branches, either through their own rebasing onto the updated `develop` or through merges from `develop`. (new)&#39;, &#39;I agree.\n\nIf you think about something simpler with nearly the same goals you could check out [OneFlow](https://www.endoflineblog.com/oneflow-a-git-branching-model-and-workflow). (new)&#39;, &#39;I thought that Git Flow typically had more longer lived branches, like releases, and had master and develop running in parallel, instead of develop just being ahead of master. (new)&#39;, &quot;This variation looks to be pretty much what I&#39;m doing: [https://www.endoflineblog.com/oneflow-a-git-branching-model-and-workflow#variation-develop-master](https://www.endoflineblog.com/oneflow-a-git-branching-model-and-workflow#variation-develop-master)\n\nExcept, I don&#39;t bother with release branches most of the time. (new)&quot;]</td><td class="s12" dir="ltr">[&#39;Automate test execution (unit, integration, e2e)&#39;, &#39;Automate code quality checks (linting, testing, analysis)&#39;, &#39;Use tags for releases&#39;, &#39;Use short-lived branches&#39;, &#39;Rebase before merge&#39;, &#39;Small team&#39;]</td></tr><tr style="height: 30px"><th id="958685326R27" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">28</div></th><td class="s2" dir="ltr"><span class="s3" style="background-color: #ddebff; color: #2a3243; width: 147.0px; max-width: 147.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">devops</span></td><td class="s4" dir="ltr">Is a full CI/CD pipeline for a containerized application possible without kube?</td><td class="s5" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/devops/comments/1eb7dj0/is_a_full_cicd_pipeline_for_a_containerized/">https://www.reddit.com/r/devops/comments/1eb7dj0/is_a_full_cicd_pipeline_for_a_containerized/</a></td><td class="s5" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/devops/comments/1eb7dj0/is_a_full_cicd_pipeline_for_a_containerized/">https://www.reddit.com/r/devops/comments/1eb7dj0/is_a_full_cicd_pipeline_for_a_containerized/</a></td><td class="s6" dir="ltr"><span class="s3" style="background-color: #d5deeb; color: #383a3c; width: 128.0px; max-width: 128.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">YANLIŞ</span></td><td class="s4" dir="ltr">[&#39;Is a full CI/CD pipeline for a containerized application possible without kube? (new)&#39;, &#39;Hi r/devops\n\nThe context around why I\&#39;m asking this is a bit long, so either bear with me or you can just skip the context part for the technical question.\n\n## Context:\n\nI\&#39;m a long time tinkerer/lurker of general dev stuff (built a home Nas and hosted a webserver on it, like to play script kiddo on several old pcs with Linux) who recently jumped into it professionally and was hired as a DevOps intern.\n\nI was hired as the sole (besides my boss and some frontdev contractors) developper in a startup a little more than 6 month ago, and boy, has it been --hard-- instructive.\n\nMy boss is a great manager and we frequently have debates over what tool to implement and other infra questions that I enjoy a lot.\n\nHe has experience mainly as a front developer though, and I found that it really shows. When coupled with his general optimistic attitude &quot;We\&#39;ll figure it out, don\&#39;t worry!&quot;, which in itself a good thing, it can lead to some... unreasonable expectations.\n\nFor example, when I was hired, the &quot;app&quot; consisted in a fully fledged react app hosted on firebase... Which turned out to be an empty hulk in terms of data and functionalities alimented by python scripts ran locally by my boss.\n\nMy first task was to &quot;Deploy it&quot; (the backend, ie jupyter notebooks) then &quot;connect it to the front&quot;, which I successfully completed, although if I had to do it again, I would certainly make different choices (mainly use firebase as it was intended instead of twisting it into working with a traditional backend)\n\nWe are now at a state where the app (front, back and db) talk to each other and somehow work, but it is honestly kind of a frankestein monster. Any software architect worth their salt would probably have a heart attack looking at the repo, and the questionable decisions made by my even less experienced self have already been problematic, as going for Google App Engine for the backend has proven troublesome when it came to orchestrating, for example, a (long running) data pipeline. It is, still to this day, a simple cron on my nas triggering a python script on the remote backend because of weird GCP and GAE limitations.\n\nAll that to get the back of the problem: since the app works, and it\&#39;s been done mostly by a single developer, we\&#39;ve unlocked funding and are now working towards unifying many other apps which were until now proofs of concept into a single unified behemoth. We\&#39;ve hired several people, including a &quot;senior devops&quot; which... well let\&#39;s just say he pushed secrets in clear to prod day one.\n\nAll that to get to where I\&#39;m mow: I am factually the only ops-ish person in a now 10 devs strong startup, each working on one to a couple apps.\n\nFor now, I somehow get it together, as so far the devs who worked fast were also of the not-too-blunt type, and I managed to help them make their part work on GCR (lamdas for you AWS people) but I can feel it becoming overwhelming quickly, especially since serverless isn\&#39;t gonna cut it for a few data and computation-heavy apps we\&#39;re working on. For these, I can spin up an instance real quick using terraform/pulumi and ansible.\n\nBut what about then? What about when it doesn\&#39;t work in prod? &quot;But it works on my machine&quot; had made my boss tell me to &quot;build a CI CD&quot; but I\&#39;ve come to realize it\&#39;s not that simple.\n\n## The actual question:\n\nWhere do I store all the secrets/configs for so many apps on a monorepo ? How do I inject them safely along the ci cd ?  A single giant .env/secret manager ? If so, what about servive accounts/credentials files? How do I handle database connections locally for tests ? \n\nHow do I even tackle Ci CD on a monorepo with trunk-based development without branches ?\n\nThe answer I\&#39;ve found so far online to all these concerns is always kube, which also seems to solve further issues like scaling and conf management.\n\nIf feel like a big multi service app is unmanageable without kubernetes, but my boss refuses to hear about it, as except me and my bootcamp level knowledge of kube, and a handful devs who worked in an already established cluster, we have nothing. And no time for learning it: we gotta deliver by next calendar year.\n\nMy guts tell me we\&#39;re going head first into a wall, and that it\&#39;s probably gonna be my job to run around everywhere with a huge roll of tape, but I\&#39;ve come round to realizing that\&#39;s what a DevOps is to most managers and devs.\n\nI\&#39;d still like to hear more experienced views on the matter, though: Am I gonna make it out alive without kube ?&#39;, &quot;You&#39;ve drastically overestimated this. Read: https://matt-rickard.com/dont-use-kubernetes-yet (new)&quot;, &#39;Kube is often overkill. There are other solutions like Fargate which are lighter. Kube is the one who h if you need it - you really need it. (new)&#39;, &#39;Take a look at skaffold for a small &quot;orchestrator&quot; useful in CI. And for secrets, I would look at sops + age. Allows them to securely be stored in git. You can then just include the age keys in your CI pipeline runner of choice to unlock the correct key for the current environment. For local/ci, you can directly use secrets. For deployed environments, you can feed the secrets into AWS Secret Manager, Kubernetes, ... (new)&#39;, &#39;have you looked at hashicorp nomad? \nim running many applications on nomad and its much faster to get running that kubernetes, nice ui for logs and debugging ect\n\nnomad + traefik, with the docker driver, cicd to build and publish containers for a container registry, then template nomad specs and push to a nomad server for deploy. (new)&#39;, &#39;Wow, that is an amazing resource. Thanks a lot! (new)&#39;, &quot;So, you&#39;re saying it&#39;s doable without kube ?\n\nI&#39;ve looked briefly into sops before, but as far as I understood it doesn&#39;t solve the problem fully, although it diminishes it greatly, as prod environments still need to get the private key from somewhere.\n\nI&#39;ll look into age though, thanks for the recommendation! (new)&quot;, &#39;How are you deploying the software? Assuming your pushing via pipeline, almost every pipeline runner supports secrets. (new)&#39;]</td><td class="s7" dir="ltr">[&#39;Adopt CI/CD pipelines for automated integration and delivery&#39;, &#39;Containerization and orchestration tools used&#39;, &#39;Integrate CI/CD tools&#39;, &#39;Needs reliable CI/CD and automation tooling (-)&#39;, &#39;Small team&#39;, &#39;Cultural or organizational resistance is common (-)&#39;]</td></tr><tr style="height: 30px"><th id="958685326R28" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">29</div></th><td class="s8" dir="ltr"><span class="s3" style="background-color: #dce9cb; color: #2c481f; width: 147.0px; max-width: 147.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">git</span></td><td class="s9" dir="ltr">Is Trunk Based Development Suitable For Library Project?</td><td class="s10" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/git/comments/nb9orl/is_trunk_based_development_suitable_for_library/">https://www.reddit.com/r/git/comments/nb9orl/is_trunk_based_development_suitable_for_library/</a></td><td class="s10" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/git/comments/nb9orl/is_trunk_based_development_suitable_for_library/">https://www.reddit.com/r/git/comments/nb9orl/is_trunk_based_development_suitable_for_library/</a></td><td class="s11" dir="ltr"><span class="s3" style="background-color: #d5deeb; color: #383a3c; width: 128.0px; max-width: 128.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">YANLIŞ</span></td><td class="s9" dir="ltr">[&#39;Is Trunk Based Development Suitable For Library Project?&#39;, &quot;In short, TBD key point from what I understand.\n\n1. All dev working on trunk, it&#39;s possible to use PR but with short task and short-lived branch.\n2. Feature toggle a new feature, which by default is OFF.\n3. Release by cherry-picking commits from the trunk.\n\nThe problem that comes to my mind when developing library using TBD is.\n\n1. Since it&#39;s a library project, it&#39;s impossible to add a feature toggle, each new class/component will still be accessible by the client.\n2. Most libraries have release channels: Stable, Next, NexMajor, Beta, RC, and some have LTS. So the problem I see here is release process will be extremely complex by cherry-picking commit. For example when the commits consist of features, bug fixes, and features that cause breaking change.\n\nAre there any library projects (opensource) that successfully implement TBD?\n\n**EDIT**\n\nSorry, I missed mentioning that the library should follow Semantic Release best practice. which is:\n\n**Stable version**: should only contains bug fix, new features should pass the Next -&gt; Beta -&gt; RC first.\n\n**Next version**: should contains bug fix and also new features but not breaking changes.\n\n**NextMajor version:** may contains all commits. (new)&quot;, &#39;expansion toothbrush shocking lock follow arrest direction decide hobbies possessive\n\n *This post was mass deleted and anonymized with [Redact](https://redact.dev/home)* (new)&#39;, &#39;&gt; For example when the commits consist of features, bug fixes, and features that cause breaking change.\n\nYou should avoid that. Bug fixes should be in their separate PRs. (new)&#39;, &#39;&gt; Most libraries have release channels: Stable, Next, NexMajor, Beta, RC, and some have LTS. So the problem I see here is release process will be extremely complex by cherry-picking commit\n\nProbably git alone cannot track it easily, you should maintain in bug tracker list of branches and releases where you release the fix. (new)&#39;, &quot;What kind of library are you developing?  \n\nFor a library, you need to pay attention to public APIs and versions, so you allow users to upgrade to new versions smoothly.  \n\nIMHO the Git branching strategy is less important than a clean APIs implementation strategy; for the versioning part, you can use what bother you less, even good ol&#39; Gitflow without the complications of feature toggles.   \n\nSome tips about APIs [here](https://www.oracle.com/corporate/features/library-in-java-best-practices.html) and [there](https://yourbasic.org/algorithms/your-basic-api/), if you want to take a look.\n\n[More](https://swagger.io/specification/) and [more](http://apistylebook.com/design/guidelines/) (new)&quot;, &#39;Our npm library always has its latest commit in `main` automatically publishes under an unstable tag, and we can always tag it as a new release whenever we want. Breaking changes are avoided as much as possible so we only support a stable release channel, though of course if needed we can always branch off an old tag if we need to backport a fix to a previous major release if necessary. (new)&#39;, &#39;[deleted] (new)&#39;, &quot;What if I don&#39;t want to release all the commits? since I want to release to specific release channel such as **Stable channel** (should only contains commit that contains fix bugs). **Next channel** should only contains commit with bugfixes and also new features, but not feature with breaking changes etc. (new)&quot;, &#39;I mean the commits on trunk consist of consist of features, bug fixes, and breaking change.  \nLest assume that the commit already created correctly, separated between bug fixes, features and breaking changes. **all of them are already on trunk**. (new)&#39;, &#39;Yes I think so, maybe the git flow with long lived feature branches more suitable for this case. (new)&#39;, &quot;It&#39;s a server side JavaScript library.\n\n&amp;#x200B;\n\n&gt;IMHO the Git branching strategy is less important than a clean APIs implementation strategy; for the versioning part, you can use what bother you less, even good ol&#39; Gitflow without the complications of feature toggles.\n\nYes, that is exactly what I thought. Semantic release may not suitable with TBD. (new)&quot;, &#39;did you adopt TBD? curious to know how would you prevent unstable feature in main branch being added in stable release? (new)&#39;, &#39;Thanks for commenting.   \nWhat do you mean by system update? is it the project itself needs an update or TBD itself need an update to becomes viable? (new)&#39;, &#39;racial foolish command cheerful muddle rainstorm north wistful history boast\n\n *This post was mass deleted and anonymized with [Redact](https://redact.dev/home)* (new)&#39;, &#39;Yes, but at least it is a separated change, you could cherry-pick it then. You may still have a conflict, but you would have a reference in branch to the bug (new)&#39;, &#39;ah sorry, i didnt read it correctly. yes that would work (new)&#39;, &quot;By having an extensive suite of tests and static analysis checks that runs on every commit. Basically doing exactly the same as we&#39;d do for a stable release, on every push. And code reviews before merging things into `main`. (new)&quot;, &#39;Its part of semantic release best practice. In short,  **Stable** release should only bump patch version (the last number), because some Company may have a strict review about a new feature.   \nThe **next** release (usually will be shared to some special clients which willing to test the new features) should only bump minor version (in the future when its become stable, but should pass BETA and RC first).   \netc. etc..   \nYou can see the a good show case [here](https://github.com/semantic-release/semantic-release/blob/master/docs/recipes/distribution-channels.md) and [here](https://github.com/semantic-release/semantic-release/blob/master/docs/recipes/pre-releases.md) (new)&#39;]</td><td class="s12" dir="ltr">[&#39;Use a single shared trunk&#39;, &#39;Use short-lived branches&#39;, &#39;Use feature flags to safely integrate incomplete features&#39;, &#39;Cherry-pick changes to release branches&#39;, &#39;Use tags for releases&#39;, &#39;Automate code quality checks (linting, testing, analysis)&#39;, &#39;Automate test execution (unit, integration, e2e)&#39;, &#39;Mandatory code review policy&#39;, &#39;Automated build and tests always pass on the CI&#39;]</td></tr><tr style="height: 30px"><th id="958685326R29" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">30</div></th><td class="s2" dir="ltr"><span class="s3" style="background-color: #ddebff; color: #2a3243; width: 147.0px; max-width: 147.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">devops</span></td><td class="s4" dir="ltr">in trunk based development, if using github actions, what does your workflow look like to deploy to dev/qa/staging?</td><td class="s5" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/devops/comments/19c3krr/in_trunk_based_development_if_using_github/">https://www.reddit.com/r/devops/comments/19c3krr/in_trunk_based_development_if_using_github/</a></td><td class="s5" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/devops/comments/19c3krr/in_trunk_based_development_if_using_github/">https://www.reddit.com/r/devops/comments/19c3krr/in_trunk_based_development_if_using_github/</a></td><td class="s6" dir="ltr"><span class="s3" style="background-color: #d5deeb; color: #383a3c; width: 128.0px; max-width: 128.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">YANLIŞ</span></td><td class="s4" dir="ltr">[&#39;in trunk based development, if using github actions, what does your workflow look like to deploy to dev/qa/staging?&#39;, &quot;What i am a bit lost at is the following:  \n\n\n1. do we tag in some identifyable way for each env? i.e dev-1.0.0 after merging to main, would trigger the pipeline to deploy into dev?\n2. what about when we want to promote that to qa and subsequently staging? aside of using a workflow dispatch with input for a tag we want to promote, i am struggling to picture how the flow would work in more automated fashion.\n3. if we use the tag mechanism to promote to lower env, doesn&#39;t that mean tags will build up? how do we keep that clean? (new)&quot;, &#39;You want to follow the build once deploy everywhere principle… you don’t tag for every environment but you tag every build in trunk as part of the process… when you deploy to an environment you deploy the same version you tested on dev, qa, then eventually production…\n\nKeeping the versioning clean you want to practice semver (which is the standard ? At least it should be?) builds on the trunk are Major.Minor.(extra info I forgot what actually goes here) and if you have branches its similar but with a dash and branch name defined (major.minor.extra info-branch info)\n\nHope that helps? (new)&#39;, &quot;We&#39;re not doing trunk based development yet but are considerations it. The current suggested workflow is that dev is updated on any commit to trunk. Staging is automatically updated on tag and then prod is the staging build that gets promoted through manual approval after staging is verified good.&quot;, &#39;We recently switched to TBD. Here’s our current workflow. \n\nPR Created: pipeline runs code/security scanning, as well as unit and component tests. \n\nPR merged into main: \n1. Pipeline runs code/security scanning, as well as unit and component tests. \n2. Builds container image and uploads to registry. \n3. Pipeline updates separate IaC repo. Updates the image tag of the dev.values.yml file. \n4. Pipeline invokes a Sync in ArgoCD to deploy to dev\n5. Pipeline waits for successful status. \n6. If successful, repeat steps 3-5 for QA \n7. If successful, queue steps 3-5 for PreProd. Requires approval. \n8. If successful, queue steps 3-5 for Prod. Requires approval. \n\nPR -&gt; Merge to Main -&gt; Dev -&gt; QA -&gt; PreProd -&gt; Prod\n\nAll one pipeline. Currently not enforcing the use of tags but teams are free to use them if they’d like to. They do not impact the pipeline though. (new)&#39;, &#39;Build once and promote. Build on commit to main, auto deploy to Dev, allow Devs to promote to additional lower environments and all way to Prod if organization is mature enough.\n\nSeparate logic for a hot fix branch. (new)&#39;, &quot;Tag a commit and push it. The tag triggers a build pipeline that ends with a push of the artifact to your registry. That&#39;s your build phase.\n\nNow use whatever deployment tool you have to take this new artifact and deploy it to whatever environment with whatever runtime. That&#39;s your deploy phase. (new)&quot;, &#39;Commenting, just to get back later and see the suggestions, we are moving to GitHub actions as well, this is doubt that even I have, should we create different workflows for dev &amp; then for stg/prod env release, where the stg/prod release is like a manual trigger of the workflow from a particular commit.\nAlso if we use Argo CD for k8s deployment, I know we can sync the dev env immediately but how is it done to deploy to stg/prod, like should we do it by maintaining a release branch or any other way? (new)&#39;, &quot;Everyone might be doing it in a different way but here is what I do:\n\n1. Yes, tagging would deploy to dev and tagging would deploy to prod as well. Tagging and pushing can be done via CLI.\n\n2. Prod will only be deployed on Main branch. Devs will push to their respective branches which will trigger a notification to the team and QA team will check them(we dont have a QA team so the product/project managers check them before merging). Once the leads/managers test it, PR is merged and deployed to prod. CI will run on every PR&#39;s when a review is requested. \n\n3. tag buildup has never been an issue for us. Can you elaborate on the clean part? You can use the PreRelease option to keep the release window clean to an extent.\n\nI would also like to see how full automation can be done to stage, pre prod and prod in an order using GHA. (new)&quot;, &quot;I mean it **really** depends on the circumstances. Like requirements, budget, team size, expectations, and so on. There is no one true way of doing things. And there is no such thing as 100% automation.\n\nUsually, in the simplest case, I don&#39;t bother with git tags. They can be used for other reasons, like helping with creating changelogs. But in the simplest case, the git commit id can be the version that is being deployed.\n\nIdeally you would have so short lived topic branches that you don&#39;t need to bother with versioning individual changes, it&#39;s just a continuous flow of changes. In reality this can prove challenging, but it&#39;s doable.\n\nYou could merge one thing at a time, and deploy to staging one at a time, but if you have a large volume of changes, and they take time to test, then you may have congestion and people sitting and waiting for their turn.\n\nYou could merge multiple changes at the same time, and deploy to staging for testing, but then you risk different tests affecting each other. This will will always introduce a degree of uncertainty, but it works really well in practice in a lot of cases. If there is some bigger changes, just add some additional manual coordination when needed.\n\nYou could have more than one staging environment, to reduce congestion. This may or may not be costly, depending on what an environment needs to contain. In one project I created a personal mini-environment for every developer where they could dev and test stuff.\n\nYou could use blue-green deployments, where you dynamically create a whole new environment for every individual changeset / deploy, and promote by moving all the traffic over to the new environment. This is super nice, but it&#39;s not cheap or easy.\n\nYou could utilize feature flags, so that you are able to deploy unfinished code. This keeps changesets lean and fast. You can use some big established tool for it, or it can just be something simple and manual, like adding a new page on a website but not linking to it until it&#39;s finished.\n\nOnce you figure out a workflow that makes sense in your project and team, it kind of becomes obvious what you need to do to automate it. Github actions can be triggered on almost anything, merge to topic branch, merge to main branch, manually, etc. \n\nDiscuss with the developers and ask them what they want and expect, and work out a flow that meets the needs.\n\nAsk questions like: How small and fast are we able to go with changesets, realistically? How often will we need to deploy, realistically? How long will testing typically take? What type of changes are most common? Do we want to promote to production automatically, or should that be a manual action? (new)&quot;, &quot;I&#39;m in similar thoughts, we are looking at flux 2 and i&#39;m trying to imagine how the CD flow would look like, with or without image-scanning. Similar to this but for app releases (new service docker image version) https://fluxcd.io/flux/use-cases/gh-actions-helm-promotion/\n\nWould love to hear what other people are doing. (new)&quot;, &quot;Just keep it simple. A separate branch for each env that triggers a pipeline on merge. Always work upstream sandbix &gt; dev &gt; qa &gt; uat &gt; master/prod. \n   \nAlways branch off master to jeep the lower envs hydrated. Don&#39;t have long lived branches. If you do, enact feature flaggjng. (new)&quot;, &#39;To solve this problem we use GitFlow.\n\nDevs create a feature branch from the develop branch. Once this is pushed all unit tests run and the Terraform plan is output for review. There is an optional step to deploy this to the Dev environment.  Once the PR is merged to develop everything is deployed to the Dev environment.\n\nWhen we are happy we want to deploy to Production we create a release branch from develop. This again runs the tests, produces the Terraform plan, and deploys to our Staging environment. Here we can do any additional smoke testing. Any small fixes that are needed are committed directly to the release branch.\n\nOnce happy in Staging we merge the release branch to master. On merging to master a deployment to Production is triggered, a git tag is created and master is merged into develop.\n\nIf we have an emergency fix that needs to be done then a hotfix branch is created from master. This deploys directly to Staging, and on approval is merged to master. Merging to master in this process does the same steps a deployment to Production is triggered, a git tag is created and master is merged into develop.\n\nThis whole process is managed with GitHub Actions. (new)&#39;, &#39;RemindMe! 1 week (new)&#39;, &#39;I enforce configuration abstraction with helm, and package all my microservices as partial packages, the final `values.yml` is for the respective environment that they will be deployed to, the merge to master trigger starts the ball rolling. (new)&#39;, &#39;Another option is to use master as the definition of all environments, with separate folders for each environment. Then each env references a specific version of a published IAC module. (new)&#39;, &quot;The answer for most things devops: do less.\n\nDon&#39;t tag for environment. If you want to differentiate between pre-release and release builds (or stable vs non-stable... whatever)... just do that. (new)&quot;, &#39;PR approval gets deployed to staging, merge to main deployed to prod - sorted (new)&#39;, &quot;Currently doing the wrong: branch per environment (develop branch = dev environment, release branch = uat environment, main branch = production). DONT DO THIS\n\nPlanning to change to trunk based and I&#39;d like to kill development environment, this should be some kind of localhost docker compose or something similar.\n\nThe most simplier, fast and cheaper way is: pull request are deployed in uat environment and than after the merge, you can deploy in production.\n\n\nIf you can create temporary environment that are cleared after the merge yoy will reduce the confusion on bug projects&quot;, &quot;No OP, but does this mean you have a build pipeline that runs every time you push to trunk, and then a separate deploy pipeline that targets dev, qa, and eventually prod? otherwise I am not following how you&#39;d do this all in one repo with one github actions pipeline definition (new)&quot;, &#39;Semver.org\n\nThe third section is for the patch level. This is for stuff like hot fixes (non-breaking fix changes to documented &quot;public&quot; interfaces that do not add new features or deprecate existing ones).\n\nThere is a tool called &quot;semantic-release&quot; that can automate things like change log updates, git tagging, etc. it detects how to bump the version based on a prefix placed in your commit message subject line. (new)&#39;, &quot;How do you handle the approval step to apply to prod? I&#39;d like to implement a similar approach but this is the thing that&#39;s confusing me. (new)&quot;, &quot;I mean that&#39;s not true TBD. There&#39;s two types of TBD, let&#39;s call it TBD and TBD-lite.\n\nTBD is when you commit to main directly.\n\nTBD-lite is when you branch and merge. (new)&quot;, &#39;does your tag look different for dev/prod? or is it the same tag that gets promoted if anything? (new)&#39;, &#39;&gt;separate branch for each env \n\nWas that at any time a best practise to do so?\n\nThats perhaps the worst idea to use branches as environments. (new)&#39;, &#39;Gitflow has worked for many years where as trunk based is a more modern approach.\n\nI have had to shut down trunk based development especially with younger teams that are not practicing TDD and do not have adequate test automation.\n\nThe extra management across branches with gitflow forces conversations about what is the deployable work, do we need feature flags, basically how are we going to safely introduce changes. Once you have more quality controls in place, and awareness of the deployable unit of work then trunk based deployment can increase efficiency.&#39;, &#39;&gt; To solve this problem we use GitFlow.\n\nGitflow creates a horribly unreadable history, bad for reviews, bisections, rebasing, etc.\n\nInstead use topic branches and pull requests. And certainly rebase (retest) before merging into main. Never even consider do merge nodes with manually resolved conflicts - instead rebase and fix the committing commits individually.\n\nFor each approved release (that may go into production), create a separate maintenance branch. When fixing bugs, start with the oldest (still active) maintenance branch and then move the fix forward to never ones (rebase) and finally into mainline. (new)&#39;, &#39;I will be messaging you in 7 days on [**2024-01-28 15:42:31 UTC**](http://www.wolframalpha.com/input/?i=2024-01-28%2015:42:31%20UTC%20To%20Local%20Time) to remind you of [**this link**](https://www.reddit.com/r/devops/comments/19c3krr/in_trunk_based_development_if_using_github/kiwe0w3/?context=3)\n\n[**CLICK THIS LINK**](https://www.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=%5Bhttps%3A%2F%2Fwww.reddit.com%2Fr%2Fdevops%2Fcomments%2F19c3krr%2Fin_trunk_based_development_if_using_github%2Fkiwe0w3%2F%5D%0A%0ARemindMe%21%202024-01-28%2015%3A42%3A31%20UTC) to send a PM to also be reminded and to reduce spam.\n\n^(Parent commenter can ) [^(delete this message to hide from others.)](https://www.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete%20Comment&amp;message=Delete%21%2019c3krr)\n\n*****\n\n|[^(Info)](https://www.reddit.com/r/RemindMeBot/comments/e1bko7/remindmebot_info_v21/)|[^(Custom)](https://www.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=%5BLink%20or%20message%20inside%20square%20brackets%5D%0A%0ARemindMe%21%20Time%20period%20here)|[^(Your Reminders)](https://www.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List%20Of%20Reminders&amp;message=MyReminders%21)|[^(Feedback)](https://www.reddit.com/message/compose/?to=Watchful1&amp;subject=RemindMeBot%20Feedback)|\n|-|-|-|-| (new)&#39;, &#39;The deploy pipeline would be in one flow. You take one build and deploy that to dev. That same build can be used on qa (which has a separate deploy flow, but similar deploy flow as prod, staging, dev) but it’s still the same build number. If you find an error you just fix trunk and restart the deploy … dev, qa, staging, etc. (single build flow, multiple deploy flows (preferably with same process between them all) (new)&#39;, &#39;You build and deploy every push to trunk once you do it correctly and have an application architecture to support that. Most companies are not mature enough to do trunk based development&#39;, &#39;Yes. Potentially with the merge pipeline also deploying to qa/dev (as in triggering the reusable deploy workflow). Then you deploy on command (or things like deploy direct to prod if you have the test automation to do real CD) (new)&#39;, &#39;We use Azure DevOps Pipelines today. For the manual approval step, we use a Deployment Task that conditionally only runs for the preprod and prod environments. The deployment task doesn’t really do anything in our case, but we have it configured to require the approval from someone in the approvers group. \n\nIn the future, we’d like to remove the manual approvals all together, but we are still working on improving our automated testing for now. (new)&#39;, &quot;That&#39;s a good callout. The textbook definition of TBD is working directly off of trunk/main. TBD-lite seemed like an easier shift for our development teams, and has been working well so far. \n\nI&#39;ll add that we also set a standard that branches should not be older than 2 days, in an effort to try and reduce the size of changes and promote integrating back into trunk/main more frequently. We&#39;ve switched from using the term &#39;feature branches&#39; to &#39;topic branches&#39; instead to try and shift away from the mental model of leaving branches open for weeks (or longer). \n\nUsing these short lived topic branches also allows us to run our unit/component tests and code/security scanning tools when the PR is created. This allows us to identify any issues at this level before the code has been merged back into trunk/main, shortening the feedback loop and helping to keep the mainline healthy and always deployable. \n\nWe took a lot of our ideas and inspiration from [this Martin Fowler article](https://martinfowler.com/articles/branching-patterns.html#Trunk-basedDevelopment) on branching patterns (for anyone interested in going down the rabbit hole). (new)&quot;, &quot;Tagging policy is not enforced by us. Dev&#39;s themselves take care of their repo. Most of the. Repos have independent tagging for prod and dev. No plans to standardise it as of now. (new)&quot;, &#39;I look forward to your weekly gitflow re-org updates at every retrospective followed by a rebase. (new)&#39;, &quot;Sounds somewhat like GitLab Flow and imo it&#39;s a reasonable method to handle deploying infra/code using an IaC framework where dev/test/staging/prod env&#39;s are required to be in different AWS accounts for example. (new)&quot;, &quot;I&#39;m not anti trunk based. In my opinion it depends on your organisation. The OP is describing needing to not always deploy whatever has been built. So I was offering an alternative.&quot;, &#39;&gt; Gitflow has worked for many years \n\nWorked badly, since it messes up history. \n\n&gt; where as trunk based is a more modern approach.\n\nWhat exactly is &quot;trunk based&quot; ?&#39;, &#39;I have never encountered any of these problems. (new)&#39;, &#39;&gt;That same build can be used on qa (which has a separate deploy flow, but similar deploy flow as prod, staging, dev)\n\nwould this be like a workflow dispatch? or some action that runs once tag is created but behind a approval? (new)&#39;, &#39;FWIW we inherited a project that used TBD and we are now transitioning away from it.\n\nThe amount of shitty, spaghetti, useless, stale code that gets pushed with differing style from each person in the team into main made the codebase a fucking nightmare to work with.\n\nBring back feature branching, I hate this new TBD trend. (new)&#39;, &#39;Yup. Gitops on the merge. They are confusing gitflow with trunk based.&#39;, &#39;I was just trying to add some commentary about the pros and cons of these two strategies since I saw you were downvoted with no rationale. (new)&#39;, &#39;https://www.atlassian.com/continuous-delivery/continuous-integration/trunk-based-development#:~:text=Gitflow%2C%20which%20was%20popularized%20first,access%20to%20the%20main%20code.&#39;, &quot;Since I&#39;m working with histories (as central tool) on daily basis, I often encounter those problems. Note that history isn&#39;t just a technical artifact, it&#39;s also a method of documentation.\n\nAnd it&#39;s also vital for things like bisect, blame, ... (new)&quot;, &#39;You can run manual jobs to deploy to different environments. However I have a pretty good SDLC process I take to all places I work. Github actions:\xa0\xa0\n\n\nCI:\xa0\xa0\n\n\nPR:\xa0\xa0\n* Run code quality gates\xa0\xa0\n* Run unit tests\xa0\n\n\nMerge to master:\xa0\xa0\n* Build artifacts (could be binary, could be image, etc) (I sometimes disable this to save on build time)\xa0\xa0\n* Run security scans\xa0\xa0\n\n\n\xa0CD:\xa0\xa0\nCreate tag:\xa0\xa0\n* Build artifacts (could be binary, could be image, etc) (use tag from previous step)\xa0\xa0\n* Release candidate tag (deploy dev/qa/preview)\xa0\xa0\n* Normal semi version (deploy dev/qa/preview/prod)\xa0\n\n\nThis has been my bread and butter for well over a decade now. (new)&#39;, &#39;I’m not an expert on GitHub actions, so I can’t tell you for sure. But that is up to you and your team if you want approvals in front of deploys … (new)&#39;, &#39;Thanks appreciated. (new)&#39;, &quot;Ah, they&#39;re going back to old pre-git workflows (even merging dead code), giving that a new fancy name. Typical marketing buzz as we know it from those folks.\n\nCouldn&#39;t ever take them seriously. Looks like they still didn&#39;t grasp what rebase what invented for, and why history is more than just a technical artifact. (new)&quot;, &#39;Why aren’t you scanning on every commit? (new)&#39;, &#39;For non enterprise customers, GitHub actions doesn’t support gated jobs or human interaction in the middle of jobs. You can’t push a button to advance a job, you have to start a new job either based on a trigger or based on a button.\n\nSo, either you have a single job that pushes to dev, runs tests, pushes to stage, runs tests, pushes to prod all automatically, or you have a automatic push to a lower environment and then a button to promote (workflow_dispatch is the GitHub way of saying a manually triggered job)\n\n\nThe comment below says you can have gated builds, but only if you’re paying the high price for GitHub Enterprise.\n\nEnterprise customers can use GitHub’s deployment framework and set environments as requiring reviews, you can start a promotion job and it will wait for approval.   So a good option would be to have your build job trigger promotion jobs that are configured to wait for approval. (new)&#39;, &#39;Because it saves on time/money to just run before any merge to main, and fail otherwise. (new)&#39;, &#39;It absolutely does https://docs.github.com/en/actions/managing-workflow-runs/reviewing-deployments (new)&#39;, &#39;Apparently that’s only for GitHub enterprise subscribers, not us lowly professional/teams customers. (new)&#39;, &#39;Hey, this is great, I didn’t know about that feature.  Gonna look at putting it in place on some of my repos.  Thanks! (new)&#39;, &#39;You need enterprise for the manual approved approvement step. (new)&#39;, &quot;You&#39;re welcome. (new)&quot;, &#39;Ah, that’s why I didn’t think it was available.  Back to the drawing board. (new)&#39;]</td><td class="s7" dir="ltr">[&#39;Adopt CI/CD pipelines for automated integration and delivery&#39;, &#39;Automate code quality checks (linting, testing, analysis)&#39;, &#39;Automate test execution (unit, integration, e2e)&#39;, &#39;Automated build and tests always pass on the CI&#39;, &#39;Commit frequently (daily)&#39;, &#39;Containerization and orchestration tools used&#39;, &#39;Deploy frequently and provide fast feedback&#39;, &#39;Enable fast and continuous feedback (+)&#39;, &#39;Enforce discipline for stable builds and testing&#39;, &#39;Feature flag complexity and debt management required&#39;, &#39;Integrate CI/CD tools&#39;, &#39;Manual approval in staged releases&#39;, &#39;Needs reliable CI/CD and automation tooling (-)&#39;, &#39;Promote frequent and rapid integration (CI) (+)&#39;, &#39;Reduce merge conflicts (+)&#39;, &#39;Shortens automated feedback cycles by testing each trunk commit against the main codebase through CI/CD pipelines (+).&#39;, &#39;Simplifies the development workflow (+)&#39;, &#39;Support safe experimentation and rollback&#39;, &#39;Tooling includes quality and monitoring support&#39;, &#39;Trunk always ready for release&#39;, &#39;Use a single shared trunk&#39;, &#39;Use feature flags to safely integrate incomplete features&#39;, &#39;Use feature flags to decouple deployment from release&#39;, &#39;Use short-lived branches&#39;, &#39;Use tags for releases&#39;, &#39;Avoid big-bang merges&#39;, &#39;Use of topic branches as very short-lived branches (&lt;=2 days) to facilitate code review and automated checks before merging to trunk (new)&#39;, &#39;Automated promotion of the same build artifact through multiple environments (dev, QA, staging, prod) to ensure consistency and traceability (new)&#39;, &#39;Integration of infrastructure-as-code (IaC) updates as part of the deployment pipeline in trunk-based workflows (new)&#39;]</td></tr><tr style="height: 30px"><th id="958685326R30" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">31</div></th><td class="s8" dir="ltr"><span class="s3" style="background-color: #dce9cb; color: #2c481f; width: 147.0px; max-width: 147.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">git</span></td><td class="s9" dir="ltr">Question about commit history when merging from develop/master back into a feature branch</td><td class="s10" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/git/comments/xa18vf/question_about_commit_history_when_merging_from/">https://www.reddit.com/r/git/comments/xa18vf/question_about_commit_history_when_merging_from/</a></td><td class="s10" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/git/comments/xa18vf/question_about_commit_history_when_merging_from/">https://www.reddit.com/r/git/comments/xa18vf/question_about_commit_history_when_merging_from/</a></td><td class="s11" dir="ltr"><span class="s3" style="background-color: #d5deeb; color: #383a3c; width: 128.0px; max-width: 128.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">YANLIŞ</span></td><td class="s9" dir="ltr">[&#39;Question about commit history when merging from develop/master back into a feature branch (new)&#39;, &#39;I\&#39;ve looked for a question similar to mine in the subreddit, but didn\&#39;t find anything that was specific to my question.\n\n  My repo is a hybrid Git Flow, but the question applies to trunk-based and regular Git Flow also.\n\n  So, we\&#39;ve got a master branch and a staging branch, and feature branches that come off of master, get merged into staging for testing, then get merged to master when they pass QC.  As part of that, we merge from master back into the feature branch to make sure the feature branch has the latest and greatest code.\n\n  When we merge from master, doesn\&#39;t that bring along changed files and commit history that is irrelevant to the feature branch?  For instance:\n\n* On Monday, I branch off of master to a feature branch.\n* On Tuesday, another dev branches from master to a separate feature branch.  He\&#39;s working on something totally different than I am.\n* His work is quicker, so he gets his work tested in staging and merged to master on Wednesday.\n* On Thursday, I test on staging and everything is good, so I merge master into my feature branch.  It merges with no merge conflicts.  But now, the other dev\&#39;s changes are part of my commit history, and \\`git log --raw\\`  or \\`git reflog\\` list his files as well as mine.\n\n  (I can put together a commit graph of my question if that doesn\&#39;t make sense.)\n\n  Assume that there\&#39;s no merge conflicts, or any incompatibilities between his code and mine.  My concern is that, since the other dev\&#39;s commits and files are completely unrelated to mine, doesn\&#39;t that make my commit history &quot;dirty?&quot;  Or does it even matter?&#39;, &#39;Well, it\&#39;s not &quot;your&quot; history, but that of that feature branch. But yes, it does. You basically have the following options:\n\n- don\&#39;t merge master back, resolve possible conflicts in the final merge of feature into master. Keeps history clean, but some people don\&#39;t like an &quot;unclean&quot; merge which actively changes code.\n- merge master back like you said. Never do it myself, but popular in bigger orgs since githubs &quot;merge&quot; button can only deal with conflictfree merges.\n- rebase your feature branch onto master directly before merging. Keeps history clean, but alters it, so might mess up your staging branch (?). (new)&#39;, &#39;Ha, you’ve asked this in a rhetorical way that is difficult to answer!\n\nThere are a few good reasons you should never merge Main into your feature branch. Bringing in ‘unrelated’ changes is not one of them.\n\nWhen you have a feature branch ready to merge into Main, it must merge cleanly - into the real state of Main now - not how it was three days ago. To be sure of that you need every update to Main, but you must not merge them in. Instead you should regularly be rebasing your feature branch. (new)&#39;, &#39;Thanks to everyone for your feedback! It seems like rebasing is the better route to go, and will help mitigate or avoid the issues that back-merging causes. (new)&#39;, &#39;Your question doesn’t apply to trunk-based development. At least, any pull request style branches  you make away from trunk/main shouldn’t live long enough to be worried about for costly or repeated merges from trunk or main. Refer https://trunkbaseddevelopment.com/styles/&#39;, &#39;&gt; There are a few good reasons you should never merge Main into your feature branch. Bringing in ‘unrelated’ changes is not one of them.\n\n  Do you mind elaborating on what the other reasons might be? I’d like to be able to use them to argue for the rebase method with my team.\n\n&gt; Instead you should regularly be rebasing your feature branch.\n\n  Good to know, I had a feeling rebasing might be the answer but I don’t know enough about it yet to know for sure.\n\n  Thanks! (new)&#39;, &#39;Thanks for the diagram, that helps clear up some of my TBD questions.  Since we’re kind of a TBD/GitFlow hybrid, I hadn’t really considered that the branches in that methodology should be short lived enough that this wouldn’t be an issue. (new)&#39;, &#39;Every development style, no matter how shortlived, has potential for merge conflicts. The graphic you linked neatly hides it in the step &quot;bring checkout up-to-date with HEAD of trunk&quot;, but doesn\&#39;t specify _how_, and that is exactly OP\&#39;s problem.\n\nEdit: you might argue that rebase is implied, but back-merging master also does the same. (new)&#39;, &quot;You&#39;re welcome. Never heard of such a hybrid though. The TBD site talks of [https://trunkbaseddevelopment.com/alternative-branching-models/#gitflow-and-similar](https://trunkbaseddevelopment.com/alternative-branching-models/#gitflow-and-similar), but is firmly against it. (new)&quot;, &#39;Most often I’m pushing direct to truck/main stash-pull-stashpop solves most of my issues. It’s not that much different on a short-lived PR branch. (new)&#39;, &quot;I think our big differences between us and Git Flow are that we don&#39;t use release branches, and that hotfixes usually go through staging. We need main/staging for testing, but we iterate too quickly to deal with release branch.\n\n Edit: Clarified which method we&#39;re different from. (new)&quot;, &quot;Trunk-Based Development doesn&#39;t mandate release branches. The Continuous Delivery book (2010) says do-TBD many times, and CI/CD right into QA or UAT.  The binary that was deployed at that, is now eligible for a button-press deployment into prod (no branches involved).  Continuous Deployment talked about passing builds being deployed into prod.&quot;, &#39;I was unclear, I meant our differences between us and Git Flow. (new)&#39;]</td><td class="s12" dir="ltr">[&#39;Rebase before merge&#39;, &#39;Reduce merge conflicts&#39;, &#39;Support safe experimentation and rollback&#39;, &#39;Use short-lived branches&#39;, &#39;Keep trunk updated with release fixes&#39;, &#39;Avoid big-bang merges&#39;]</td></tr><tr style="height: 30px"><th id="958685326R31" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">32</div></th><td class="s2" dir="ltr"><span class="s3" style="background-color: #dce9cb; color: #2c481f; width: 147.0px; max-width: 147.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">git</span></td><td class="s4" dir="ltr">Question about Git branching strategy for continuous testing</td><td class="s5" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/git/comments/1gr3fo5/question_about_git_branching_strategy_for/">https://www.reddit.com/r/git/comments/1gr3fo5/question_about_git_branching_strategy_for/</a></td><td class="s5" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/git/comments/1gr3fo5/question_about_git_branching_strategy_for/">https://www.reddit.com/r/git/comments/1gr3fo5/question_about_git_branching_strategy_for/</a></td><td class="s6" dir="ltr"><span class="s3" style="background-color: #d5deeb; color: #383a3c; width: 128.0px; max-width: 128.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">YANLIŞ</span></td><td class="s4" dir="ltr">[&#39;Question about Git branching strategy for continuous testing (new)&#39;, &quot;Hello!\n\nI am trying to figure out a branching strategy for a project I am working on and I am a bit lost!  There are two environments, prod and test and the project is mostly just different scripts that target remote servers to do some tasks.   \n\n\nMy issue is that to even be able to properly test the scripts, a developer must push their changes to Git so it can be deployed to the remote server which has the correct network configuration for them to work. If they push and it does not work properly, they may need to commit more changes to the develop branch.\n\nOnce that script is fully tested and ready, it must be deployed to production. Multiple developers may be pushing to the develop branch to test their scripts, which means that the develop branch is never ready for release and there can&#39;t really be any code freeze either.\n\nDoes anyone have any ideas or tips on what an effective strategy for this could look like? I am looking into trunk-based development but I am not exactly sure if that will work in this case as the code on master could be broken or just for testing\n\nThanks!&quot;, &quot;It&#39;s a common mistake to treat Git branches as if they were deployment environments. Instead, Git branches are just branches: alternative versions of the code under development. You don&#39;t need a branch-per-environment.\n\nIf you have more than one person working on a project, you generally need more than one test environment: at least one per person. Each developer (and each tester) needs to be able to install and run the project on their own personal environment, whether it be their own workstation or some kind of server they control. This is in addition to any shared testing environment you may already have.\n\nWith this setup, you can avoid merging obviously bad or broken code into your develop branch, because testing can be done before merge. The develop branch can move forward with good, tested code, until it is finally ready for release to production. Of course, sometimes mistakes are made and bugs make it into the develop branch or even into production, but this should be rare and won&#39;t usually derail development. (new)&quot;, &#39;I can see a couple options. One is with all developers bombarding develop branch by merging their own working branch when ready to test (then doing the testing and editing and re-merging), and once a developer is ready to deploy to production, they merge their branch over to a production-candidate branch (this could utilize a permission gate). Great place for a code freeze if needed (no more pushing to production-candidate), some final checks and testing can happen here with all other candidates together, and then actually deploy to production from here. \n\nThe other thought is to use enable/disable flags in each script/feature. Enabled for testing/development purposes, but if a release to production needs to happen, anything not ready would be disabled, release happens, then developers can re-enable and  resume testing. (new)&#39;, &#39;It sounds like your problem has more to do with the fact that all of your developers share a single test environment than it does to do with any kind of branching strategy.\n\nIf you can collaborate with your team to design a better process, you will find that it becomes much easier to adopt a good branching strategy. (new)&#39;, &#39;Your fundamental problem is that you’re using Git for two conflicting purposes. Your develop branch is both an integration branch and the only way for a developer to test their work. So your develop branch turns into a mess as a result.\n\nCan each developer get their own environment? If so, do that.\n\nDo they have to share the same environment? Then give them the ability to deploy from any branch.\n\nOnce you have done one of the two things above, your developers work in a feature branch, test as they need to, and once the team is happy with the result, it gets merged to master. No more stepping on each others’ toes in Git. No need for a develop branch, it’s redundant. (new)&#39;, &#39;The answer is &quot;it depends&quot; on the number of developers you have, and rate of feature development.\n\n\\* Small teams can get away with nearly any kind of development, easily.  Cut your development branches, fix your features, then merge in.  Let the next guy deal with the integration either on the primary branch, or a merge to theirs for the integration fix, **then merge back**.  Every successful build on the primary branch just gets a label applied and you can deploy that to production.\n\n\\* Medium teams may want to keep integrations on the primary branch.  Every time your feature on the dev branches works fine, you grab final merge for the conflicts, then merge back to the main branch.  Treat that main branch as an integration and a fix-forward branch.  \n\n\\* Variation of the above for larger or more de-centralized teams is a sprint branch (Y24W46) and the release/tags here are merged to the primary branch when you\&#39;re ready.  That way you can deploy to production with your sprint branch and your primary branch reflects what is in production &quot;just in case&quot; you have a production bug to fix and deploy from again.\n\n\\* Larger feature development is the same as above, except you cut a new branch to fix the production bugs.  When you\&#39;re ready, you merge back to the main branch.  We did this kind of thing when we had 3000+ developers on a fairly monolithic stack.\n\nWord of advice, it\&#39;s not just a Git thing, but try to avoid cutting release/production/whatever branches over and over again.  You can get into some really ugly trees and make it harder to follow.  Just merge back to main/trunk periodically and slap a tag onto it. (new)&#39;, &#39;I recently read about that [here](http://toolongautomated.com/one-branch-to-rule-them-all-1). It mentions a design that uses trunk-based development with short-lived feature branches and deployments to multiple envs via containerization and configuration files.&#39;, &#39;I completely agree that current setup is far from ideal and that it is not really the purpose of Git to act like some sort of &quot;jump server&quot; to test like you would in your local environment. We are bit locked behind network restrictions to test locally, but I am realizing that this needs to be sorted out to have a proper development cycle. (new)&#39;, &#39;+1 for branch by abstraction (new)&#39;, &#39;This is an interesting approach, I will take a look and see what would be possible. Thank you for this! (new)&#39;, &#39;We kind of follow the same on DeployHQ, good approach (new)&#39;, &#39;I absolutely agree. If we could figure out a better development procedure, the complexity of this would resolve itself. There are unfortunately a few issues with network configuration that makes this a bit more difficult but I am sure it is possible. (new)&#39;, &#39;This is probably it. I\&#39;ve seen some projects that become utterly reliant on a very expensive setup that cannot be replicated. This is due to some combination of static configuration, non-portable code, excessive fragmentation across &quot;independent&quot; services and excessive use of external proprietary services. It can be quite painful and quite unnecessary. It also promotes bad development and change management practices because nothing can really be tested and reviewed anymore, people just try stuff until it works and keep stepping on each other\&#39;s toes all the time. (new)&#39;, &quot;Yep, this is it. I will need to check with IT if we are able to set up a proper environment for each developer to test. I am slowly realizing that doing this solely through Git isn&#39;t the best approach. Thanks for your input! (new)&quot;, &#39;&gt; We are bit locked behind network restrictions to test locally, but I am realizing that this needs to be sorted out to have a proper development cycle.\n\nYou don\&#39;t have to do your testing locally. You just shouldn\&#39;t have all of your developers sharing a single branch for their untested code. Instead, each developer, or even better, each feature, should have its own test environment. That doesn\&#39;t need to be &quot;local&quot;. \n\nOn our team we have a CI setup that lets developers easily deploy to a &quot;[review app](https://docs.gitlab.com/ee/ci/review_apps/)&quot; from a merge request, each of which has a distinct feature branch. The review app has a unique URL based on the feature branch name. So developers can do their testing in the review app, and it\&#39;s only after the code gets merged into main that it gets deployed to real production environment. (new)&#39;]</td><td class="s7" dir="ltr">[&#39;Use a single shared trunk&#39;, &#39;Use short-lived branches&#39;, &#39;Use branch by abstraction&#39;, &#39;Use feature flags to safely integrate incomplete features&#39;, &#39;Use feature flags to decouple deployment from release&#39;, &#39;Promote frequent and rapid integration (CI) (+)&#39;, &#39;Reduce merge conflicts (+)&#39;, &#39;Simplifies the development workflow (+)&#39;, &#39;Accelerate release cycles (+)&#39;, &#39;Enable fast and continuous feedback (+)&#39;, &#39;Deploy frequently and provide fast feedback&#39;, &#39;Trunk always ready for release&#39;, &#39;Use tags for releases&#39;, &#39;Avoid big-bang merges&#39;, &#39;Provision per-developer or per-feature test environments to support independent testing before trunk integration in TBD (new)&#39;]</td></tr><tr style="height: 30px"><th id="958685326R32" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">33</div></th><td class="s8" dir="ltr"><span class="s3" style="background-color: #ddebff; color: #2a3243; width: 147.0px; max-width: 147.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">devops</span></td><td class="s9" dir="ltr">Release cycles, ci/cd and branching strategies</td><td class="s10" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/devops/comments/1lv6brv/release_cycles_cicd_and_branching_strategies/">https://www.reddit.com/r/devops/comments/1lv6brv/release_cycles_cicd_and_branching_strategies/</a></td><td class="s10" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/devops/comments/1lv6brv/release_cycles_cicd_and_branching_strategies/">https://www.reddit.com/r/devops/comments/1lv6brv/release_cycles_cicd_and_branching_strategies/</a></td><td class="s11" dir="ltr"><span class="s3" style="background-color: #d5deeb; color: #383a3c; width: 128.0px; max-width: 128.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">YANLIŞ</span></td><td class="s9" dir="ltr">[&#39;Release cycles, ci/cd and branching strategies (new)&#39;, &quot;For all mid sized companies out there with monolithic and legacy code, how do you release?\n\nI work at a company where the release cycle is daily releases with a confusing branching strategy(a combination of trunk based and gitflow strategies). A release will often have hot fixes and ready to deploy features. The release process has been tedious lately\n\nFor now, we mainly 2 main branches (apart from feature branches and bug fixes). Code changes are first merged to dev after unit Tests run and qa tests if necessary, then we deploy code changes to an environment daily and run e2es and a pr is created to the release branch. If the pr is reviewed and all is well with the tests and the code exceptions, we merge the pr and deploy to staging where we run e2es again and then deploy to prod.\n\nIs there a way to improve this process? I&#39;m curious about the release cycle of big companies&quot;]</td><td class="s12" dir="ltr">[&#39;Automate test execution (unit, integration, e2e)&#39;, &#39;Manual approval in staged releases&#39;, &#39;Use temporary release branches&#39;, &#39;Deploy frequently and provide fast feedback&#39;, &#39;Adopt CI/CD pipelines for automated integration and delivery&#39;]</td></tr><tr style="height: 30px"><th id="958685326R33" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">34</div></th><td class="s2" dir="ltr"><span class="s3" style="background-color: #c0e1ff; color: #3f4170; width: 147.0px; max-width: 147.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">programming</span></td><td class="s4" dir="ltr">Google&#39;s directed acyclic graph build system for monorepos with special sparse-checkout features versus classic depth-first recursive types</td><td class="s5" dir="ltr"><a target="_blank" href="https://www.youtube.com/watch?v=L67ri_xe2oQ">https://www.youtube.com/watch?v=L67ri_xe2oQ</a></td><td class="s5" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/programming/comments/1kovucv/googles_directed_acyclic_graph_build_system_for/">https://www.reddit.com/r/programming/comments/1kovucv/googles_directed_acyclic_graph_build_system_for/</a></td><td class="s6" dir="ltr"><span class="s3" style="background-color: #d5deeb; color: #383a3c; width: 128.0px; max-width: 128.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">YANLIŞ</span></td><td class="s4" dir="ltr">[&quot;Google&#39;s directed acyclic graph build system for monorepos with special sparse-checkout features versus classic depth-first recursive types (new)&quot;, &#39;I\&#39;ve uploaded a talk to YouTube: [Google\&#39;s directed acyclic graph build system for monorepos with special sparse-checkout features versus classic depth-first recursive types](https://youtube.com/watch?v=L67ri_xe2oQ)\n\nThis talk compares both, with source in a cloneable repo that shows the structure. I also discuss how Google shrink their 9+ million source files in their trunk to something that is more manageable for a dev or QE who\&#39;s wanting to achieve a specific coding task/story.\n\nYou\&#39;d watch this if you don\&#39;t understand how Bazel works &quot;under the hood&quot;. Or if you don\&#39;t understand how a ginormous VCS-relying company would actually use a single repo for all applications, apps, services, libraries they make themselves. Definately an education piece, rather than something you\&#39;d run it to work with for a &quot;stop everything&quot; declaration.\n\nCaveats:  \n\n1. Less than 100 companies would do this Google thing, I guess.\n2. Your company is **JUST FINE** with a multi-repo setup.\n3. There are multiple sub types of trunk-based development: https://trunkbaseddevelopment.com/styles/&#39;]</td><td class="s7" dir="ltr">[&#39;Use a single shared trunk&#39;, &#39;Use sparse-checkout and directed acyclic graph build systems to manage large monorepos in Trunk-Based Development (new)&#39;]</td></tr><tr style="height: 30px"><th id="958685326R34" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">35</div></th><td class="s8" dir="ltr"><span class="s3" style="background-color: #ddebff; color: #2a3243; width: 147.0px; max-width: 147.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">devops</span></td><td class="s9" dir="ltr">I don&#39;t know how to design a simple release pipeline. Help... please?</td><td class="s10" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/devops/comments/1b6j23d/i_dont_know_how_to_design_a_simple_release/">https://www.reddit.com/r/devops/comments/1b6j23d/i_dont_know_how_to_design_a_simple_release/</a></td><td class="s10" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/devops/comments/1b6j23d/i_dont_know_how_to_design_a_simple_release/">https://www.reddit.com/r/devops/comments/1b6j23d/i_dont_know_how_to_design_a_simple_release/</a></td><td class="s11" dir="ltr"><span class="s3" style="background-color: #d5deeb; color: #383a3c; width: 128.0px; max-width: 128.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">YANLIŞ</span></td><td class="s9" dir="ltr">[&quot;I don&#39;t know how to design a simple release pipeline. Help... please? (new)&quot;, &quot;I am a software developer and this is the first doing DevOps.\n\nThis should be simple, and I know I am overthinking, but here it goes:\n\nWe&#39;re doing trunk-based development, with short-lived feature branches.\n\nWe&#39;re using GitHub Actions.\n\nWe&#39;re using Amazon ECR as an image registry.\n\nWe use the [release-please](https://github.com/googleapis/release-please) Github action to autogenerate the next release version and change-log (one of the reasons why we follow the conventional commits specification).\n\nI have workflow `pull.yml` which listens to commits in any feature branch and performs these jobs:\n\n1. Linting\n2. Static analysis\n3. Find unused dependencies/dead-code\n4. Commit linting\n5. Build-test-push:\n   1. Check-out repository\n   2. Build binaries\n   3. Dockerize binaries\n   4. Runs functional tests with these Docker images (we use Testcontainers)\n   5. ???\n\nAnd then I have another workflow, `release.yml`, that listens to commits in the master branch. This workflow currently:\n\n1. Runs `release-please` action to create a release PR (if there is none), updates changelogs\n2. (if release PR is merged) ??? (we should promote the Docker images to production here, but how??)\n\nThis is where I feel stuck.\n\nThere is no way for the `release.yml` to, when a release PR is merged, to have access to the Docker image we built in the feature pull request. We need to somehow access it so we can tag/promote it for release.\n\nWe could just build it twice, but it feels wrong.\n\nWe could push the image to ECR in `pull.yml`, but what would be its name, and tag?\n\nAnd then, how would we pull the correct image in `release.yml`? Like, what identifier do I use?\n\nI could make `pull.yml` upload the tested Docker image as an artifact. But Github makes downloading artifacts from different workflows hard and convoluted.\n\nI guess I could run the `release-please` action in `pull.yml`, only to get the next version, and then push to ECR as ${app_name}v1.0.0-rc\n\nBut what if I have multiple feature branches? Wouldn&#39;t they override this Docker image in ECR, overriding the same image with a tag ${app_name}v1.0.0-rc?\n\nI&#39;m just confused; I know this should be simple. Thoughts?&quot;, &#39;I recommend pushing the artifact remotely and have the promotion pipeline to pull from it to tag and release. The promotion pipeline can be one that is manual through workflow dispatch or automated. This way, you can retag once you pull and push it again to your remote registry.\n\nIf you have more questions feel free to DM me (new)&#39;, &#39;how do feature branch commits get into master?  \nOn every merge into master you must test again, build a new image. Reusing a feature branch built image is not recommended at this stage because it could be stale (master moving ahead and feature still pointing to older master)  \nTag the master image with commit-hash (merge commit is fine) and pushed to ECR  \nwhen you are releasing, the process should pull the images directly with the commit-hash (no rebuilding is allowed here) and if possible re-tag them as latest or v1.x (new)&#39;, &#39;This is how the workflows look like now, by the way.\n\n\\`pull.yml\\`: [https://gist.github.com/rotivleal/c3b9547bf2b65cebce63a3f6ae50a2ad](https://gist.github.com/rotivleal/c3b9547bf2b65cebce63a3f6ae50a2ad)\n\n\\`release.yml\\`: https://gist.github.com/rotivleal/26ebcb3abc16a1fbb9c523f325d7a98f (new)&#39;, &#39;And how would I tag these images? The problem is that the release.yml workflow needs to somehow to promote the correct, latest release candidate.\n\nSay I have two feature branches, and they each push one Docker image to ECR, with a tag of {app\\_name}+{commit\\_sha}\n\nAnd then these feature branches get merged to main.\n\nThen, the release PR gets merged to main.\n\nHow would, then, \\`release.yml\\` select the correct image to promote? (new)&#39;, &#39;I have also attached both of the workflows, if it makes the problem any clearer (new)&#39;, &#39;When you merge the PR , the merge to main knows which commit is being merged. You can take advantage of that to fetch the correct tag. (new)&#39;, &#39;OK. Now, I am sending the image to ECR with the tag as the commit SHA of commit inside the feature branch PR.\n\nThen, in the release.yml, when a release PR is merged, I grab the commit SHA of the previous commit:\n\n```\n      - name: Get short commit SHA of previous commit \n        id: before-commit-metadata\n        run: |\n          echo &quot;short_sha=$(git rev-parse --short HEAD^1)&quot; &gt;&gt; $GITHUB_OUTPUT\n```\n\nBut this is not going to work:\n\n1. if we do a squash + merge, then the commit SHA will not be the same. I\&#39;ve disabled squash merges for now.\n2. the commit SHA in the PR is different from the one in the `master` branch after the rebase + merge happens.\n\n:/ (new)&#39;]</td><td class="s12" dir="ltr">[&#39;Trunk always ready for release&#39;, &#39;Use short-lived branches&#39;, &#39;Automate code quality checks (linting, testing, analysis)&#39;, &#39;Automate test execution (unit, integration, e2e)&#39;, &#39;Adopt CI/CD pipelines for automated integration and delivery&#39;, &#39;Containerization and orchestration tools used&#39;, &#39;Use tags for releases&#39;, &#39;Rely on modern Git-based collaboration platforms&#39;, &#39;Promote frequent and rapid integration (CI) (+)&#39;, &#39;Shortens automated feedback cycles by testing each trunk commit against the main codebase through CI/CD pipelines (+).&#39;, &#39;Simplifies the development workflow (+)&#39;, &#39;Automate artifact promotion and tagging in CI/CD pipelines to support trunk-based workflows (new)&#39;]</td></tr><tr style="height: 30px"><th id="958685326R35" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">36</div></th><td class="s2" dir="ltr"><span class="s3" style="background-color: #ddebff; color: #2a3243; width: 147.0px; max-width: 147.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">devops</span></td><td class="s4" dir="ltr">Our team has been forced into using git cherry-pick in order to promote changes to other environments, and it&#39;s not going well, any alternatives?</td><td class="s5" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/devops/comments/1bjgh93/our_team_has_been_forced_into_using_git/">https://www.reddit.com/r/devops/comments/1bjgh93/our_team_has_been_forced_into_using_git/</a></td><td class="s5" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/devops/comments/1bjgh93/our_team_has_been_forced_into_using_git/">https://www.reddit.com/r/devops/comments/1bjgh93/our_team_has_been_forced_into_using_git/</a></td><td class="s6" dir="ltr"><span class="s3" style="background-color: #d5deeb; color: #383a3c; width: 128.0px; max-width: 128.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">YANLIŞ</span></td><td class="s4" dir="ltr">[&quot;Our team has been forced into using git cherry-pick in order to promote changes to other environments, and it&#39;s not going well, any alternatives? (new)&quot;, &quot;So unfortunately due to a decision made by some arbitrary architect, our team has been struggling with our current git strategy.\n\nWe have three branches for three environments, dev, qa, and main. Originally we were doing git flow and we were just doing simple merges, and things were running somewhat smoothly. Then a bunch of third party devs got involved in the project, and code started getting promoted that shouldn&#39;t have.\n\nSo my bosses freaked out and turned to an architect outside the company who suggested our only solution is cherry picking (something in my 20 years of experience I have never heard being used in this way).\n\nI suggested that we try to pivot to a trunk based solution with feature flags using CI/CD, and leadership apparently won&#39;t go for it, the architect won&#39;t back it up either but I think it&#39;s because they. don&#39;t have any familiarity with it and is acting like they do.\n\nSo I have been tasked to find an alternative that doesn&#39;t involve merging and most likely rebase (a ridiculous limitation). So has anyone have any ideas on how this might be able to be achieved without things getting even more convoluted than they are already?\n\nThanks in advance\n\n&amp;#x200B;\n\nEdit: Thanks for the responses! I feel like I&#39;ve been gaslit for the last year, which has led me to question myself even though I knew the problem did not lay with me,, but seeing these responses reminds me there&#39;s still good people in this industry. Thanks&quot;, &#39;- First option would be protected branches. Ban direct pushes and only enable changes via merge requests.\n\n- Another good option would be feature branches. \n\n- Third option.. environment specific release tags. I tried this recently and it worked for me. (new)&#39;, &quot;Ah, nothing like bosses freaking out and inviting clueless people to make things worse without ever addressing the root problem. \n\nYour merge based system was the right way to do this. \n\nThe correct solution to the original problem is to stop letting third party devs promote code if they aren&#39;t adhering to standards. \n\nOne of the biggest problems in our industry is how we refuse to address people problems and instead throw janky technical bandaids at them.\n\nWe don&#39;t allow cherry picking because the code will exist in multiple commits with different hashes when branches are merged. (new)&quot;, &#39;go trunk based. remove env tracking branches.  use feature branches, release branches and main. pr merge required feature-&gt; release and feature-&gt; main. create new release branch programmatically from ci/cd as needed for all repos in upcoming releases. devs then have to pr merge their main -&gt; upcoming release..and any other fixes from feature branches as testing progresses get merged -&gt; main and -&gt; release..and that release branch is all you deploy to qa,staging,prod etc. ..\n\n&amp;#x200B;\n\nfeature flags--which are ci/cd/programatically/git controlled/enabled with each deploy, would be best.  lots of other ways to handle longer running development though.\n\none way:\n\ninstead of feature flags, you could pre-create future longer running release branches..and test upcoming features there..but then probably will need more than one dev,qa env..ie. dev100, dev102 etc. and need to rebase those on main often. gets sticky in a number of otherways as well to manage this.&#39;, &quot;I would say dont run long lived branches for each environment, or you are at risk of having code drift between the branches. We used to do a lot of cherry picking from a dev branch to our release branch and it was impossible to do at scale. It help cause a massive project to fall months behind schedule and a chaotic build a release process. We did what you&#39;re recommending and moved to trunk based and using tags for code cuts and it&#39;s way better now.&quot;, &#39;Trunk-based development is the way to go.  One long-lived branch, and many short-lived feature branches.  Any changes that go to main should be ready to go to prod, no exceptions.  Feature flag if necessary, or just implement the part that calls new code last; you can still test new code in a feature branch.  Deploy to prod multiple times a day.  Main is always in a good state, bad changes are identified immediately before they can rot in the code base.  Bad code has nowhere to hide, accountability is maximized&#39;, &#39;Are we speaking source code for applications or infrastructure code?\n\nAs for applications, I strongly suggest releasing released packaged artifacts. Then you deploy that to whatever env you want. Each env you know what version is deployed. Anything that is env specific is considered configuration and is not in the git repo with the source code.\n\nFor infrastructure and configuration I have no working solution. Some config is similar on the envs and is &quot;promoted&quot; from dev to stage and so on. Other elements are totally independent and changes happen to each env independently. (new)&#39;, &quot;It&#39;s a political problem, not a technical one. If I were you I&#39;d slowly start looking for another job - nobody wants to work for an incompetent boss who insists on braindead workflows.\n\nThe obvious solution is indeed a protected trunk, feature branches for development, proper CI/CD, mandatory reviews for merges, and the whole shebang. Good luck trying to convince your bosses, though. (new)&quot;, &#39;How do you test code with this stategy... (new)&#39;, &quot;If you&#39;re going that route, Use Gitlens plugin in vscode to cherry pick the commits. It gives a GUI which is much easier to visualise. (new)&quot;, &#39;[deleted] (new)&#39;, &#39;You had the right idea with trunk, and preventing rogue devs from breaking your layout is ultimately what CI/CD is for. But you can’t play tennis without legs, if they’re not letting you go with that and you don’t think they can be convinced then your options are minimal.\n\nFeature branches would be a potential solution but while that will bring some clarity, it’ll also cause an increase in sprawl and the pressure will be on to aggressively cull branches as they age off, which will translate into more risk and work for your devs. It won’t scale.\n\nI would agree with others in this thread that ultimately, this is not a technical problem, it’s political. Your bosses are idiots. The ‘architect’ they’ve brought in is an idiot. There’s a critical mass of idiots here and no job is worth doing when your entire leadership are morons. I’d be looking to move. (new)&#39;, &quot;Lol well I came here to suggest trunk based, but I guess that&#39;s out.&quot;, &#39;Having env based branches, or even just production branch, is a terrible idea. I experienced that once, it was a bad decision made back then. \n\nThe less branches you need to track, the better. \nTrunk based is great, if feasible. \nThe other option I would consider is release branches, where every N weeks a new release is made from master, and feature-branches are merged to it, this branch is rolled through testing, fixes, and eventually release.&#39;, &quot;We have almost the exact same problem right now, and I was tasked with the solution. Was going to go with cherry picks as I thought it seemed perfect. What&#39;s the problems with it? (new)&quot;, &#39;* use topic branches, that are frequently rebased to master\n* only tested stuff goes into master (rebase before merge, thus only fast-forward merges)\n* release points tagged on master\n* for each release make a maintenance branch\n* do fixes on maintenance branch and then rebase to master before merging there (topic branch like above).\n* no separate prod branch - just use tags. (new)&#39;, &#39;Armchair udemy &quot;architect&quot; no doubt.\n\nYou need to sit down, devise a strategy that works, and sell it properly to whoever can make that decision. Part of the sale would be to detail exactly the drawbacks of the current &quot;solution&quot; and how your proposal addresses them and improves the process. (new)&#39;, &quot;I&#39;m not sure what kind of code you have in your repositories and whether or not you have control over your environments. And how long it should take to build a version, test it and roll it out to the environment.\n\nIf you&#39;re talking about a webservices, the simplest and often easiest thing is to have the code in one directory, the config for every environment in another. CI/CD is building the main branch and can roll out to dev, qa and prod.\n\nIf you need more time between creating a version and being ready for prod rollout, then cut a release branch from master and tag the versions which roll out to the qa environment. Bugfixes need to be done on this branch and then merged back into the main branch. You can develop new features on feature branches you branch of from the main branch while qa is testing. (new)&quot;, &#39;I second your trunk based approach with feature flags because of reasons. Put the env specific config with the infrastructure where it belongs, I say. It’s nice to have bit-identical binaries across all envs.&#39;, &#39;Potentially a place for tags - I don\&#39;t do it this way, but I could imagine having some branch pinned to dev for say whatever a normal release is - stuff goes in there and is automatically deployed to dev.\n\nStaging deploys the head of main - when your dev release is good to go, merge to main, smoke test on staging.\n\nAnd when you\&#39;re ready to go on prod, you make a tag on main of that commit - prod deploys the latest prod tag - ie, not head which would be deemed unstable.\n\nI sorta never saw the sense of pinning stuff to specific environments - I guess other than main to prod - I\&#39;m mostly doing chatops where devs can deploy any branch to any testing environment they like. And the systems scales down to a single vm, so devs each have their own &quot;staging&quot; environment to deploy whatever they want to. (new)&#39;, &#39;&quot;So I have been tasked to find an alternative that doesn\&#39;t involve merging and most likely rebase&quot; do they understand how git works lol? Force merge requests and limit approvers. This seems like a simple solve.... (new)&#39;, &#39;An alternative strategy could be feature branch deployments, where you deploy all branches to its own environment and have QA approve and then release each branch individually. There is some setup work, but it work quite well especially for frontend. (new)&#39;, &#39;If there’s a little resistance to best practices, that’s normal. Maybe even good, since it forces you to be able to explain things. \n\nSo, if this is a one-off: settle for applying strict branch protection policies for now. Then turn your full attention to your automated test suite until you can get &gt;80% confidence that passing tests = safe release. Push your team to focus on making tests a first-class part of the development process - not an afterthought. Put tests around as many business-critical functions as possible, and encourage your product team to use concrete, testable acceptance criteria in your ticket system. Then once your test suite is robust and your leadership isn’t in a reactive mode of thinking, revisit CI/CD. Should take about one, maybe two years. \n\nIf this is not a one-off and your leadership habitually makes uninformed decisions and won’t hear reason, don’t bother with any of that stuff. It would only take time away that you could be using to find a better job. (new)&#39;, &#39;My team does the same thing. We Always have the development head that receives feature commits, the upcoming release, which receives bug fix commits as it goes through QA and occasionally features as it goes through user acceptance testing, and the current release, which generally only receives bug fix commits. This is, in fact, one of the strategies highlighted by trunk based development:\xa0 https://trunkbaseddevelopment.com/branch-for-release/ Where it struggles is with a lack of discipline in git practices. It requires you to develop with small, meaningful, atomic commits that “just do one thing”. A lack of adherence to git practices often stems from a feedback process: if your code reviews take a long time, developers will learn to put more code into them so that they spend less time blocked waiting for review. This will make reviews take longer, and eventually it’ll make reviewers tend to just give up and say, “well, the changes *work*, so I guess there’s nothing egregious enough I’m gonna make them rewrite a thousand lines of code.” It requires a willingness to reject a pull request that’s too big, which will cost development velocity in the short term if the motivating factors behind large PRs go unaddressed. It’s the sort of thing that’s likely to go badly if you don’t fully drink the koolaid.\n\nI find that strong automated testing and tools that support a “stacked diff” workflow help to keep commits truly focused and atomic.&#39;, &quot;We did was we had 3 bare repositories all repositories were mirrored. Yes that&#39;s nine branches each repo 1 for US, Twain and India teams. Finally there was a primary repo that two devops controlled. Yes we had to merge up to the master then we would merge back into each repo.\n\nThere were merge conflicts but the primary repo was controlled and isolated from each region. With that level of control we were able to prevent the main code base from being reverted or even old code leaking back into code base.\n\nYes we had to rebase the  other repositories and had to let the region that messed up re download repository.\n\nThis was difficult but in the end the code discrepancies were very minimal into the main code base. (new)&quot;, &#39;Cherry pick?! 🤣 I actually lol’d (new)&#39;, &#39;Diverging branches for each environment is the wrong way to use git. Trunk-based development with only one main branch is the only sensible branching strategy in my experience.&#39;, &#39;There is definitely more than one way to do it.\n\n&amp;#x200B;\n\nperhaps all involved should read [https://trunkbaseddevelopment.com/](https://trunkbaseddevelopment.com/) and have some meaningful conversations.  \n\n&amp;#x200B;\n\nI quite enjoy git cherry picks with trunk-based development because you\&#39;re -still- working off the trunk just at different touch points.\n\n&amp;#x200B;\n\nReally at the proverbial &quot;end of the day&quot; you\&#39;re manipulating git history.  It is a good muscle to build.&#39;, &#39;I see a disaster coming! (new)&#39;, &#39;2 and 3 are the solution, \n\nI would also suggest release management versus development as two separate teams.\n\nOnce you have a RC cut from release tags, (if you have lots of repos) you just need to make sure everyone follows the ##.##.## structure the release team takes over the deployment and the engineers go off and work on the next release. (new)&#39;, &#39;words right out of my mouth.  except we\&#39;re  used to saying &quot;Pull requests&quot; these days instead of merge. we also require 2 approvers for the PR to complete. (new)&#39;, &#39;Also if they really want to control what gets deployed, just cut a version tag, and then you can roll out that version to each environment. (new)&#39;, &quot;When you say environment release tags, do you mean promoted environments like dev, stage, prod? Or multi-tenancy environments?\n\nWe&#39;ve been doing well with MRs going to the dev environment, main goes to stage, then tags go to prod. If we ever need to do multi-tenancy, we&#39;d consider tags for each tenant environment. (new)&quot;, &quot;&gt;The correct solution to the original problem is to stop letting third party devs promote code if they aren&#39;t adhering to standards.\n\n\\^\\^ that.\n\nUnless your code base is idiot-level trivial, this is always going to cause problems and having some dickhead come in and push for cherry picking as a solution should have gotten the CTO bollocked. This is how code goes missing. (new)&quot;, &quot;I wish you were on my team at work, I&#39;ve been sounding the alarm about them not adhering to the standards, but it has fallen on deaf ears so far. (new)&quot;, &#39;&gt;One of the biggest problems in our industry is how we refuse to address people problems and instead throw janky technical bandaids at them.\n\nTestify! (new)&#39;, &#39;Came here to reply much the same as this. Upvoted! (new)&#39;, &#39;Can you point me to some tools/articles related to these automated feature flags? I never understood how you would automate this (new)&#39;, &quot;I think you hit the nail in the head that the root of the problem is having long lived branches for each env. If that&#39;s a requirement maybe the cherry-pick approach makes sense.\n\nBut yeah, in my experience the simplest approach is trunk based with a single main branch. Then your qa branch is always built from the latest commit in main and your prod env is built from some manual action after validation (like pushing a tag or running a protected job on the pipeline or something). I prefer having the prod env always built on the latest main commit but this can be a compromise. The dev env(s) can be built from whatever branch not yet merged into main.&quot;, &quot;This exactly. I&#39;ve worked on systems with long-lived env branches, and we had to extensively use cherry-pick to promote changes because of code drift. You basically lose the ability to merge normally and it&#39;s a dead end road you can&#39;t get off of. I would never recommend it and really almost any other strategy is better. (new)&quot;, &#39;&gt;We used to do a lot of cherry picking from a dev branch to our release branch and it was impossible to do at scale. It help cause a massive project to fall months behind schedule and a chaotic build a release process.\n\nSo our project is already entering this territory, and we got word that yet another 3rd party needs to make changes to our environment that will absolutely break it and kill our velocity. (new)&#39;, &#39;This is the only answer. Any other way just becomes unmanageable. Whatever is in master/main should be what is in production. (new)&#39;, &#39;That sounds optimal. To be honest, having such model (master always green and master is prod) is multiple times tougher for larger companies (200+). \nOnce you have multiple components that has dependencies, i think it breaks this model. For example, you have 4+ diff repos, with 30-40 different services, developed by different teams. What do you do? (new)&#39;, &#39;Yeah the cherry picking change is just another symptom of larger process issues. They need to peel this onion back a few more layers to find the real root cause. Hiring a 3rd party architect sounds like the right call, but I think they picked out of the bargain bin if their solution is cherry picking. (new)&#39;, &quot;&gt;The obvious solution is indeed a protected trunk, feature branches for development, proper CI/CD, mandatory reviews for merges, and the whole shebang. \n\nThat would take time though, it&#39;s much better to shove my changes directly into the release branch via cherry pick. Much faster delivery of value. /s\n\nOn a serious note, you&#39;re right. It&#39;s a political issue, not a process one. (new)&quot;, &#39;Thank you, the political situation is ridiculously heavy, I am amazed we get anything done at this point. I have one eye on the door already. (new)&#39;, &quot;If they can&#39;t figure this out then you can be sure their testing strategy is, or is about to be, in the toilet as well. (new)&quot;, &quot;Oh my bosses love throwing around the word automate, but when you actually ask to implement it, they just tell you to work with the current very manual process for now, we have so many great things happening, but they&#39;re always next month lol. (new)&quot;, &#39;Yeah I was like um these are pretty good practices to utilize. (new)&#39;, &quot;I think it could work if you have a team of devs who actually follow the dev standards put in place, but from what I&#39;ve read it doesn&#39;t scale, and sometimes dependencies don&#39;t make it to the higher environments. I recently had an issue where a fix for the bug I was working on was already done by another developer, but they hadn&#39;t promoted it to the other environments, and it have been so long, the commits were spread across multiple branches for features that were unrelated. Also from what I&#39;ve read here, it doesn&#39;t scale well. (new)&quot;, &quot;Sounds great to me, although recently I told my boss I had two possible solutions the this issue, and he basically told me that we have to work with the current process until June (Which I guarantee will be September, if we&#39;re lucky). He didn&#39;t even bother asking what the solutions were or to send him an email on it. So I am very discouraged, sounds like they want a Titanic situation. (new)&quot;, &quot;&gt;Once you have a RC cut from release tags, (if you have lots of repos) you just need to make sure everyone follows the ##.##.## structure the release team takes over the deployment and the engineers go off and work on the next release.\n\nI have suggested this but they won&#39;t listen until I create diagrams to explain it, which I am doing. This company loves a good powerpoint, apparently they need lots of visuals. lol (new)&quot;, &quot;This is alright -- but I think your suggestion takes more resources than is required for what basically equates to people being afraid of conflict.\n\nThey just need protected branches and those with the know-how to better gatekeep the code via reviews. I&#39;m more in tune with this other comment: [https://www.reddit.com/r/devops/comments/1bjgh93/comment/kvr4rfl/?utm\\_source=share&amp;utm\\_medium=web2x&amp;context=3](https://www.reddit.com/r/devops/comments/1bjgh93/comment/kvr4rfl/?utm_source=share&amp;utm_medium=web2x&amp;context=3)\n\nI think your suggestion is great, but it&#39;s probably more of a problem at scale when a more hands-on approach is too slow. And it sounds like OP&#39;s company isn&#39;t that large. (new)&quot;, &#39;In this case I meant dev,stage, prd (new)&#39;, &#39;Code reviews, right? I worked in a FAANG operation and watched in dumbfounded amazement as the art director abolished CR’s then unleashed a bunch of maverick contingents on the code base. Welcome to incompetence 101. (new)&#39;, &#39;The root issue is having separate branches for each environment. If you don’t have release artifacts that are being promoted through each environment, that’s your second problem. Templatize the deployment process and pass configurations for the target environment at runtime. \n\nIf a 3rd party came in and looked at the deployment process and their only solution is cherry picking, they’re not worth their salt. (new)&#39;, &#39;My company is larger than those numbers and follows this approach for a vast majority of their repositories.  I’d say discipline is more important than size (new)&#39;, &#39;Integration testing (new)&#39;, &#39;Google and Facebook use trunk based development. It scales better than any other branching method&#39;, &quot;&gt; This company loves a good powerpoint, apparently they need lots of visuals.\n\nI&#39;m on your side here - I think that release tags are your best option, but this is a bit of a crappy attitude. \n\nIt&#39;s your *job* to communicate the reasons behind your proposed decisions. If you can&#39;t articulate why X is better over Y, then *of course* your bosses are going to go with the solution that **they understand the benefits** of best, not necessarily **what&#39;s best**.\n\nCompanies are built on egos, and it&#39;s on us to ensure that we can communicate and demonstrate best practices, as well as have the technical chops to implement them. (new)&quot;, &quot;Lol yeah it&#39;s likely herding 150 cats, the release team before me was using one massive OneNote. I&#39;m like a technomage to them. Look at the magic release notes we didn&#39;t have to write. (new)&quot;, &quot;I&#39;d like to hear some more tales of this please (new)&quot;, &#39;Yep. Get rid of the env branches and abstract the environmental info out into the deployment process. (new)&#39;, &quot;How do you correlate between different teams in different repos? What&#39;s the rules, if you mind sharing? (new)&quot;, &#39;How do you correlate between different teams on different repos, without using some sort of release branch or tag? Any experience with something that works, you can elaborate on? (new)&#39;, &quot;It&#39;s ultimately up to the team which process they choose, but there is official guidance from technical leads to use trunk-based development and that&#39;s what most teams choose to follow.&quot;, &#39;What do you mean correlate (new)&#39;]</td><td class="s7" dir="ltr">[&#39;Use feature flags to safely integrate incomplete features&#39;, &#39;Use feature flags to decouple deployment from release&#39;, &#39;Use feature flags to Support progressive delivery (A/B testing, dark launches)&#39;, &#39;Use a single shared trunk&#39;, &#39;Use short-lived branches&#39;, &#39;Mandatory code review policy&#39;, &#39;Adopt CI/CD pipelines for automated integration and delivery&#39;, &#39;Promote frequent and rapid integration (CI) (+)&#39;, &#39;Trunk always ready for release&#39;, &#39;Use tags for releases&#39;, &#39;Use temporary release branches&#39;, &#39;Reduce merge conflicts (+)&#39;, &#39;Make small, frequent commits&#39;, &#39;Enforce discipline for stable builds and testing&#39;, &#39;Accelerate release cycles (+)&#39;, &#39;Deploy frequently and provide fast feedback&#39;, &#39;Encourage team collaboration and communication (+)&#39;, &#39;Maintain traceability and code history&#39;, &#39;Simplifies the development workflow (+)&#39;, &#39;Promote shared or collective code ownership&#39;, &#39;Initial migration effort was significant. (-)&#39;, &#39;Cultural or organizational resistance is common (-)&#39;, &#39;Requires strong discipline and team coordination (-)&#39;, &#39;Requires robust testing and test infrastructure (-)&#39;, &#39;Integrate CI/CD tools&#39;, &#39;Manual approval in staged releases&#39;, &#39;Keep trunk updated with release fixes&#39;, &#39;Avoid big-bang merges&#39;, &#39;Fail-forward deployment strategy&#39;, &#39;Use protected branches to ban direct pushes and enforce merge requests (new)&#39;, &#39;Use release branches created programmatically from CI/CD for upcoming releases (new)&#39;, &#39;Use environment-specific release tags to promote code through environments (new)&#39;, &#39;Pre-create future longer running release branches for testing longer features (new)&#39;, &#39;Use stacked diff workflow and strong automated testing to keep commits atomic and focused (new)&#39;, &#39;Separate environment-specific configuration from code and manage it outside the main repo (new)&#39;, &#39;Cut release candidate (RC) from release tags and have release team manage deployments (new)&#39;, &#39;Use feature branch deployments with dedicated environments for QA approval (new)&#39;, &#39;Require multiple approvers for pull requests to improve code quality (new)&#39;, &#39;Abstract environment-specific info out into deployment process to avoid env branches (new)&#39;, &#39;Use GitLens or similar tools to assist with cherry-picking when necessary (new)&#39;, &#39;Promote discipline in git practices to avoid large pull requests and improve reviews (new)&#39;, &#39;Use diagrams and visual aids to communicate branching and release strategies to leadership (new)&#39;, &#39;Adopt a policy of only merging tested and approved code into main/trunk (new)&#39;, &#39;Reject pull requests that are too large to maintain code quality (new)&#39;, &#39;Use tags to mark stable releases for production deployment (new)&#39;, &#39;Separate development and release teams for better release management (new)&#39;, &#39;Use stacked diffs and atomic commits to improve code review and integration (new)&#39;, &#39;Promote code ownership and accountability through trunk-based development practices (new)&#39;]</td></tr><tr style="height: 30px"><th id="958685326R36" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">37</div></th><td class="s8" dir="ltr"><span class="s3" style="background-color: #dbeeef; color: #133819; width: 147.0px; max-width: 147.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">softwaredevelopment</span></td><td class="s9" dir="ltr">Alternatives to Upsource for &quot;review-per-commit&quot; workflow?</td><td class="s10" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/softwaredevelopment/comments/z7o30g/alternatives_to_upsource_for_reviewpercommit/">https://www.reddit.com/r/softwaredevelopment/comments/z7o30g/alternatives_to_upsource_for_reviewpercommit/</a></td><td class="s10" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/softwaredevelopment/comments/z7o30g/alternatives_to_upsource_for_reviewpercommit/">https://www.reddit.com/r/softwaredevelopment/comments/z7o30g/alternatives_to_upsource_for_reviewpercommit/</a></td><td class="s11" dir="ltr"><span class="s3" style="background-color: #ebe6db; color: #4c535e; width: 128.0px; max-width: 128.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">DOĞRU</span></td><td class="s9" dir="ltr">[&#39;Alternatives to Upsource for &quot;review-per-commit&quot; workflow? (new)&#39;, &#39;We use Upsource for code review, but it is reaching end of life. \n\nWe use it as a &quot;non-blocking code review&quot;-tool, where reviews are created for all commits.   \nWe use Trunk Based Development (ie. without branches) - so we need a tool that:   \n\n\nDiscovers new commits and creates reviews.   \nAssign team members   \nSupports raising concerns or commenting with questions or feedback.   \nhas an overview people can use to perform their review work (i.e. open reviews, concerns to handle, and other) \n\nMost tools are based on Pull requests - that is NOT what we want as we work only on master/main(/trunk)&#39;, &#39;Gerrit ? (new)&#39;, &quot;The problem with finding an alternative could be due to the fact, that you process is not standard.\n\nWe do a code review that looks a bit like a Pair Programming, but only for committing part. So you call a reviewer BEFORE THE COMMIT and go file by file in the order the author likes. He describes the reviewer what is happening in the code and why. If a problem is found, they fix it right away (unless it&#39;s time consuming, then they hang the call and resume whenever the fix is ready).\n\nFull Pair Programming is probably better, but it never managed to stay for long with us.\n\nThat way all code that goes into master is already reviewed and git history is clean. And knowledge sharing and bonding excel in this approach. (new)&quot;, &#39;How do you like trunk based development? I’ve never actually seen a team use that before&#39;, &#39;I’m curious why you only want to work on main? Pull requests are quite common and while not an answer to your question, I’m curious what benefit you get from not doing pull requests, besides your stated preference of working directly on main? (new)&#39;, &#39;[deleted] (new)&#39;, &#39;Does it allow non-blocking reviews? \nI.e. are people able to commit and push their code without being blocked by review? And then a review is automatically created for a team member? \n\nThe things i read is like it is blocking ? (new)&#39;, &#39;What we do work very well for us. And does not require waiting or interrupting. \nTrunk based development is best practice. So is reviewing code. Blocking workflows are not best practise. \nSo it seems weird there is a lack of tooling for it...&#39;, &#39;Love it. Would never go back. It is much more fluent and simple.  \n\nSo much i ended up a while back writing this: \n https://link.medium.com/0A1uFfCznvb (new)&#39;, &#39;Highly recommend it. Never been more productive than using TBD. It does require either small teams with a good average experience level (you can have inexperienced members, but not too many at the same time), or if you have large teams some very experienced architects/Senior developers enforcing the workflow.\n\nAnd be sure to follow all the best practices for TBD - feature flags are not optional for example, but critical to avoid unfinished code getting out and to be able to do quick recovery. (new)&#39;, &#39;Pull requests are common, but they should be used only in specific cases, like open source development or totally distributed development. \n\nWhen &quot;old books&quot; say about code review - and when code review became a best practice - it was held **before** the commit was made. (new)&#39;, &quot;Doing actual trunk based development is best practice - if you haven&#39;t already check out state of DevOps or accelerate. \n\nYou could counter that: you can integrate daily when using branches, and i would say that branches are not contributing anything but an unnecessary cumbersome workflow in that case. \n\nMore details here :  https://link.medium.com/0A1uFfCznvb&quot;, &#39;Way too complicated and unnecessary Byzantium workflow. \nIf you have tried just working on main, with non blocking reviews using feature toggles and frequent deploys and releases, you wouldnt consider such a solution. It is way to much motion and pseudowork.... (new)&#39;, &quot;This is close to how you would do TBD with a large/distributed team, so it&#39;s not a bad workflow. It&#39;s a lot of unnecessary work for smaller teams though that will reduce their performance. (new)&quot;, &quot;I don&#39;t fully understand what you wantf.\n\nThe best thing for you would be to download it and try it by yourself.\n\nIirc it&#39;s quite easu to have a basic setup up and running. (new)&quot;, &quot;If reviews after commit were a best practice, you would have tons of tools that cover this :) \n\n&gt; And does not require waiting or interrupting.\n\nYeah, that one is tricky. It would be superb to have all of the features you wrote, but the problem is: development is a team work. Otherwise you just have a bunch of guys typing code and a manager that prays that the sum of it will be a working software.\n\nPS. I didn&#39;t downvote you.\n\nPS. Please tell me, how often does it happen, that the commit must be reverted after the code review in your approach? In my experience, about 30% of code reviews end up with an agreement that the commit won&#39;t happen now, because some major fixes need to be done. In your workflow, these commits would make it to the trunk and be reverted or fixed with later commits? If the later, it means that git log contains garbage commits that nobody should see. (new)&quot;, &quot;To expand on this (because I completely agree), you **need** pull requests in Open Source projects due to their nature of untrusted commits, and you need pull requests with distributed development because you have to do asynchronous workflows and cannot maintain a tight cohesion and agreement on best coding practices and solution spaces once teams grow beyond a certain size. (Also time difference).\n\nBut pull requests are a band-aid to the problems of untrusted commits and lack of cohesion. It&#39;s the best possible band-aid, but it&#39;s still a band-aid, and using it when it&#39;s not required harms you instead of helping you.\n\nOver time PRs have come to be considered synonymous with code reviews, but this is not the case. You can code review in a number of ways (pair programming, pre-commit, PRs, or post-commit). It&#39;s just that Git (and GitHub) have popularized the Git and GitHub flows so much that a lot of developers don&#39;t realize there are other ways to do things. (new)&quot;, &#39;I see absolutely no problem in the review (also) happening after the code is committed? If it is behind feature toggles or is not used yet, there is no problem in Work In Progress being part of the system.... (new)&#39;, &#39;[deleted] (new)&#39;, &#39;[deleted] (new)&#39;, &#39;I realised it was another thread in which i had left this link:  https://link.medium.com/0A1uFfCznvb (new)&#39;, &quot;I could go into my guesses as to why people don&#39;t do structures review after commit/push. Partially because of the same reasons as people do feature branches, despite research showing Trunk based development is the way to go. Partially it is the idea that code gets better by gatekeeping than continues and frictionless integration of work - and continued improvements and awareness of work. \nBut that is not what I intended to discuss here. You can read my exhaustive views on this by the link in other comments. Regarding your teamwork comment, i don&#39;t see the relevance. It is as much teamwork that everyone reviews everybody else&#39;s code - but does so without blocking each other. . \n\nWe don&#39;t revert. We use feature toggles and incremental backward compatible changes. And do small batches of change. \nJust because the code is not perfect it can easily be part of the deployable - maybe not released as it is not toggled on in production environment. But toggled on in test so we get feedback and.wuality assurance through use and the like.  \n\nThat something evolves through the git log and changes overtime (instead of showing up perfectly done) i do not see as a problem. Quite the contrary. I see early feedback on commits made in the beginning of work as crucial to ensure right direction, catch misunderstanding and much more. \n\nBut again. \n\nMy question was about a tool supporting the quite simple way of work the works for the place i work. \n\nDo you know any such tool?&quot;, &#39;Reviews after commit are the common practice. Pair Programming for each commit is a lot of wasted time, unless all your devs are junior. (new)&#39;, &#39;Did you use review as &quot;code guards/gates&quot;? \n\nOr an after the fact review of other people\&#39;s work? \n\nThe aim by doing &quot;non-blocking reviews&quot; / Post-CI reviews, is related to this: \n\n&gt;&quot;There is a cost to multi-tasking, so maybe someone in the dev team who is between work items at that moment should focus on the review before they start new work. With a continuous review ethos, it is critical that code reviews are not allowed to back up.&quot;\n\nWe see the CI/CD-To-Test as more important and the gains bigger, than code-guard reviews etc. \n\nIt is possible to enforce reviews, but not block code from getting into test. While also requiring code to be reviewed, before getting into prod (we don\&#39;t do that though) \n\nThe problem with &quot;shortlived feature branches&quot; is that, in my experience, a lot of the supposedly &quot;shortlived feature branches&quot; are in actuality short lived. And if we want multiple reviewers, illness suddenly becomes blocking. And Meetings. And flow. \n\nWe also do mob sessions occasionally but giving everyone a simple chance to review code (by having reviews assigned to them continually) increases  chance that code is reviewed - and in addition of catching different stuff/bugs/naming/misunderstandings it also raises awareness about everybody\&#39;s work. It also does not pin people against each other where everyone guard each other.   \n\n\nWe REALLY want to have the ability to get code continually into test (CI/CD for test) BUT still get code reviewed by several (if not all) on the team. \n\nAny suggestions to tools? (new)&#39;, &#39;sounds reasonable. (new)&#39;, &quot;&gt; Do you know any such tool?\n\nNo, I don&#39;t. \n\nI like the idea of Trunk Base Development and wanted to try it in a next project, but with Code Reviews before commit (instead of Commit Review). \n\nTBD is done be many companies, to there must be some establish process already (I thought it&#39;s Code Review, not Commit Review and not Pull Request Review). (new)&quot;, &#39;[deleted] (new)&#39;, &#39;The &quot;official&quot; answer to code reviews with TBD in small teams is pair programming, but the value I see in &quot;code review&quot; after commit is not just to - well - review code. It also serves to engage the entire team in what is being done, and the direction everyone is working. It reinforces the standup and other team communication and helps to spread good code practice in the (small) team. (new)&#39;, &quot;I don&#39;t think you quite understand what the process that works for us. \nWe are looking for a tool that can help us with a process that works well for us, not a tool that forces a process on us that does not work for us. \n\nWe don&#39;t want branches. \nWe do want reviews. \nWe don&#39;t want gates or other control mechanisms to getting code into master/main. \n\nWe do want overview for each individual of the reviews they have not done. \nWe do want a way of raising concerns and similar. \n\nWe are actually looking into whether some of this or all can be done by use of GitHub actions combined with issues and use of project. \n\nBut we have not made the PoC / spike for this yet. (new)&quot;]</td><td class="s12" dir="ltr">[&#39;Use a single shared trunk&#39;, &#39;Commit frequently (daily)&#39;, &#39;Make small, frequent commits&#39;, &#39;Use feature flags to safely integrate incomplete features&#39;, &#39;Use feature flags to decouple deployment from release&#39;, &#39;Enable fast and continuous feedback (+)&#39;, &#39;Promote frequent and rapid integration (CI) (+)&#39;, &#39;Simplifies the development workflow (+)&#39;, &#39;Encourage team collaboration and communication (+)&#39;, &#39;Use pair programming or mob programming for collaboration&#39;, &#39;Small team&#39;, &#39;Mandatory code review policy&#39;, &#39;Reduce merge conflicts (+)&#39;, &#39;Non-blocking, post-commit code review workflow integrated with trunk-based development (new)&#39;, &#39;Continuous assignment and tracking of code reviews without blocking trunk commits (new)&#39;]</td></tr><tr style="height: 30px"><th id="958685326R37" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">38</div></th><td class="s2" dir="ltr"><span class="s3" style="background-color: #dce9cb; color: #2c481f; width: 147.0px; max-width: 147.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">git</span></td><td class="s4" dir="ltr">Git Strategy for multiple environments</td><td class="s5" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/git/comments/1fpernc/git_strategy_for_multiple_environments/">https://www.reddit.com/r/git/comments/1fpernc/git_strategy_for_multiple_environments/</a></td><td class="s5" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/git/comments/1fpernc/git_strategy_for_multiple_environments/">https://www.reddit.com/r/git/comments/1fpernc/git_strategy_for_multiple_environments/</a></td><td class="s6" dir="ltr"><span class="s3" style="background-color: #ebe6db; color: #4c535e; width: 128.0px; max-width: 128.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">DOĞRU</span></td><td class="s4" dir="ltr">[&#39;Git Strategy for multiple environments (new)&#39;, &#39;Hi.\n\nI know this is a classic topic over here, but I need to expose my use case and reality to try to have some new ideas.\n\nI\&#39;m working in a data project, to simplify, I have one repository with python code, json configurations (to support python code) and airflow dags definition. We have 4 environments: sandbox, development, test and production.\n\n* Sandbox is the most lower environment, where developers can do whatever they need.\n* Development is where we have the possibility to use some external dependencies and also where QA element do their tests.\n* Test is where the client does their end to end tests before it gets to production (like UATs).\n* Production is production.\n\nSome details:\n\n* Not everything that\&#39;s developed will go in the next production deployment wave, the criteria is what the client decides, let\&#39;s just keep this as a fact, even though it can be right or wrong.\n* A feature can be developed and QA tested, but stopped in Test for client testing and will not go to production. It can also be fully tested and ready to production but decided not to deploy.\n* We have then a scenario where we can have features A, B and C in which: A is fully tested and will be deployed (passed all envs, except prod before deployment), B is also fully tested but will not be deployed (passed all envs also, except prod) and C that was not tested by QA or was tested with some findings needed to be fixed, not at time to go to Test and be deployed. All this in one sprint period. So here, only A will be deployed to production, B got stucked in Test and A will go back to development.\n\nNow regarding git strategy, so far we just stated some project specifics about environments and work flow.\n\nWe started by having:\n\n* main\n* feat/...\n* release/...\n* Deploy to environments using different tags from main and release branch\n* Regular merges from feature to main after QA finish tests.\n\nWhat was the main problem of this:\n\n* As we cannot be sure if a feature that is finished and QA tested can go to Test and/or Production environments our deployments started by creating a release branch from main and doing a pure exercise of checking each file to check if it can go or not, to a point where we had to delete code on shared developments. This because main was with more things than it needed to be deployed. Then, when we had our release branch ready, we would deploy it to production.\n* This is a nightmare for many reasons and also breaks the all concept of the QA testing (when there\&#39;s no automatic testing) because we ended up creating a potential complete different package without any further testing.\n\nWhat was the idea to be able to have independent Test and Production environments and guarantee that we put only what each env needs?\n\n* Create branches to map environments (yes I know we fall into a trap, but please let me explain :) )\n* Created dev branch to single point to have all developments merged to avoid developers overwriting one another.\n* Created tst branch to be possible to merge only features that must go into Test.\n* Keep release branch created from main and then merge all features that will be deployed to production.\n* Ensure that feature branches don\&#39;t have anything other than main code and its own developments code, so that we are sure that we will put into main (prod) only what was developed on that feature.\n* Use main as single point to production development by merging release branch into it (previously merged with all features).\n* For test, merge features as needed.\n* Central point: have feature branches completely clean from other developments so that we are always ready to deploy only the feature developments.\n\nAfter some runs of this process, it worked in what regards having main (production) with a 100% safe deployment as we indeed only deployed what was needed without any manual adjustment or manual removal of things.\n\nBut as expected, it becomes harder and harder to manage all environments, approve a lot of PRs that sometimes are just copy of what was already approved in other envs and also conflicts and duplicate commits (saying that something is changed that in reality it is not) started to happen, and we are in a point where I\&#39;m feeling that we need some other strategy, even if it is a middle ground between what we had and what we have.\n\n**Main point:** the project requirements are what they are. We will not be able to have a single main branch with all features, because we will not deploy them when ready.\n\nWhat strategies can you think to this use case? I thought about tagging in a different way, not that experience doing that, read about trunk based strategy, but also never read about it, feature flags... What can we do to have less possible complexity, less possible mapping branch to env, but also make sure that we only deploy to Test and Production the developments from each feature without anything else?\n\nAppreciate help and please if you answering have expertise on the matter, just give practical examples... I know that it is easier to say like &quot;follow trunk based&quot;, or &quot;just do it from main&quot;...\n\nMany many thanks.&#39;, &#39;Git is not a replacement for a CD tool. Using branches for environments has been generally deemed &quot;wrong&quot; (sometimes I flirt with the idea as well, but then decide not to). If you must, then I think branches for environments should be linear history (eg prod is a direct descendant of test, which is a direct descendant of main). The main branch should be a sequence of merge commits. \n\nI have a feeling you already know the answer to it: the more general accepted workflow is Trunk Based Development, and from what you describe about some features not being released it sounds like you\&#39;d also benefit of having a Feature Toggles mechanism. You can rollout your own or use a provider like Launch Darkly if you can justify the expense.\n\nFeature Toggles does come with its own complexities, though. A bunch of if statements in the code and you\&#39;ll need to make sure your automated tests are run in each state of the toggle, and if there are multiple toggles you\&#39;ll need to test various combinations.\n\nThe primary premise is to avoid long-lived branches so Feature Toggles helps with that.\n\nAlso, you\&#39;re not using Squash-and-Merge, right? That\&#39;ll cause issues down the line with similar changes needing to be re-approved. This is the easiest self-inflicted issue to get rid of but requires contributors to know how to clean their git history before merging.\n\nDo you have mostly manual tests? That\&#39;s also an area of improvement. Upskill QA to become QE so they can start doing more test automation.&#39;, &#39;Remindme! 1 day (new)&#39;, &#39;[deleted] (new)&#39;, &#39;Git tags &amp; tool that deploy tagged version to specifici environment. Maybe even guard some envs to only deploy tags that follow specific pattern. Then e.g. QA could tag with their own tag tested release, and only those can be deployed to PROD.\n\n  \nIf you have better tooling, consider pipelines that have manual steps, then each step is representing those envs, and each step after need manuall initiation, with convention that only QA activate step after QA, devs after sandbox. etc.\n\n  \nBbbbuuuuttttt how do devs decide (or QA, or ...) what is tested/activated/deployed where?\n\n  \nFeature flags. Those can be as simple as hardcoded list in a file under git (in which case git tag correspond to preset of FFs). That is plenty enough for some setups. Or use FF service (in which case its a bit more complicated, because now you need to manage who can manage what, but still plenty doable).\n\n\n\nFeature branches are vehicle for code review in this scheme, and are rarely deployed independently. Review done? Merge with Feature deactivated with Feature Flag. Ready for testing? (could be after days, due to related work, or test data setup!) Enable FF on test box.\n\n  \n(This can further be optimized into Trunk Based Development, but that is big investment, and can be spread over time)&#39;, &#39;No squash. But too many merges now and conflicts start hapening very often… we fixed one side, but I know that this branch-&gt;env will become unmanageable (new)&#39;, &#39;I will be messaging you in 1 day on [**2024-09-26 21:14:57 UTC**](http://www.wolframalpha.com/input/?i=2024-09-26%2021:14:57%20UTC%20To%20Local%20Time) to remind you of [**this link**](https://www.reddit.com/r/git/comments/1fpernc/git_strategy_for_multiple_environments/lox589m/?context=3)\n\n[**CLICK THIS LINK**](https://www.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=%5Bhttps%3A%2F%2Fwww.reddit.com%2Fr%2Fgit%2Fcomments%2F1fpernc%2Fgit_strategy_for_multiple_environments%2Flox589m%2F%5D%0A%0ARemindMe%21%202024-09-26%2021%3A14%3A57%20UTC) to send a PM to also be reminded and to reduce spam.\n\n^(Parent commenter can ) [^(delete this message to hide from others.)](https://www.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete%20Comment&amp;message=Delete%21%201fpernc)\n\n*****\n\n|[^(Info)](https://www.reddit.com/r/RemindMeBot/comments/e1bko7/remindmebot_info_v21/)|[^(Custom)](https://www.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=%5BLink%20or%20message%20inside%20square%20brackets%5D%0A%0ARemindMe%21%20Time%20period%20here)|[^(Your Reminders)](https://www.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List%20Of%20Reminders&amp;message=MyReminders%21)|[^(Feedback)](https://www.reddit.com/message/compose/?to=Watchful1&amp;subject=RemindMeBot%20Feedback)|\n|-|-|-|-| (new)&#39;, &quot;Actually we are doing that. We have N integration branches and we only merge to main our feature branches, not the integration ones.\n\n  \nThis is working, but we need to put in pratice that idea of reseting the integration branches as when they live long enough, conflicts start to happen.\n\nIt creates overhead, but I don&#39;t see a clear idea in what we will do differently, I found the feature flags to be difficult to apply, probably due to my lack of knowlegde... (new)&quot;, &#39;Oh, and bugfix? Two solutions:  \n \\* create branch from Tag for current prod (yes, you can \\`git checkout\\` tag, commit and create new branch from that\n\n \\* rollback, fix on main branch, deploy that instead (watch out for FFs if you have them hardcoded in git repo) (new)&#39;, &quot;What about having throw-away integration branches? I believe that&#39;s how git develops git - https://git-scm.com/docs/gitworkflows#_description\n\nThey have `next` and `seen` where seen is the lowest level kinda like a dev environment that eventually graduates to next (eg the test environment) and eventually it gets released into master (or main).\n\nThe cool thing about this is that there&#39;s no need to re-approve stuff. Pull requests are still targeted to main, but they just get merged to these integration branches on the side. And once a higher branch like main is fast-forwarded to next then all these pull requests get automatically merged.\n\nThe downside is that it might require some manual git operations that are not available on services like GitHub or GitLab. They do have the concept of merge-queues or merge-trains, but I think that&#39;s a different use case.\n\nNote that next and seen can be force-pushed, but master gets fast-forwarded to next, and maint gets fast-forwarded to master. (new)&quot;, &quot;Some amount of conflicts is unavoidable, but you can usually minimize the impact by merging often and avoiding long-lived branches (like public feature branches possibly worked on by multiple people). If people are not comfortable doing basic conflict resolution, you might need to address that first. Other times it&#39;s due to how code is developed (excessive churn, insufficient planning/review) or organized, particularly since you mentioned envs and I&#39;ve seen projects where devs keep hitting the repo with changes simply because they cannot test their changes locally or at least isolated somehow, without merging. Perhaps you need people to talk more across teams and some people to take up maintainership at some scale.\n\nSome variation on trunk-based development should be enough in most cases, from a few people up to large open source projects with thousands of contributors. It&#39;s usually some other process-related thing that&#39;s causing issues.&quot;, &quot;Yes, basic git resolution is something that is not well seen. It is like we are doing things wrong.\n\nAlso, the way we are currently trying to do, we have feature branches that will be ready to deploy and will be merged throughout all branches (dev, tst, release and main) at each respective time. Then we also have some restrictions on pushing directly to branches, what causes too many problems when needings to merge from main to lower env branches and then people don&#39;t understand that we must do regular merges with main to avoid conflicts, so on so on so on. Myself included, I don&#39;t have a huge knowledge on this, but at least try to look for ideas and answers.\n\nThe trunk based development, if I understood it correctly, even if we use feature branches and main only will not work by itself as we need to control what gets to main based on client feedback and their priorities. Also the feature flags, and what I read, probably because I don&#39;t have experience on them, it seems like a very complex case for my use case, as I will put flags and flags for each feature to make possible not to deploy them, and I will for sure get a final code full of conditions that will also be unmanageable. Or not, I don&#39;t know feature flags implementation :)\n\nWill keep looking for ideas and test what&#39;s better for us. I don&#39;t belive in 100% bullet proof solutions and neither that your solution can fit my use case, every situation is different, but there are some common ground errors and pratices that I want at least to know I&#39;m doing.&quot;, &#39;&gt;to make possible not to deploy them, and I will for sure get a final code full of conditions that will also be unmanageable.\n\nNot like that. Some features may require refactoring common code, that\&#39;ll usually get in no matter what. You\&#39;re generally supposed to disable standalone features or at least stuff you can isolate a bit using these feature flags, not make everything into spaghetti code or avoid *all* other changes from making it to production. For example, you could have a registration mechanism to handle widgets shown on pages, so you can simply add a conditional or otherwise remove a widget that\&#39;s not yet ready.\n\nClient feedback should generally concern visible changes or otherwise meaningful requirements. Parallel development histories &quot;just because&quot; is going to cost them a lot more for very little gain. Even in the best case, some changes require other changes and that takes time, you can\&#39;t simply pick up code that\&#39;s been left two months to rot while everything else changed, nor you can avoid making changes to related stuff simply because it\&#39;s been labeled as an extra feature. (new)&#39;]</td><td class="s7" dir="ltr">[&#39;Feature flag complexity and debt management required&#39;, &#39;Use feature flags to safely integrate incomplete features&#39;, &#39;Use feature flags to decouple deployment from release&#39;, &#39;Promote frequent and rapid integration (CI) (+)&#39;, &#39;Reduce merge conflicts (+)&#39;, &#39;Avoid big-bang merges&#39;, &#39;Use a single shared trunk&#39;, &#39;Use short-lived branches&#39;, &#39;Cultural or organizational resistance is common (-)&#39;, &#39;Requires robust testing and test infrastructure (-)&#39;, &#39;Requires strong discipline and team coordination (-)&#39;, &#39;Manual approval in staged releases&#39;, &#39;Use tags for releases&#39;, &#39;Use throw-away integration branches for intermediate environment-specific testing before merging to trunk (new)&#39;]</td></tr><tr style="height: 30px"><th id="958685326R38" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">39</div></th><td class="s8" dir="ltr"><span class="s3" style="background-color: #dce9cb; color: #2c481f; width: 147.0px; max-width: 147.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">git</span></td><td class="s9" dir="ltr">Is it bad practice to push a feature branch to remote?</td><td class="s10" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/git/comments/uln76l/is_it_bad_practice_to_push_a_feature_branch_to/">https://www.reddit.com/r/git/comments/uln76l/is_it_bad_practice_to_push_a_feature_branch_to/</a></td><td class="s10" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/git/comments/uln76l/is_it_bad_practice_to_push_a_feature_branch_to/">https://www.reddit.com/r/git/comments/uln76l/is_it_bad_practice_to_push_a_feature_branch_to/</a></td><td class="s11" dir="ltr"><span class="s3" style="background-color: #ebe6db; color: #4c535e; width: 128.0px; max-width: 128.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">DOĞRU</span></td><td class="s9" dir="ltr">[&#39;Is it bad practice to push a feature branch to remote? (new)&#39;, &quot;My CTO explained to me today that while working on a feature branch, I should keep it on my local machine and not create a remote upstream branch. (He said that backup can be done with other tools, and code review can be done locally.)\n\nHis rationale for this is that you want to keep the main branch as clean as possible, in case you need to revert an earlier commit. If you merge a feature branch in that is intertangled with code after the bad commit, undoing the commit becomes messy, and you might need to cherry-pick. However, if you develop locally and then merge to main and push upstream, if the earlier commit needs to be undone it is simpler to fix. Therefore, modern best practice is to only have one branch on the remote, and developers keep branches local (unless multiple developers are collaborating on one feature).\n\nThis doesn&#39;t make sense to me, since it seems that merging branch `feature` into main and then pushing upstream to `origin/main` is exactly the same as merging `origin/feature` into `origin/main` and then deleting the branch. Can someone explain to me which approach is right?\n\nEDIT: [this post](https://barro.github.io/2016/02/a-succesful-git-branching-model-considered-harmful/#all-development-happens-on-the-master-branch) seems to advocate a similar idea.\n\n--\nThanks everyone for sharing your knowledge! 🙏 Gonna go read up on `--no-ff`, github flow and trunk-based development.&quot;, &#39;There seem to be two questions that are mingled together.\n\n1. Push a feature branch to a remote, yes or no? \n\nYes. You might want to create a fork and push it to the remote of the fork. But this is my current workflow. Pushing it to a remote allows me to pick it up on another computer or share it with coworkers.\n\n2. Merging main/master in your current feature branch.\n\nThis is a somewhat opinionated topic. There are people who advocate just merging it into your feature branch because that is what you did. It is what history purists want to see, because they value chronological order above anything else. IMHO they are wrong. Nobody cares that you merged the master branch three times during your development cycle.\n\nThe other view point is to rebase it, which is what I do and what your CTO advocates. It is not a chronological history but it does offer a cleaner history. Your merges of master are not seen because your commits were replayed on top of the master branch. The commit graph is easier on the eyes and more useful. I am a big advocate of this. (new)&#39;, &quot;I&#39;ve worked with the CTO just like that. I wonder if that&#39;s the same guy you are talking about.\n\nLet&#39;s just say some people would rather come up with a bullshit excuse-explanation rather than acknowledge they have no idea what they are doing.\n\n&gt; He said that backup can be done with other tools\n\nBut is it done though? I kinda doubt that.\n\n&gt; code review can be done locally\n\nSo, how would you review someone&#39;s branch before it is merged? Send a parcel with a usb drive?\n\n&gt; His rationale for this is that you want to keep the main branch as clean as possible\n\nGit is a tool to make development more convenient, not the other way around. You shouldn&#39;t sacrifice your workflow to make a beautiful repo.\n\n&gt; This doesn&#39;t make sense to me, since it seems that merging branch feature into main and then pushing upstream to origin/main is exactly the same as merging origin/feature into origin/main and then deleting the branch.\n\nYou are right here.\n\nThe only legit reason to avoid remote feature branches it becomes annoying to navigate through too many branches. If that&#39;s the case you just agree with the team that everyone starts the branch name with their nickname and removes the branch once it is merged (GitHub allows to do this automatically, AFAIK). (new)&quot;, &quot;How do you do Pull Requests ?\n\nAnd reverting a `--no-ff` merge commit shouldn&#39;t be that bad / messy ? (new)&quot;, &#39;Pushing a branch to the remote doesn\&#39;t affect any other branches. Your CTO has no idea what they\&#39;re talking about.\n\nLearn the difference between a merge (with merge commit, &quot;--no-ff&quot;) and a fast-forward.\n\nAnd yes, trunk-based development (that is described in your link) is the only sensible branching strategy in my experience.&#39;, &quot;What is this guy smoking?!\n\nIf you want backups, there&#39;s this neat thing called version control. Wish I could remember what it was called. Gort? Gat? Guthib? And there&#39;s no limit to the amount of branches you can have!\n\nReverting is easy: `gort revert `\n\nIn all seriousness, if you want a clean git history rebasing can keep it pretty tidy (new)&quot;, &#39;Looks like most of the answers here are on point, Id suggest you read up on [github flow](https://docs.github.com/en/get-started/quickstart/github-flow) which will better explain feature master branching strategy. You should always push your feature to remote, I would suggest looking at open source github flow if you want to keep your repos origin clean (the forks model where you fork the repo, create features on your remote and pr back to upstream). Your CTO should prolly stick to CTOing and stay away from decisions on branching strategies etc. (new)&#39;, &#39;Fork the repo, push your feature branch to your remote, open a pull request to merge your feature branch from your fork into origin/master. This has served me well.\nOnly doing local development defeats half the purpose of git. Imo, push code for review early and mark the PR as do-not-merge. Early reviews means getting valuable feedback from others early in the process. (new)&#39;, &quot;&gt; His rationale for this is that you want to keep the main branch as clean as possible, in case you need to revert an earlier commit. \n\nThis sounds as he has not understood how Git or feature branches work... and what purpose a version control tool like Git has... \n\nAs long as you don&#39;t merge a branch into another you don&#39;t see the changes there (it does not matter if we are talking about main or any other branch).\n\n&gt; If you merge a feature branch in that is intertangled with code after the bad commit, undoing the commit becomes messy, and you might need to cherry-pick.\n\nBefore you merge into any branch you should squash the changes into a single commit and that one will be merged into the appropriate branch. That makes it. easy to undo a feature (based on the nature of the branch)...via a simple `git reverse ...`\n\nFurthermore if you don&#39;t push your feature branch to the server (remote) it can not checked via a CI/CD pipeline using automatated testing etc. which sounds even more strange to prevent people from pushing feature branches to a central location...How will tests run? (assumed that things like this exists).\n\n&gt;  Therefore, modern best practice is to only have one branch on the remote, and developers keep branches local (unless multiple developers are collaborating on one feature).\n\nThat&#39;s simply stupid and either a misunderstanding of the trunk/main/master based development..or simply a misunderstanding of a version control at all...\n\nFinally how could you do code reviews only in front of your local machine?\nYou push your feature branch to remote and you can create a PR of it or independant on that you can make review on that branch... (new)&quot;, &#39;&gt; [this post](https://barro.github.io/2016/02/a-succesful-git-branching-model-considered-harmful/#all-development-happens-on-the-master-branch) seems to advocate a similar idea.\n\nI wouldn\&#39;t say that. That post is advocating no *shared* remote branches, not no remote branches at all.\n\nWhat we do at my company is pretty consistent with that post, but not consistent with what your CTO is advocating for:\n\n- we have a single main branch in our shared repo (on GitLab)\n- developers work in feature branches (off of the main branch) locally\n- we all changes reviewed by a second developer. The feature branch is pushed to GitLab, and a merge request (MR) is created. An MR is essentially GitLab\&#39;s equivalent to a PR on GitHub, though the details are a bit different.\n- once the MR is approved, the changes from the feature branch are merged in and the branch is deleted\n\nSo the branches on the central repo aren\&#39;t exactly &quot;shared&quot;. Each feature branch has an owner, and typically, only they will write to the branch. Reviewers can see these branches, though.\n\nOne thing we do a bit different from that post is we don\&#39;t use fast forwards into the main branch. Instead, we use &quot;[semi-linear history](https://docs.gitlab.com/ee/user/project/merge_requests/reviews/#semi-linear-history-merge-requests)&quot;. This means a merge commit is still created, but it must be possible to fast forward.  (GitLab has an option to enforce this.)\n\nThis avoids the &quot;Christmas tree&quot; problem, but also makes it easy to see which commits were &quot;really&quot; on main (the merge commits, which are always the left parent) and which were intermediate commits on a feature branch. We\&#39;ve found this to be a nice middle-ground. With fast-forward-only, you have to either live with there being commits on you main branch that don\&#39;t pass CI, people wasting a lot of time making sure even intermediate commits do pass CI, or people just giving up and squashing away intermediate commits every time they merge (fine sometimes, but for bigger changes it can be nice to see the intermediate steps). (new)&#39;, &#39;No PRs, just local code review (if needed) and push to master (new)&#39;, &#39;Yeah this is the problem.  This is a bad workflow.  Google &quot;Git Flow&quot; it\&#39;s a widely used process for code changes and CI/CD.\n\nWhat you should be doing is creating a feature branch, pushing that to remote as often as needed, allowing CI/CD things to occur (like commit-hooks, or automated testing/builds) and once all interested parties have reviewed a PR (with constraints like minimum 2 approved reviews) then you merge to main branch (or a release branch, that once released, merges to main)\n\nSounds like the CTO has some old/outdated processes. (new)&#39;]</td><td class="s12" dir="ltr">[&#39;Use a single shared trunk&#39;, &#39;Use short-lived branches&#39;, &#39;Rebase before merge&#39;, &#39;Squashing commits into logical units&#39;, &#39;Mandatory code review policy&#39;, &#39;Promote frequent and rapid integration (CI) (+)&#39;, &#39;Automate test execution (unit, integration, e2e)&#39;, &#39;Adopt CI/CD pipelines for automated integration and delivery&#39;, &#39;Enable fast and continuous feedback (+)&#39;, &#39;Simplifies the development workflow (+)&#39;, &#39;Reduce merge conflicts (+)&#39;, &#39;Rely on modern Git-based collaboration platforms&#39;]</td></tr><tr style="height: 30px"><th id="958685326R39" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">40</div></th><td class="s13" dir="ltr"><span class="s3" style="background-color: #dce9cb; color: #2c481f; width: 147.0px; max-width: 147.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">git</span></td><td class="s14" dir="ltr">Isn&#39;t &quot;trunk based development&quot; just a complete crock of shit?</td><td class="s15" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/git/comments/14yyvvu/isnt_trunk_based_development_just_a_complete/">https://www.reddit.com/r/git/comments/14yyvvu/isnt_trunk_based_development_just_a_complete/</a></td><td class="s15" dir="ltr"><a target="_blank" href="https://www.reddit.com/r/git/comments/14yyvvu/isnt_trunk_based_development_just_a_complete/">https://www.reddit.com/r/git/comments/14yyvvu/isnt_trunk_based_development_just_a_complete/</a></td><td class="s16" dir="ltr"><span class="s3" style="background-color: #ebe6db; color: #4c535e; width: 128.0px; max-width: 128.0px; margin-left: 6.0px;  padding: 1.0px 5.0px 1.0px 5.0px ; ">DOĞRU</span></td><td class="s14" dir="ltr">[&#39;Isn\&#39;t &quot;trunk based development&quot; just a complete crock of shit?&#39;, &#39;To me, it sounds like the fanciest, most needlessly confusing way of expressing the principle that &quot;short lived feature branches are good&quot;. I would, in good faith, love to hear other opinions though! I am fascinated by the many, many, high powered pros who swear by it (new)&#39;, &#39;Trunk based development is by far the simplest version control policy. It can’t get any simpler. I have used it for my entire career (19 yrs so far).\n\nThe definition of trunk based development has actually changed. It currently means short lived feature branches merged into main, releases come from main. The other variant is you truly just commit straight to main. Then cut a release branch late, release from release branch. This has fallen out of favor because it is hard to do code review with that and code review is pretty standard these days.&#39;, &quot;I&#39;m retired now so I don&#39;t know if my opinion matters. However, in the 30-something years of software engineering from the absurd to the sublime I have to say trunk based is the only one that can be easily learned, easily enforced and easily understood even by the suits who really never understand anything.\n\nUntil something simpler can be thought up, I don&#39;t see that changing. In engineering, simple cannot be underestimated.&quot;, &#39;Have you gone through https://trunkbaseddevelopment.com? I ask because there is a lot more to the philosophy than feature branches imo. Some teams even commit straight to the trunk. But for example feature flags are typically used in true trunk-based flow.&#39;, &#39;I suggest reading https://martinfowler.com/articles/branching-patterns.html (in its entirety). By the time you get to the penultimate section, &quot;trunk-based development&quot;, you will have a far easier time understanding what TBD implies about supporting procedures and tools, what it may imply about branch usage, and why it may sound self-contradictory. In short, the things that make TBD good, if one thinks TBD is good, are usually not the TB parts.\n\nIn contrast, when somebody references https://trunkbaseddevelopment.com/ I inevitably have to ask which creative interpretation of &quot;trunk-based&quot; they\&#39;re applying and what practices make it useful for them.&#39;, &#39;When I started I. The industry. For a while, I was convinced it\&#39;s bullshit. \n\nAfter working with gitops models and different types of git flow methods, I can see why trunk based development might be considered superior. \n\nFirst of all, it\&#39;s simple to use for everyone... you don\&#39;t have to follow a process to start coding and doing versioning. \n\nSecond, you do adhere to a continuous integration principle since if you do test the code as you ensure the code you\&#39;re pushing is always going to be stable and tested and integrated with the code the others is pushing. \n\nThird, it forces you to use flags to enable your code. Which is a good principle overall. If you have CD. It also forces you to write your code so that apps can be scalable, so you don\&#39;t cause downtime every time you &quot;push to prod&quot; or to the master branch...\n\nI think there are probably many more good points about trunk development, but I\&#39;ve only mentioned a few of them that come to mind when I\&#39;m thinking of the shortcomings of gitflow. You can do all I\&#39;ve said in gitflow as well. But it\&#39;s not as simple or constraining.&#39;, &#39;Start here: [youtu.be/_w6TwnLCFwA](https://youtu.be/_w6TwnLCFwA) (new)&#39;, &quot;I agree it&#39;s sometimes made out to be more controversial than it really is. I think that also reflects a reality where developers as a whole have moved towards more flexible working styles. The continuous deployment/integration/etc movement and before that the move from waterfall style development to iterative approaches are along the same lines.  \n  \nI wrote a very short post here trying to take some of the mystery/bs out of trunk based development: https://bucket.co/blog/trunk-based-development. Might be helpful.&quot;, &quot;This is a very old thread, I know.  The company I work for used Trunk Based and we are trying to hire only people with experience with it.  Haven&#39;t had much success in finding such folks.  I hadn&#39;t worked with it before, and honestly despise it.  While as people below talk about short lived branches, the reality I&#39;m seeing is that devs work from and commit directly to main.  Add in the mandatory pair programming, and this place has the slowest development cadence of anywhere I&#39;ve worked in the 19 years I&#39;ve been in software&quot;, &#39;IMHO I agree, I\&#39;ve been reading about it a long time and most points are valid but my main is concern is &quot;pushing coherent chunks of code to master&quot; that is supposed to &quot;reduce bugs and tralalala&quot;.\n\nAnd the suggestion of using Feature Toggle / Flag to &quot;enable/disable&quot; piece of code.\n\nIn theory that\&#39;s great but it also miss a real point, sometimes it\&#39;s not that easy to set up a FF behind a chunk of code, it requires a good conception and all the teams may not be able to achieve it easily.\n\nSometimes a new &quot;feature&quot; may not be coherent if it doesn\&#39;t deliver real value to the end-user.\n\nIf you just release a &quot;chunk&quot; of something greater but which is not usefull as is, you missed the point.\n\nThere are times where a &quot;long-lived feature branch&quot; is inevitable, involving multiple skills to release a coherent &quot;package&quot; and not just an orphan chunk, which requires ops, frontend, backend, data, dba, etc.\n\nI would be very curious even about a simple ToDo application on how TBD applies here.\n\nAnother missing point is that the purpose of PR/MR is also the experiment, an initiative, &quot;hey guys I had an idea that can unblock us on &quot;whatever&quot; or here is a more performant way of doing this&quot; and empower collaboration over a formal, concrete implementation that may evolve and for which the quality increase.\n\nTBD seems to have been by lazy people thinking the cycle is only measured on the git lifecyle without taking  in account conception, architecture, coding best practices importance.\n\nAs well as unskilled developers who don\&#39;t know how to use git properly (checkout a main feature branch, rebase onto that branch, merge and contribute, review the final feature, adjust, clean, merge), most of the time it ends with conflicts hells not because it should end this way as a fatality but because 1. they don\&#39;t how to use git properly and how rebase / squash / cherry-pick work, 2. because they have splitted an epics to such granular tasks to &quot;parallelize&quot; leading to 3 peoples working/required a fucking single VO.\n\nPushing pushing pushing to master increases the number of shits you put in and make it difficult to change.\n\nWhenever a dev write some shitty code it takes forever to get rid of it and that is were we may introduce technical debt as soon as the code is pushed.\n\nIt also seems to me that no one willing to \\*\\*enforce\\*\\* this had never contributed to any open source projects that are way more scaled than most companies, in term of shipping velocity and quality, without having to set a shit load of FF or enforcing you to merge your PR by 24h.\n\nLast but not least, push value, not code. (new)&#39;, &quot;One point not rised by other commenters is that TBD is not a solo technique (alternatives aren&#39;t either but we get more out of the box from various forges).\n\n\nSo having unique name by which you can relate related techniques is very much a must.\n\n\n\n\nWould I use TBD as just replacement for long running branches? No. Not unless project is objectively messy already. You assure quality differently with TBD so you need extra budget to introduce other things with it (like feature flags). (new)&quot;, &quot;We commit to master mostly, unless it&#39;s a really big feature (new)&quot;, &quot;It&#39;s easy to do code review with just trunk. Slap Gerrit in front of you git hosted repo and you are done.\n\nIt&#39;s pure Github/Gitlab that make code review impossible without a branch. Slap Gerrit there, or do pair programming, or do 100% feature flags and sleep only those that passed all quality checks. (new)&quot;, &#39;I think that means your opinion matters more than most! I find it very interesting that this practice has actually been around for so long, which on its own speaks to some amount of natural merit (new)&#39;, &#39;&gt; In contrast, when somebody references https://trunkbaseddevelopment.com/ I inevitably have to ask which creative interpretation of &quot;trunk-based&quot; they\&#39;re \n\nIt is indeed interesting how the meaning of “trunk based development” has changed over the years. What I knew as TBD doesn’t seem to be the current definition. So I always ask people what they mean by TBD when they mention it as well.\n\nIt is kind of like microservice architecture. It’s original meaning has pretty much been totally lost.&#39;, &#39;This is by far the most information rich answer, and helps me understand both the real value proposition and why I felt misled by the hype machine. Thank you for this! (new)&#39;, &#39;I have seen this video. I found it to be full of absurdities, loose ends, and baseless conjecture. (new)&#39;, &#39;nice!  i liked the follow up as well (new)&#39;, &#39;Is there any resistance among tech leads to protecting main or why are devs allowed to commit straight to main without a pull/merge request? (new)&#39;, &#39;I introduced TBD in large ish legacy codebase (plus N smaller repos). Had to do some of supporting techniques by hand due to language versions, etc.\n\n\nSo if you still look for devs who care about whole SDLC, remote in EU/USA, with PHP experience, please DM with link to recruitment. (new)&#39;, &quot;&gt; It&#39;s easy to do code review with just trunk. Slap Gerrit in front of you git hosted repo and you are done.\n\nNice, thanks for the pointer to gerrit. What is the workflow with gerrit? Does it intercept the commit and not actually commit until the review is done? (new)&quot;, &#39;You **DO** know who Dave Farley is, right? (new)&#39;, &quot;haha, thanks! For everyone else, here&#39;s the follow up: [https://bucket.co/blog/trunk-based-development-misconceptions](https://bucket.co/blog/trunk-based-development-misconceptions)&quot;, &#39;There is not because senior leadership has made it 100% clear that this is the path we are to follow and if we don’t like it, we can find work elsewhere (new)&#39;, &quot;You set up a git repo with it and submit commits via normal git (albeit on different branches) and then can push from gerrit to  your main repo once everything is OK. Gerrit have lots of integrations so that it can track CI or other stuff per commit and display that to reviewers. Can also support rules of conduct like, review only after automatic CI, etc.\n\nOh, and it assigns ID to a commit so that you can modify the same commit multiple times and Gerrit shows that for a reviewer (with comments from previous rounds of review).\n\nIt&#39;s as if Github/Gitlab review functionality was inspired constantly by particular competitor. ;) (new)&quot;, &#39;I sure do. Not sure what that has to do with whether the points he makes in that video are well supported or whether he does any sort of job at all addressing fair criticisms in the comments. (new)&#39;, &#39;That sounds incredibly frustrating. Sorry about that. (new)&#39;, &#39;That he is talking from decades of own experience.\n\nOne can learn from it or not.\n\nIn his videos he often makes a point telling the viewer that this is HIS experience and there is room for other viewpoints - but that he have found that other existing approaches are less effective. (new)&#39;, &#39;It is what it is. One of the devs yesterday said to me that this model is awful because there is zero chance for buyer’s remorse. If we find a bug in the test environment, we have to pull our changes out of main before someone else deploys (new)&#39;, &#39;He actually makes a point of repeatedly and dubiously citing a &quot;study&quot; (which is really more of a report; it\&#39;s extremely unacademic in nature) which at best only implies the things that he claims it flat out concludes, not his own experience. He willfully ignores a lot of context around these choices which can make them better or worse, claiming only that this way of doing things (the precise prescription even-- he\&#39;s clear about the fact that he does not think there are other similar pathways to attain the same outcome) is an unqualified good for both release quality and velocity.\n\nThere are plenty of people with just as much experience as Dave who have different viewpoints on this, and his video (and follow up comments) on this matter was childishly reductive in pretending that there are not good reasons for doing things any other way.\n\nEDIT: maybe he did actually call it a report, it doesn\&#39;t really matter though. It\&#39;s not concluding what he claims it is if you read the report, and it\&#39;s definitely not fashioned as an authoritative source of best practices (new)&#39;, &quot;You do you. Some agree, some don&#39;t.\n\nTo your original question: The answer is no. (new)&quot;]</td><td class="s17" dir="ltr">[&#39;Use short-lived branches&#39;, &#39;Use a single shared trunk&#39;, &#39;Commit frequently (daily)&#39;, &#39;Promote frequent and rapid integration (CI) (+)&#39;, &#39;Adopt CI/CD pipelines for automated integration and delivery&#39;, &#39;Shortens automated feedback cycles by testing each trunk commit against the main codebase through CI/CD pipelines (+).&#39;, &#39;Enable fast and continuous feedback (+)&#39;, &#39;Simplifies the development workflow (+)&#39;, &#39;Feature flag complexity and debt management required&#39;, &#39;Use feature flags to safely integrate incomplete features&#39;, &#39;Use feature flags to decouple deployment from release&#39;, &#39;Use pair programming or mob programming for collaboration&#39;, &#39;Mandatory code review policy&#39;, &#39;Reduce merge conflicts (+)&#39;, &#39;Cultural or organizational resistance is common (-)&#39;, &#39;Requires robust testing and test infrastructure (-)&#39;, &#39;Requires strong discipline and team coordination (-)&#39;, &#39;May be difficult for inexperienced developers (-)&#39;]</td></tr></tbody></table></div>