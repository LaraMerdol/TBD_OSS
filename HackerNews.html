<meta http-equiv="Content-Type" content="text/html; charset=utf-8"><link type="text/css" rel="stylesheet" href="resources/sheet.css" >
<style type="text/css">.ritz .waffle a { color: inherit; }.ritz .waffle .s11{border-bottom:1px SOLID #f6f8f9;border-right:1px SOLID #284e3f;background-color:#f6f8f9;text-align:left;color:#434343;font-family:docs-Roboto,Arial;font-size:10pt;vertical-align:middle;white-space:nowrap;overflow:hidden;direction:ltr;padding:2px 8px 2px 8px;}.ritz .waffle .s6{border-bottom:1px SOLID #f6f8f9;border-right:1px SOLID #284e3f;background-color:#ffffff;text-align:left;color:#434343;font-family:docs-Roboto,Arial;font-size:10pt;vertical-align:middle;white-space:nowrap;overflow:hidden;direction:ltr;padding:2px 8px 2px 8px;}.ritz .waffle .s12{border-bottom:1px SOLID #284e3f;border-right:1px SOLID #f6f8f9;background-color:#f6f8f9;text-align:left;color:#434343;font-family:docs-Roboto,Arial;font-size:10pt;vertical-align:middle;white-space:nowrap;overflow:hidden;direction:ltr;padding:2px 8px 2px 8px;}.ritz .waffle .s9{border-bottom:1px SOLID #f6f8f9;border-right:1px SOLID #f6f8f9;background-color:#f6f8f9;text-align:left;text-decoration:underline;text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#434343;font-family:docs-Roboto,Arial;font-size:10pt;vertical-align:middle;white-space:nowrap;overflow:hidden;direction:ltr;padding:2px 8px 2px 8px;}.ritz .waffle .s1{border-bottom:1px SOLID #284e3f;border-right:1px SOLID #284e3f;background-color:#356854;text-align:left;color:#ffffff;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;overflow:hidden;direction:ltr;padding:2px 8px 2px 8px;}.ritz .waffle .s13{border-bottom:1px SOLID #284e3f;border-right:1px SOLID #f6f8f9;background-color:#f6f8f9;text-align:right;color:#434343;font-family:docs-Roboto,Arial;font-size:10pt;vertical-align:middle;white-space:nowrap;overflow:hidden;direction:ltr;padding:2px 8px 2px 8px;}.ritz .waffle .s4{border-bottom:1px SOLID #f6f8f9;border-right:1px SOLID #ffffff;background-color:#ffffff;text-align:left;text-decoration:underline;text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#434343;font-family:docs-Roboto,Arial;font-size:10pt;vertical-align:middle;white-space:nowrap;overflow:hidden;direction:ltr;padding:2px 8px 2px 8px;}.ritz .waffle .s5{border-bottom:1px SOLID #f6f8f9;border-right:1px SOLID #ffffff;background-color:#ffffff;text-align:center;color:#434343;font-family:docs-Roboto,Arial;font-size:10pt;vertical-align:middle;white-space:nowrap;overflow:hidden;direction:ltr;padding:2px 8px 2px 8px;}.ritz .waffle .s16{border-bottom:1px SOLID #284e3f;border-right:1px SOLID #284e3f;background-color:#f6f8f9;text-align:left;color:#434343;font-family:docs-Roboto,Arial;font-size:10pt;vertical-align:middle;white-space:nowrap;overflow:hidden;direction:ltr;padding:2px 8px 2px 8px;}.ritz .waffle .s2{border-bottom:1px SOLID #f6f8f9;border-right:1px SOLID #ffffff;background-color:#ffffff;text-align:left;color:#434343;font-family:docs-Roboto,Arial;font-size:10pt;vertical-align:middle;white-space:nowrap;overflow:hidden;direction:ltr;padding:2px 8px 2px 8px;}.ritz .waffle .s15{border-bottom:1px SOLID #284e3f;border-right:1px SOLID #f6f8f9;background-color:#f6f8f9;text-align:center;color:#434343;font-family:docs-Roboto,Arial;font-size:10pt;vertical-align:middle;white-space:nowrap;overflow:hidden;direction:ltr;padding:2px 8px 2px 8px;}.ritz .waffle .s3{border-bottom:1px SOLID #f6f8f9;border-right:1px SOLID #ffffff;background-color:#ffffff;text-align:right;color:#434343;font-family:docs-Roboto,Arial;font-size:10pt;vertical-align:middle;white-space:nowrap;overflow:hidden;direction:ltr;padding:2px 8px 2px 8px;}.ritz .waffle .s10{border-bottom:1px SOLID #f6f8f9;border-right:1px SOLID #f6f8f9;background-color:#f6f8f9;text-align:center;color:#434343;font-family:docs-Roboto,Arial;font-size:10pt;vertical-align:middle;white-space:nowrap;overflow:hidden;direction:ltr;padding:2px 8px 2px 8px;}.ritz .waffle .s0{border-bottom:1px SOLID #284e3f;border-right:1px SOLID #356854;background-color:#356854;text-align:left;color:#ffffff;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;overflow:hidden;direction:ltr;padding:2px 8px 2px 8px;}.ritz .waffle .s14{border-bottom:1px SOLID #284e3f;border-right:1px SOLID #f6f8f9;background-color:#f6f8f9;text-align:left;text-decoration:underline;text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#434343;font-family:docs-Roboto,Arial;font-size:10pt;vertical-align:middle;white-space:nowrap;overflow:hidden;direction:ltr;padding:2px 8px 2px 8px;}.ritz .waffle .s8{border-bottom:1px SOLID #f6f8f9;border-right:1px SOLID #f6f8f9;background-color:#f6f8f9;text-align:right;color:#434343;font-family:docs-Roboto,Arial;font-size:10pt;vertical-align:middle;white-space:nowrap;overflow:hidden;direction:ltr;padding:2px 8px 2px 8px;}.ritz .waffle .s7{border-bottom:1px SOLID #f6f8f9;border-right:1px SOLID #f6f8f9;background-color:#f6f8f9;text-align:left;color:#434343;font-family:docs-Roboto,Arial;font-size:10pt;vertical-align:middle;white-space:nowrap;overflow:hidden;direction:ltr;padding:2px 8px 2px 8px;}</style><div class="ritz grid-container" dir="ltr"><table class="waffle" cellspacing="0" cellpadding="0"><thead><tr><th class="row-header freezebar-vertical-handle"></th><th id="918362267C0" style="width:300px;" class="column-headers-background">A</th><th id="918362267C1" style="width:100px;" class="column-headers-background">B</th><th id="918362267C2" style="width:300px;" class="column-headers-background">C</th><th id="918362267C3" style="width:124px;" class="column-headers-background">D</th><th id="918362267C4" style="width:300px;" class="column-headers-background">E</th><th id="918362267C5" style="width:300px;" class="column-headers-background">F</th></tr></thead><tbody><tr style="height: 30px"><th id="918362267R0" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">1</div></th><td class="s0" dir="ltr">title</td><td class="s0" dir="ltr">id</td><td class="s0" dir="ltr">url</td><td class="s0" dir="ltr">OSS-related?</td><td class="s0" dir="ltr">discussion_items</td><td class="s1" dir="ltr">CODES</td></tr><tr><th style="height:3px;" class="freezebar-cell freezebar-horizontal-handle"></th><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td><td class="freezebar-cell"></td></tr><tr style="height: 30px"><th id="918362267R1" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">2</div></th><td class="s2" dir="ltr">Ask HN: Does trunk based development work?</td><td class="s3" dir="ltr">43044594</td><td class="s4" dir="ltr"><a target="_blank" href="https://news.ycombinator.com/item?id=43044594">https://news.ycombinator.com/item?id=43044594</a></td><td class="s5" dir="ltr">YANLIŞ</td><td class="s2" dir="ltr">[&#39;Ask HN: Does trunk based development work?&#39;, &#39;Ok so here’s the thing, the more I read up stuff on making a team more effective, the more I see benefits of trunk based development(continuous deployment, faster feedback times etc)However I’ve only seen it once and it was a shit show honestly.I’d like to understand if anyone here is using trunk based development on their prod system, I.e someone does a small patch, writes some code and deploys it prod directly(maybe behind a feature flag).How’s your system stability? How thorough are your tests, is is worth doing?Why am I pursing this: My team unfortunately has VERY long drawn out release cycles and too many manual checkpoints(from release meetings to figuring out what should be release and what shouldn’t be) and its becoming a big problem.&#39;, &#39;Trunk-based development works.In fact I suspect most people working in SaaS are doing some kind of Trunk-based development - some unknowingly.There are tons of misconceptions about _what it is_. I wrote a blog post on common misconceptions about trunk-based development here: https:&amp;#x2F;&amp;#x2F;bucket.co&amp;#x2F;blog&amp;#x2F;trunk-based-development-crock-of-shit&#39;, &#39;Like so many things, it depends. You have to consider risk, to the data, to the user experience, to the other work going on. Changing some text or a button, adding a new report, sure, push to master and deploy. Low risk. Other kinds of changes might corrupt the database, confuse users, expose the application to a security vulnerability, or bring the business to a halt.As another commenter said you can roll back a bad deployment, but that only matters if the bad deployment didn’t break things. You can pull a knife out of your leg but that doesn’t roll back the damage.Thinking in absolutes, calling a cautious workflow “cancer,” doesn’t help developers make good decisions. For a change that might cause significant or irreparable damage I want a feature branch, a pull request, and reviews. (new)&#39;, &#39;Yes, it works. The &amp;quot;git flow&amp;quot; blogpost is cancer.The faster you can deploy, the faster you can deploy fixes. Also note, you can always roll back bad deployment.But, using a trunk branch (eg master, main, whatever you want to call it), doesn&amp;#x27;t mean you can&amp;#x27;t support a variety of release schedules. You primarily just feature flag the elements that aren&amp;#x27;t scheduled for release. (new)&#39;]</td><td class="s6" dir="ltr">[&#39;Accelerate release cycles (+)&#39;, &#39;Deploy frequently and provide fast feedback&#39;, &#39;Enable fast and continuous feedback (+)&#39;, &#39;Promote frequent and rapid integration (CI) (+)&#39;, &#39;Reduce merge conflicts (+)&#39;, &#39;Shortens automated feedback cycles by testing each trunk commit against the main codebase through CI/CD pipelines (+).&#39;, &#39;Simplifies the development workflow (+)&#39;, &#39;Use feature flags to safely integrate incomplete features&#39;, &#39;Use feature flags to decouple deployment from release&#39;, &#39;Support safe experimentation and rollback&#39;]</td></tr><tr style="height: 30px"><th id="918362267R2" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">3</div></th><td class="s7" dir="ltr">Trunk-Based Development: Game Changers</td><td class="s8" dir="ltr">34733805</td><td class="s9" dir="ltr"><a target="_blank" href="https://trunkbaseddevelopment.com/game-changers/">https://trunkbaseddevelopment.com/game-changers/</a></td><td class="s10" dir="ltr">YANLIŞ</td><td class="s7" dir="ltr">[&#39;Trunk-Based Development: Game Changers&#39;, &#39;It&amp;#x27;s rather funny.&amp;quot;Trunk-based development&amp;quot; is essentially counter-marketing to Gitflow. Before Gitflow, trunk-based development was so routine it didn&amp;#x27;t need a proper name or website.Gitflow has the &amp;quot;interesting&amp;quot; properties of being more complex than release-ready trunk-based setups, while (in most contexts) decreasing quality, and delivery speed.Unfortunately, Gitflow is very appealing to mediocre managers who want to point to a website and some pretty pictures and say &amp;quot;we do that&amp;quot; (thus, alleviating themselves of any actual engineering or contextual thinking). So the counter-marketing is helpful, but it feels rather ridiculous how the software world is so susceptible to these trends.It reminds me of the Alan Kay quote, &amp;quot;programming is a pop culture.&amp;quot;&#39;, &#39;We have a main branch, and a develop branch. Feature branches are based on the main branch.When a developer is happy with their feature branch, they open a pull request to develop, which gets reviewed by another developer and, eventually, merged to develop.The code in develop gets deployed semi-hourly or on demand to a testing environment, where quality assurance takes on the feature branch.Eventually, when the testers are happy with the feature branch, it gets merged to the main branch. Main gets deployed to production daily, or on demand. There are no release branches or tags.Feature branches that take longer are periodically rebased on main (or main gets merged into the feature branch). On rare occasions, hotfix branches are merged directly to main (and immediately, possibly partially, deployed). That code lands in develop via an automatic merge process from main to develop.The weakness of the model would appear to be that testing practically never happens on the main code branch. I say practically, because we do have a staging environment that reflects the main branch code version, but it&amp;#x27;s almost unused. It just hasn&amp;#x27;t been an issue in a decade+ working this way with a team of 8-20 developers. Maybe it doesn&amp;#x27;t scale to much larger teams?Someone help me out, is there a name for this model? \nIt doesn&amp;#x27;t appear to be gitflow, which IIUC periodically transforms (or merges) the entire develop branch into  main branch (we never do this). But it also doesn&amp;#x27;t sound like it&amp;#x27;s trunk based development, which doesn&amp;#x27;t seem to have a develop branch, and also uses versioned releases. We can&amp;#x27;t be the only ones doing it this way?&#39;, &#39;&amp;gt; It is important to note that today’s CR-delimited text file systems are blunt instruments compared to the fine-grained directed graphs with fidelity down to class&amp;#x2F;method history of each of those. It was more like a multidimensional database with cross-cutting tags representing HEAD, or someone else’s important combination of those three. It was omnipresent too - a decision made to move HEAD was instantly available without ‘update’ action to teammatesThese stories about Smalltalk and Lisp (machines) sometimes read as if they came from a forgotten, ancient civilization that was way more advanced than ours.When does the renaissance come? (new)&#39;, &#39;I think it&amp;#x27;s interesting to note that Google&amp;#x27;s &amp;quot;default&amp;quot; model now (what&amp;#x27;s recommend to incoming engineers) is the fully trunk-based monorepo, in a Perforce clone called Piper... But with a Mercurial based interface for actual development.In your individual checkout you can have arbitrary branching structures, then it just gets squashed down to a linear model when you submit to the monorepo.It&amp;#x27;s a bit annoying from a technical POV that there are two separate VCS, but the conceptual model works well IMO.&#39;, &#39;Trunk based development is a marketing name..Frequent releases of a main branch to which developers push code (either via other branches, mr&amp;#x27;s) or direct commits... Thats what it is..Even if you create a release branch on every release... A tag would also do.. But a tag and a branch are technically quite similar in git... Its mostly fluffDeploy often, dont have long lived branches. Have your main branch in a deployable state 90% of the time... Hoora youre there&#39;, &#39;I love trunk based development, but hardly ever get to do it because other developers don’t like it.&#39;, &#39;This could really do with defining what trunk based development is!Edit: I read the first hit from CircleCI and I am none the wiser. The article seems to suggest it could be any of these things:* Having a main (`master`) branch. But literally everyone except maybe Linux developers does this.* Not using branches? Which sounds awful.* Pushing directly to `master` and then running CI&amp;#x2F;CD! This is insane; does anyone really do this?So what is it exactly? Linear history?&#39;, &#39;I know its hardly fashionable...but what&amp;#x27;s really wrong with release integration branches? (new)&#39;, &#39;At that I&amp;#x27;m kinda waiting for someone to advertise &amp;quot;just putting each release in tarball with date in name&amp;quot; as the new hot in source control. Hell, let&amp;#x27;s go back to CVS while we&amp;#x27;re at it (new)&#39;, &#39;It&amp;#x27;s really important to point out that Google&amp;#x27;s monorepo works in large part because they have spent 100s of engineering years on their build and deployment tools.It would be very hard for a large company to adopt their monorepo because you&amp;#x27;d have to replicate their tools.Just in case anyone was thinking of just copying Google... (new)&#39;, &#39;In regards to the subject I think it is also important for the developers to understand and agree upon what the mainline (master&amp;#x2F;main&amp;#x2F;etc.) branch represents. For me it should contain only commits&amp;#x2F;changes which result in the new HEAD properly working and having a bug fixed and&amp;#x2F;or feature added.So the feature&amp;#x2F;bug&amp;#x2F;etc. branches can contain multiple commits which are helpful for the developer(s) that&amp;#x27;s working on it but it all should be squashed into a single one during merging into master.In short the history noise in master should be kept in check and reduced as much as possible which makes e.g. bisect easier as we don&amp;#x27;t take into account pointless commits and the history is cleaner. Problem is many think &amp;quot;more is better&amp;quot; and they end up with branches that are much more complicated to work with and reason about. (new)&#39;, &#39;Trunk-based development reminds me of Agile Development: the drawbacks mostly accrue to the developers while the benefits mostly accrue to the managers.&#39;]</td><td class="s11" dir="ltr">[&#39;Accelerate release cycles (+)&#39;, &#39;Deploy frequently and provide fast feedback&#39;, &#39;Trunk always ready for release&#39;, &#39;Simplifies the development workflow (+)&#39;, &#39;Use a single shared trunk&#39;, &#39;Use short-lived branches&#39;, &#39;Squashing commits into logical units&#39;, &#39;Reduce merge conflicts (+)&#39;, &#39;Commit frequently (daily)&#39;, &#39;Rebase before merge&#39;, &#39;Cultural or organizational resistance is common (-)&#39;, &#39;Requires strong discipline and team coordination (-)&#39;, &#39;Mandatory code review policy&#39;]</td></tr><tr style="height: 30px"><th id="918362267R3" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">4</div></th><td class="s2" dir="ltr">Ask HN: Does acceptance testing/BDD slow down development?</td><td class="s3" dir="ltr">34983454</td><td class="s4" dir="ltr"><a target="_blank" href="https://news.ycombinator.com/item?id=34983454">https://news.ycombinator.com/item?id=34983454</a></td><td class="s5" dir="ltr">YANLIŞ</td><td class="s2" dir="ltr">[&#39;Ask HN: Does acceptance testing/BDD slow down development? (new)&#39;, &#39;Hi HN,We are currently debating at work how to implement continuous delivery in one of our products.My argument is that if we are implementing continuous delivery then almost all PRs should include integ&amp;#x2F;acceptance tests even before the feature is toggled in prod since we are continuously releasing mainline instead of using versioned trunks. Other devs are arguing that a hard requirement on integ&amp;#x2F;acceptance tests will slow down development 3x.I was wondering what has your experience been with implementing continuous delivery, did you require integ tests in every commit, did they slow down development? (new)&#39;, &#39;I have no direct experience, so you can ignore the rest of this if you want.What&amp;#x27;s the cost to development from “slowing down” due to integration&amp;#x2F;acceptance tests before deployment vs. stopping development entirely to go back and fix errors that were deployed (including potential real dollar costs to customers being affected by the error)? If you had to choose between slowing down development by requiring tests vs. accruing technical debt by deploying potentially buggy code without the tests as a gate, which makes economic sense? (new)&#39;]</td><td class="s6" dir="ltr">[&#39;Adopt CI/CD pipelines for automated integration and delivery&#39;, &#39;Automate test execution (unit, integration, e2e)&#39;, &#39;Trunk always ready for release&#39;, &#39;Enable fast and continuous feedback (+)&#39;, &#39;Deploy frequently and provide fast feedback&#39;, &#39;Use feature flags to safely integrate incomplete features&#39;, &#39;Requires robust testing and test infrastructure (-)&#39;]</td></tr><tr style="height: 30px"><th id="918362267R4" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">5</div></th><td class="s7" dir="ltr">Show HN: Changelog CLI – no more undescribed changes – CI/TrunkBased oriented</td><td class="s8" dir="ltr">42894848</td><td class="s9" dir="ltr"><a target="_blank" href="https://github.com/runespoor-engineering/runespoorstack/tree/main/cli/changelog">https://github.com/runespoor-engineering/runespoorstack/tree/main/cli/changelog</a></td><td class="s10" dir="ltr">YANLIŞ</td><td class="s7" dir="ltr">[&#39;Show HN: Changelog CLI – no more undescribed changes – CI/TrunkBased oriented&#39;, &#39;A specialized CLI tool (@runespoor&amp;#x2F;changelog-manager) designed for managing changelogs and semantic versioning in single repositories, particularly optimized for Continuous Integration and Trunk Based Development workflows.Key Features: Automated Version Management - intelligently handles semantic versioning based on change types. Standardized Change Documentation - enforces consistent changelog formats. CI&amp;#x2F;CD Integration - built-in commands for verification in CI pipelines. Issue Tracking - optional integration with issue tracking systems. Git Integration - automated commit and push functionality.Use Cases: Maintaining consistent changelog entries across team members. Automating version bumps based on change significance. Enforcing change documentation in CI&amp;#x2F;CD pipelines. Tracking changes with associated issue references. Standardizing release documentationThe tool essentially automates the often manual and error-prone process of maintaining changelogs and version numbers in a development workflow.Core Commands:rune change: Interactive command to document changes before merging. Generates timestamped JSON files containing change details. Captures change type (major&amp;#x2F;minor&amp;#x2F;patch&amp;#x2F;none), description, author, and optional issue linksrune verify: CI-focused validation command. Ensures proper change files exist and are valid. Verifies branch differences and file naming conventionsrune apply: Processes accumulated change files. Automatically bumps version numbers based on change types. Updates CHANGELOG.md and package.json. Commits and pushes changelogs&#39;]</td><td class="s11" dir="ltr">[&#39;Adopt CI/CD pipelines for automated integration and delivery&#39;, &#39;Integrate CI/CD tools&#39;, &#39;Maintain traceability and code history&#39;, &#39;Automate code quality checks (linting, testing, analysis)&#39;, &#39;Automate test execution (unit, integration, e2e)&#39;, &#39;Trunk always ready for release&#39;, &#39;Enable fast and continuous feedback (+)&#39;, &#39;Promote frequent and rapid integration (CI) (+)&#39;, &#39;Simplifies the development workflow (+)&#39;, &#39;Use internal/custom-built tools for specialized needs&#39;, &#39;Enforce standardized and automated changelog documentation as part of trunk merges (new)&#39;]</td></tr><tr style="height: 30px"><th id="918362267R5" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">6</div></th><td class="s2" dir="ltr">Ask HN: How to Handle Impossible Situation</td><td class="s3" dir="ltr">20892585</td><td class="s4" dir="ltr"><a target="_blank" href="https://news.ycombinator.com/item?id=20892585">https://news.ycombinator.com/item?id=20892585</a></td><td class="s5" dir="ltr">YANLIŞ</td><td class="s2" dir="ltr">[&#39;Ask HN: How to Handle Impossible Situation (new)&#39;, &#39;I&amp;#x27;m currently at a Big Dumb Corp. We have a legacy application that actually does pretty well as an add on to the main line of business.The situation is this; we host the applications on our infrastructure. The company has an infrastructure group that manages the servers, network, databases, etc. We basically throw a .war over a wall and they just take care of it (this is a java shop btw). Due to PII&amp;#x2F;PHI reasons, development doesn&amp;#x27;t have access to the prod or UAT environments.The issue comes when there are problem with a release. We had one release recently that&amp;#x27;s been very unstable on our largest customers. Everythings fine for smaller customers but when it comes the customers with the really big DB&amp;#x27;s we have servers going unresponsive, require restarts etc. Needless to say, we don&amp;#x27;t do load testing, so this was not caught before release. The infrastructure team just rolls back to previous versions if customers complain too much.It&amp;#x27;s a real disaster. The problem is the infrastructure team takes no responsibility in trouble shooting or diagnosing the JVM issues, and Dev has no access to do it.  If it was me, I&amp;#x27;d connect visualvm to a server&amp;#x2F;jvm and watch it constantly. But I can&amp;#x27;t, I don&amp;#x27;t have access and can&amp;#x27;t get access.Does anyone have input on this type of situation? What course of action can the development take in this situation? I feel like I&amp;#x27;m just whining and pointing fingers, I&amp;#x27;d really like to have a solution for this! (new)&#39;, &#39;The best solution in an env like this would be to have a good APM like AppDynamics. If you don’t have that and can’t get it installed, next best would be good logs and a good log aggregator&amp;#x2F;search tool like splunk. Another option (sorry in advance, this sucks, but “works” to find these issues for some definition of “works”): Branch off the last good version, apply changes one by one (or bisect) and push them out to one of the complaining customers - hopefully with their collaboration. When it breaks again, you know where to start looking. Good luck! (new)&#39;, &#39;This isn&amp;#x27;t a technical problem, it&amp;#x27;s a business problem. Who are the relevant decision-makers, and what are their constraints when it comes to allocating resources? (new)&#39;]</td><td class="s6" dir="ltr">[&#39;Cherry-pick changes to release branches&#39;, &#39;Staged rollout with rollback support&#39;]</td></tr><tr style="height: 30px"><th id="918362267R6" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">7</div></th><td class="s7" dir="ltr">I prefer trunk-based development</td><td class="s8" dir="ltr">36571253</td><td class="s9" dir="ltr"><a target="_blank" href="https://trishagee.com/2023/05/29/why-i-prefer-trunk-based-development/">https://trishagee.com/2023/05/29/why-i-prefer-trunk-based-development/</a></td><td class="s10" dir="ltr">YANLIŞ</td><td class="s7" dir="ltr">[&#39;I prefer trunk-based development&#39;, &#39;&amp;gt; when we say CI, what CI really meant was actually integrate your code regularly. Code living on separate branches is, by definition, not integrated.When I work on a long lived (say, a week or two) branch, I just rebase it on main every morning or some times several times per day. It always contains 100% of everyone elses code. But their code contains 0% of my commits yet. Because that&amp;#x27;s the point of the branch. That none of it is visible to anyone else, until I deem it ready to. The point is that when I merge it, it looks like an atomic change on main, which takes it from one working state (100% passing tests and so on) to another working state. And the only way to ensure that is to make the validation take place IN my branch.If I&amp;#x27;m eager to &amp;quot;publish&amp;quot; my work, I can do that. I can make multiple branches with just one or two commits each on monday and tuesday with new functionality behind some feature flag. And then the final friday commit is basically just flipping the feature flag. But it doesn&amp;#x27;t change the fact that I do want to make sure main stays healthy so I still want to gate the commits. I don&amp;#x27;t think there is a pattern of development that works everywhere, and whether one thinks that feature branches is an overhead I think will vary.People who are used to a project taking 3 months and having multiple builds per day, perhaps having their tests run in seconds via a commit hook, will think that the overhead of a PR is massive. But if validation builds&amp;#x2F;tests take multiple hours anyway then the overhead of making branches isn&amp;#x27;t really going to have an impact on productivity. (new)&#39;, &#39;I think the article paints a false dichotomy. DVCSs and trunk-oriented development are fully compatible.I work on an open-source project using git that has both a main branch that&amp;#x27;s continuously-deployed, and stable branches for twice-yearly community releases.We treat the main as a trunk: everyone makes small PRs to it and they&amp;#x27;re generally deployed day-of, if not within a couple of hours. If anyone&amp;#x27;s PR is too big, they&amp;#x27;re generally asked to split it up for incremental review+merge into main. PRs are generally rebased onto to main and tested via CI regularly, including right before merge. So, we enjoy all the &amp;quot;trunk-based&amp;quot; development benefits that the article describes. I get the impression that this workflow is common in the industry, especially for GitHub users.That said, the branching features of git are still essential for us for creating, testing, and patching those stable community release branches. That&amp;#x27;s not to mention the offline development quality-of-life features that DVCSs give us. I couldn&amp;#x27;t imagine not using a DVCS!&#39;, &#39;This article fails for me because it doesn’t clearly define the two sides: what constitutes “trunk” vs “branch”? The two sides in this argument are always fighting their own straw man of the other side.I’ve heard teams using Phabricator for “trunk based development” say they are reviewing commits not branches. If you’re doing any code review or CI before code lands on trunk, I’ve got a hard time seeing the difference between that and a “branch”.Even in a CVS like SVN, your local code changes are still a “branch” that diverged from trunk until you commit it up to the server. And if you go 1-2 weeks without committing to trunk that’s just the same to others as going 1-2 weeks making hourly local git commits to a local branch…And if I make a local git branch, commit 100 times to it over 6 hours, and then squash those local commits and push a single change to trunk, is that any different from trunk development?At $JOB we use GitHub, try to make small Pull Requests that are usually merged within 24 hours of PR open, and those PRs tend to receive commits for between 6 hours and 4 days before we try to merge them into `main`.  But you’re free to make as many commits as you want to your branch. We squash it down to a single commit rebased on main. Main is the only branch that lives indefinitely. Is that “branch” or “trunk” development? I think it’s “trunk” but maybe the author would differ.&#39;, &#39;&amp;gt; Trunk-based development encourages frequent commits, which leads to smaller and more manageable changes.I strongly disagree with this assertion. In my years of doing development with SVN&amp;#x2F;CVS the consistent pattern I would see is that developers didn&amp;#x27;t want to publish their work to trunk until they were certain it was good, and since with SVN you can&amp;#x27;t make local commits without publishing to trunk people delayed making commits until a feature was complete.In other words, all the work that would be done on a branch with git was instead done on the developer&amp;#x27;s local machine without any revision control (and often without backups). Good developers would frequently `svn update` as they worked to get smaller conflicts, but code was merged to trunk at the same frequency as it is today with git[1].In git, the equivalent would be make a branch, then commit --amend each change, fetch and rebase frequently, and then merge the single &amp;quot;squashed&amp;quot; commit.[1] If anything code was merged less frequently because agile encourages smaller stories today but that is completely orthogonal to trunk vs branch based development.&#39;, &#39;the longer we leave it to commit our changes, the higher the chances our commit will clash with someone else&amp;#x27;s changesThe further you let your branch deviate from the trunk the worse it gets, sure, but you can alleviate that problem pretty much entirely by regularly merging develop into your feature branch. When it&amp;#x27;s time to merge your feature into develop there aren&amp;#x27;t many conflicts because you&amp;#x27;ve already got all the changes in your branch.Trunk based dev is still better in my opinion, mostly because it forces people to check their work properly, to write robust tests, or else they risk breaking the build. If you work on a team with people who aren&amp;#x27;t particularly careful then it&amp;#x27;s not worth the hassle though.&#39;, &#39;The problem with CD is not so much that you might break production (though that&amp;#x27;s definitely an issue, even if you have comprehensive tests).The problem is that you&amp;#x27;re constantly disrupting users with new features, changes to existing ones, and usually resetting or invalidating any open sessions.I think CD is most useful to integrate into a &amp;#x27;staging&amp;#x27; branch that is effectively the &amp;#x27;trunk&amp;#x27; branch as far as developers are concerned. And that branch is them deployed to production on a schedule, say weekly, etc. Development should stil happen on feature branches though IMHO, just keep them small. (new)&#39;, &#39;I surely don&amp;#x27;t miss locked files and having to have projects with gazillion files that reflect team structure instead of what is the best logical way to solve problem X. (new)&#39;, &#39;I just read this as an argument for tiny incremental changes and very short-lived branches. This can work well for a team that is very highly engaged and where Code Reviews get immediate attention. When I&amp;#x27;ve worked for startups, I&amp;#x27;ve seen this kind of usage out of git and it can be quite effective (no branches alive for more than a couple days + frequent rebasing in of upstream changes from main&amp;#x2F;master).Long-lived, all-encompassing feature branches are definitely an anti-pattern and they bit-rot unbelievably quickly, especially as team size grows. Some shops I&amp;#x27;ve worked in still prefer them, though, because they demand zero dead code paths or half-baked features making it into the mainline (which are definitely their own risk of technical debt).&#39;, &#39;I&amp;#x27;m fine with both, I&amp;#x27;ve seen both trunk-based (with SVN) and branch-based (with Git) models work.Due to git&amp;#x27;s &amp;#x27;multiple histories&amp;#x27; it&amp;#x27;s quickly becoming a mess when many people are on the same branch, that&amp;#x27;s why I prefer to use a branch-model in git where only one person is on a short-lived branch, and a team uses PRs&amp;#x2F;MRs into a common target branch to create a clean, shared, linear history. This target branch doesn&amp;#x27;t have to be the main branch, but can itself be a (bigger) feature branch which then is eventually merged into the main branch (key is to not diverge too much from the main branch though, so that merging back doesn&amp;#x27;t become a hassle).&#39;, &#39;It takes a mature and disciplined team to use TBD and these teams are few and far between. Every developer you add to your team (or department) increases the risk that someone is going to miss a test, or an edge case and ultimately break the build and blocks everyone.For me short lived branches that get merged into main dependant on passing tests and maybe a PR is by far the easiest, most reliable, and most common approach.For many of the reasons listed, I do use TBD for my side projects. Push it to main, tested, built and deployed. Easy. :)&#39;, &#39;People ought not express an opinion on this unless they&amp;#x27;ve tried both professionally.Git doesn&amp;#x27;t have great support for trunk-based development. Gerrit tries to paper over the gaps, but the git client isn&amp;#x27;t great. git-branchless or another plugin is needed for better support.&#39;, &#39;I don&amp;#x27;t think the author understand how one is supposed to use branches and DVCS. It also compares an &amp;quot;ideal&amp;quot; situation of &amp;quot;trunk-development&amp;quot; with the worst usage of branches. Those unfortunate enough to have worked with CVS&amp;#x2F;SVN on a single trunk know that the ideal just does not happen and that by 2023 we know what not to do with branches (and it is perfectly realistic to avoid such mistakes).&amp;gt; In the branching model, large and infrequent merges can introduce bugs that are hard to identify and resolve due to the sheer size of the changes.You are not supposed to have branches that diverge too much, and if you do, what&amp;#x27;s stopping you in a centralized VCS from doing the same? I.e. having a large local changes that you did not upload back to the server. It actually makes the problem worse.&amp;gt; In contrast, the branching model encourages developers to create separate branches for every feature, bug fix, or enhancement.It seems the author suggesting not only a reversion the centralized VCS days but also to do it with just a trunk branch, where either each commit is made to the trunk right away (so it must be right on the first try) or you pile uncommitted changes locally.Using a DVCS and committing to the local version of the `master` branch already counts as having a branched model, except more limited.&amp;gt; In a trunk-based model, continuous integration becomes more straightforward because your code is committed frequently to trunk, and that&amp;#x27;s the branch your CI environment is running the build and tests on.You can run CI and test in any branch you want, and you can rebase prior to running the tests. It is not a big deal.&#39;, &#39;This really means every commit goes to the main branch... and if on a dvcs like git, gets immediately pushed too?One thing that occurs to me is that probably requires more intention and discipline into how your commits are divided up, what makes a commit?  I guess you have to run tests and ensure green before committing, for one thing? But also I&amp;#x27;d guess in general probably waiting to commit until it&amp;#x27;s a larger unit&amp;#x2F;feature than otherwise?  But I&amp;#x27;m guessing. I&amp;#x27;m curious what people who use this method have to say about how they decide when to make a commit and what it should contain.  And how that effects their experience.If I&amp;#x27;m understanding correctly what is being described. (new)&#39;, &#39;The biggest advantage I see of branch based development is that you land a single fix&amp;#x2F;feature with one merge commit. This makes it relatively easy to revert a change if necessary as it&amp;#x27;s more or less an atomic change. (new)&#39;, &#39;&amp;gt;I prefer trunk-based developmentI am devoted to fridge based development. Whenever I have something harder to solve, I open the fridge and eat something. That seems to help my thought process.&#39;, &#39;Wikipedia link does not work\nI see a lot of claims in your article without any examples etc. to prove these claims.It&amp;#x27;s hard for me to distinguish what is factual and what is &amp;quot;only&amp;quot; evangelism ... Additionally it&amp;#x27;s probably a lack of knowledge on my side, since I only worked with git. So examples would be very helpful to make this topic more accessable. (new)&#39;, &#39;Yes, this doesn&amp;#x27;t get talked about enough, however, I understand how discussion can get polarising: Some downsides of feature branches can be mitigated. Make CI do a merge before running tests, failing the test if there are conflicts. If you split your teams well, you may not need to ship work in big long running branches. Some of it also comes down to discipline.Objectively the continuous integration model wins in my opinion, but the feature branch thing we&amp;#x27;ve ended up with seems to work well in many general cases. I think as with many programming related phenomena it seems to largely depends on human factors. (new)&#39;, &#39;Here&amp;#x27;s a nice article from the VSTS team at Microsoft on trunk-based development - https:&amp;#x2F;&amp;#x2F;devblogs.microsoft.com&amp;#x2F;devops&amp;#x2F;release-flow-how-we-do...This is basically what I do on all of my projects and have put this into place in a couple of companies that I have worked at. Haven&amp;#x27;t encountered any serious issues and it has offloaded some big problems related to the gitflow madness that preceded it.&#39;, &#39;I have worked in pre-git environments extensively, and I can say that I hated every minute of it.Branches are great. Pushing branches is great. People rebasing is a good thing. Committing as much as you need to is great, and lets me diff when I mess up.If I couldn&amp;#x27;t commit till I was &amp;quot;done&amp;quot; because we&amp;#x27;re all working off main, like I had to do in the past, oh man were there gonna be merge conflicts. I&amp;#x27;ve had projects where we spent a week on merge conflicts alone. I have never, in 14 years of using DVCS had anything even remotely close to that. (new)&#39;, &#39;Some people use long-lived branches in essentially the same way as short-lived branches function in TBD. Multiple sibling comments talk about merging in commits from main into their long-lived dev or QA branch multiple times a day, but this seems not really that different from just briefly branching from main when you need to do some work.&#39;]</td><td class="s11" dir="ltr">[&#39;Commit frequently (daily)&#39;, &#39;Make small, frequent commits&#39;, &#39;Use short-lived branches&#39;, &#39;Squashing commits into logical units&#39;, &#39;Rebase before merge&#39;, &#39;Trunk always ready for release&#39;, &#39;Automated build and tests always pass on the CI&#39;, &#39;Promote frequent and rapid integration (CI) (+)&#39;, &#39;Enable fast and continuous feedback (+)&#39;, &#39;Enforce discipline for stable builds and testing&#39;, &#39;Use feature flags to safely integrate incomplete features&#39;, &#39;Use a single shared trunk&#39;, &#39;Avoid big-bang merges&#39;, &#39;Reduce merge conflicts (+)&#39;, &#39;Mandatory code review policy&#39;]</td></tr><tr style="height: 30px"><th id="918362267R7" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">8</div></th><td class="s2" dir="ltr">Show HN: Simple Git Workflow for Effective Teams</td><td class="s3" dir="ltr">35849995</td><td class="s4" dir="ltr"><a target="_blank" href="https://www.trunkflow.com/">https://www.trunkflow.com/</a></td><td class="s5" dir="ltr">YANLIŞ</td><td class="s2" dir="ltr">[&#39;Show HN: Simple Git Workflow for Effective Teams (new)&#39;, &#39;Hi HN,My friends and I worked at Meta &amp;amp; Google. Once we’d left we realised a lot of the internal tooling didn’t have parity on the outside. Specifically, version control tools outside big tech are much harder to use than Google’s Critique and Facebook’s Phabricator, etc.Git is powerful but notoriously difficult to use [0]. Existing Git clients don’t make life much easier, exposing all the complexity by default. In practice we don’t need an equally complex GUI, and version control can be much easier to use.In our experience, it works best to expose a small number of features for an efficient workflow: commit, submit changes for review, and rebase (those are actively used in trunk-based development). Further, a “tree of commits” is a sufficient mental model, there’s no need to worry about branches, merges, etc.We have built a simple prototype called TrunkFlow that works inside Visual Studio Code. It borrows UI from Sapling (which is similar to internal tooling at Meta) but is fully compatible with Git.Would appreciate any feedback on the prototype [1] or on the challenges you’ve had using Git![0]: https:&amp;#x2F;&amp;#x2F;news.ycombinator.com&amp;#x2F;item?id=25121416[1]: https:&amp;#x2F;&amp;#x2F;www.trunkflow.com&amp;#x2F;&#39;]</td><td class="s6" dir="ltr">[&#39;Commit frequently (daily)&#39;, &#39;Rebase before merge&#39;, &#39;Simplifies the development workflow (+)&#39;, &#39;Use a single shared trunk&#39;]</td></tr><tr style="height: 30px"><th id="918362267R8" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">9</div></th><td class="s7" dir="ltr">The Origins of Trunk Based Development</td><td class="s8" dir="ltr">10959925</td><td class="s9" dir="ltr"><a target="_blank" href="http://paulhammant.com/2015/04/23/the-origins-of-trunk-based-development/">http://paulhammant.com/2015/04/23/the-origins-of-trunk-based-development/</a></td><td class="s10" dir="ltr">YANLIŞ</td><td class="s7" dir="ltr">[&#39;The Origins of Trunk Based Development&#39;, &#39;I think it would be useful if IDEs allowed a team to share when multiple people are editing the same file at the same time.  And even get notified when such a change gets committed so you merge it right away.  And I don&amp;#x27;t mean just watching the repo.Sometimes two people are working separately on the same bug when they could be collaborating. Its also easier to merge changes one by one, instead of dealing with 10 at once.  And if a change is completely incompatible, its best to deal with that when the code is committed, not a week later.It would also be cool if there were chat integrated with that, with a history that gets linked when you commit so you can understand the context later. (new)&#39;, &#39;I&amp;#x27;ve worked with a few different branching styles, including:1. Feature branches that get merged into master via PR in GitHub2. Sprint branch, bug fix branch, and master3. Developers push directly to master (or if they really need a code review, push to a branch)So far I prefer 3 the most, then 1, and I hope I never have to do 2 again. 3 is fastest, and we write a lot of Go so many of the comments I would have made on a Python PR for example aren&amp;#x27;t necessary. (new)&#39;, &#39;This article is completely silent on QA. You have to be able to commit code that isn&amp;#x27;t finished so it can be reviewed and tested (as well as for disaster recovery), yet you don&amp;#x27;t want other people building on it because it might have severe problems. (new)&#39;, &#39;As far as I can remember a lot of Google folk used Git on top of the &amp;#x27;mega-trunk&amp;#x27;. Not sure though if this was or was not the majority. (new)&#39;]</td><td class="s11" dir="ltr">[&#39;Commit frequently (daily)&#39;, &#39;Reduce merge conflicts (+)&#39;, &#39;Encourage team collaboration and communication (+)&#39;, &#39;Promote frequent and rapid integration (CI) (+)&#39;, &#39;Simplifies the development workflow (+)&#39;, &#39;Use a single shared trunk&#39;, &#39;Integrate real-time collaborative editing and commit-linked chat to enhance context and coordination in trunk-based workflows (new)&#39;]</td></tr><tr style="height: 30px"><th id="918362267R9" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">10</div></th><td class="s2" dir="ltr">Isn&#39;t &quot;trunk based development&quot; just a complete crock of shit?</td><td class="s3" dir="ltr">43047136</td><td class="s4" dir="ltr"><a target="_blank" href="https://bucket.co/blog/trunk-based-development-crock-of-shit">https://bucket.co/blog/trunk-based-development-crock-of-shit</a></td><td class="s5" dir="ltr">YANLIŞ</td><td class="s2" dir="ltr">[&#39;Isn\&#39;t &quot;trunk based development&quot; just a complete crock of shit?&#39;, &#39;There really doesn&amp;#x27;t need to be a phrase to describe every case of &amp;#x27;doing nothing&amp;#x27; in some aspect. In this case, it&amp;#x27;s &amp;#x27;not compartmentalizing feature development&amp;#x27;. (new)&#39;, &#39;Dupe (7 points, 10 comments) https:&amp;#x2F;&amp;#x2F;news.ycombinator.com&amp;#x2F;item?id=43035628 (new)&#39;, &#39;Bit of a nothing article. It assumes the audience is unfamiliar with PRs from feature branches. (new)&#39;, &#39;I&amp;#x27;m stunned that Algorithm encourages people to choose between 2 sides on A Topic. (new)&#39;]</td><td class="s6" dir="ltr">[&#39;Cultural or organizational resistance is common (-)&#39;]</td></tr><tr style="height: 30px"><th id="918362267R10" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">11</div></th><td class="s7" dir="ltr">Minimum Viable Git for Trunk-Based Development</td><td class="s8" dir="ltr">33802251</td><td class="s9" dir="ltr"><a target="_blank" href="https://blog.trunk.io/minimum-viable-git-for-trunk-based-development-81a5da7a77a7">https://blog.trunk.io/minimum-viable-git-for-trunk-based-development-81a5da7a77a7</a></td><td class="s10" dir="ltr">YANLIŞ</td><td class="s7" dir="ltr">[&#39;Minimum Viable Git for Trunk-Based Development&#39;, &#39;This guy doesn&amp;#x27;t understand rebase. Rebase is an organizational tool. it&amp;#x27;s housekeeping for keeping your commits clean. One reason to learn how to do rebase is so that your feature branch is tidy so when you merge it to main, main itself is tidy. Another is that as you perform the exercise of cleaning up your commits you are performing code review, something that, up until this point, you&amp;#x27;ve just been throwing at your co-worker without much thought as soon as all the tests pass.&amp;quot;But my feature branch gets squashed anyway&amp;quot;1. I believe that in itself is a mistake, especially as feature branches get large and, though you say you&amp;#x27;re all for small feature branches, your commit history says you do something different.2. You don&amp;#x27;t clean up that giant merge commit message with all those &amp;quot;WIP&amp;quot; &amp;quot;fixed stupid mistake&amp;quot; comments in there.Use rebase to keep your workspace clean and main&amp;#x2F;master comprehensible to your colleagues. (new)&#39;, &#39;I finally understand why some people are so against rebase. They&amp;#x27;re doing it wrong.I&amp;#x27;ve always heard people talk about how it doesn&amp;#x27;t scale, but I use rebase like 99% of the time, and have worked on projects with hundreds of ICs. This is the first time I&amp;#x27;ve seen someone explain it in a way where I get it. NO I&amp;#x27;M NOT FORCE PUSHING TO MAIN YOU SILLY NILLY! Turns out I&amp;#x27;m &amp;quot;squash rebasing.&amp;quot; I guess I didn&amp;#x27;t know I need to specify that.I do it slightly differently tough. I use git commit --amend to build up a single commit as I go.    git checkout -b blah-feature\n\n    # do some work\n\n    git commit -m &amp;quot;Main description of my feature&amp;quot;\n\n    # do more work\n\n    # no -m, and then I just add bullet points for each subsequent change in vim (example below)\n    git commit --amend\n\n\nThen, once I&amp;#x27;m ready to make a PR I do the following:    # pulls from remote without merging\n    git fetch origin main \n\n    # adds my single commit to the end of the current main\n    git rebase main\n\n    # push up feature branch for code review\n    git push\n\n    # get yelled at about --set-upstream, and copy&amp;#x2F;paste that command :-)\n\n\nMy commit messages typically look like:    Add some new feature\n\n    - do some sub task\n    - do another sub task\n    - ... (new)&#39;, &#39;&amp;gt; git add -A .&amp;gt; Add everything I’m working on (new and edited files).Bad idea. Extraneous cruft that isn&amp;#x27;t caught by .gitignore will leak into the repo. Always run git diff and git status first to see what you are about to add. (new)&#39;, &#39;&amp;gt; you need to re-clone from scratch — even if you did nothing wrong.I don&amp;#x27;t think you will need to reclone if did nothing wrong. You can always use `git reset --hard origin&amp;#x2F;...`, and if that does not work the you definitely did something wrong.&amp;gt; But in Linus’s own words, Git is “the information manager from hell.”That git is not the same git we have today, and it was handed over to another person quite early in the development. Although I agree that git ux is sometimes confusing.&amp;gt; Limit your Git actions ... for peak Git efficiencyI pretty much disagree, if I can give my two cents, read the manual. Git have some really handy tooling that can help with non-git issue (e.g.: `git bisect`). Limiting your knowledge brings no benefit.I like some point of the text, but overall I don&amp;#x27;t like the premise. it exaggerate a lot a problem to prove a point. (new)&#39;, &#39;I&amp;#x27;ll always be a rebase diehard, but the core message here is great. If you have to do more than a little bit of git surgery, you&amp;#x27;re probably doing something else wrong. (new)&#39;, &#39;Without rebasing, tools for managing PRs might show the merged mainline commits in the PR.Some times they are described as such “merged master into feature” and can be avoided if you review the PR per commit. But more often I want to review the PR as a whole, and then the tool fails to show a good diff of what’s actually developed in the PR. This to me is a much larger problem than the log pollution, which can be solved by squashing.Other than that (missing the bigger reason for rebase and focusing on a lesser argument in my opinion) I quite agree with the article. (new)&#39;, &#39;Clicking through a self-link in the article https:&amp;#x2F;&amp;#x2F;blog.trunk.io&amp;#x2F;git-commit-messages-are-useless-c2f3c4... we read:&amp;gt; This isn’t grade school, you don’t have to show your work\nAs you become an efficient engineer, the path you took to get to the final state of a pull request becomes far less important — and is academically interesting at best. You shouldn’t have to show your work like you did in school. Land the feature or bug and move on to the next one. The code speaks for itself (alongside some judiciously placed comments).&amp;gt; Having granular annotations of all your work is unnecessary, ...This premise underlies the particular workflow that the posted article assumes, and all the described command+option incantations are directed to it.But there is another, very different git workflow used by a project we&amp;#x27;ve all heard of, and that is the Linux kernel core code.  The trunk.io workflow is unsuitable for Linux due to different requirements.  Some of which being:1. Commitment to support for indefinite future.2. Large, complex feature PRs.3. Human review of PRs, by maintainers fully empowered to reject.4. A low-level programming language, in which subtle bugs are easily introduced.Also different luxuries:1. Willingness to put off merge of a &amp;quot;hot&amp;quot; new feature indefinitely.So, kernel PRs are structured as a linear series of numbered patches meeting the requirement that each step along the way compile cleanly.  This is primarily to ease the task of the maintainer responsible for the subsystem involved, and who will have deal with the fallout of bugs introduced by the PR.  Example:https:&amp;#x2F;&amp;#x2F;lore.kernel.org&amp;#x2F;rcu&amp;#x2F;Credential: I have written code for the Linux kernel core, and it was merged, and it was buggy. (new)&#39;, &#39;&amp;gt; git push origin&amp;gt; Push my code to the remote; likely spinning up lots of machines in CI to check my work.That&amp;#x27;s a good callout; something that I have noticed I frequently miss when iterating on my code is the cost of the CI&amp;#x2F;CD systems already set up. It&amp;#x27;s something to consider especially when iterating using a system like Sapling for Stacked PRs; each individual PR push may update a chain which causes a lot of wasted CI&amp;#x2F;CD time. (new)&#39;, &#39;&amp;gt; The easiest practice to implement for peak Git efficiency is to stick to a subset of commandsThis has been my experience as well.Great article, thanks! I&amp;#x27;ve been using essentially this same subset of commands for many years, and it&amp;#x27;s worked extremely well for me: does everything I need&amp;#x2F;my team needs, and avoids complication. I&amp;#x27;m glad to have this as a reference I can point people to when they ask for git advice. (new)&#39;, &#39;How does this guy run a developer tools company called “trunk” and yet doesn’t understand rebase? Talk about killing credibility… (new)&#39;, &#39;I agree; maybe when git was new and actually being used in a decentralized fashion some of the more advanced operations were necessary. But with the typical checkout&amp;#x2F;branch&amp;#x2F;PR&amp;#x2F;merge flow from GitHub and others, I rarely need anything but git merge (with squash merging when merging a pr) (new)&#39;, &#39;Nice! Maybe someone should create an opinionated git front-end to enforce some of these patterns on a team.The irony, IMO, is that Linus prefers C to C++ exactly because C++ gives developers too much rope. (new)&#39;, &#39;I&amp;#x27;m a huge fan of squash rebase, myself. really it&amp;#x27;s my default, and I find it particularly useful for long run branches. (new)&#39;, &#39;I personally am a proponent of rebase, but not all the time and not for every workflow. It has it&amp;#x27;s place though, IMO. I like&amp;#x2F;value clean history and good commit messages (although I admit I don&amp;#x27;t always succeeding providing that all of the time). I prefer to stage my commit pieces at the hunk level at the largest. I like to rebase my branches before merging them into release or main (depending on git strategy as a whole), but it isn&amp;#x27;t always necessary. I use interactive rebase from time to time to clean up my feature branches (especially longer running ones). This is all stuff I prefer in my own workflow.That said, every time I try to really teach someone rebase, particularly a new dev, I understand why people shy away from it. I did for a very long time. So I totally understand and get why the above style workflow may terrify folks (or just seem unnecessary). It is easy to mess up and there are a lot of little gotchas if someone isn&amp;#x27;t careful. And worst of all, it can result in lost work (although even that is &amp;quot;usually&amp;quot; recoverable, but not always). I do think there are some benefits to it, and I think it is something that can be integrated into a dev&amp;#x27;s workflow a bit at a time. And it really doesn&amp;#x27;t take significantly more time, in my experience.I&amp;#x27;m not gonna argue here for adopting that. Except for &amp;quot;no commit messages&amp;quot;, I&amp;#x27;d be pretty ok with a workflow as outlined by this post. I do think folks should understand how rebase works, what commits will be moved&amp;#x2F;changed when they run a rebase (this is vital), and how to recover when a rebase goes bad (no, not reclone, not generally even delete branch and check it out again)..Couple random thoughts I try to communicate to folks who decide to utilize rebase more in their workflow:- rebase often (if main updates often)- if worried the rebase may be messy, create a temporary branch prior to starting the rebase at the feature branch HEAD - allows for an easy way back (and prevents lost code)- don&amp;#x27;t rebase shared branches - this is a tool to use PRIOR to &amp;quot;sharing&amp;quot; (i.e. pushing) code- squash&amp;#x2F;clean up unneeded commits before rebasing on another branch (this may bring it all the way down to a single commit, but for larger features, I think there is value in seeing the main decision points along the way)- fix conflicts with the code at the specific commit you are on only, don&amp;#x27;t fix it with the eventual end result X commits down the line - this will generally avoid the dreaded &amp;quot;fix the same conflict over and over for each commit&amp;quot; problem some people encounter with rebasing- remember rebase creates new history - it doesn&amp;#x27;t rewrite history (however, old commits will eventually be garbage collected)- pro tip: understand how `rebase --onto` works, sometimes you shouldn&amp;#x27;t, or at least don&amp;#x27;t want to, take all of the commits (new)&#39;]</td><td class="s11" dir="ltr">[&#39;Rebase before merge&#39;, &#39;Squashing commits into logical units&#39;, &#39;Use short-lived branches&#39;, &#39;Make small, frequent commits&#39;, &#39;Simplifies the development workflow (+)&#39;, &#39;Promote frequent and rapid integration (CI) (+)&#39;, &#39;Reduce merge conflicts (+)&#39;, &#39;Maintain traceability and code history&#39;]</td></tr><tr style="height: 30px"><th id="918362267R11" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">12</div></th><td class="s2" dir="ltr">The Origins of Trunk Based Development</td><td class="s3" dir="ltr">10959925</td><td class="s4" dir="ltr"><a target="_blank" href="http://paulhammant.com/2015/04/23/the-origins-of-trunk-based-development/">http://paulhammant.com/2015/04/23/the-origins-of-trunk-based-development/</a></td><td class="s5" dir="ltr">YANLIŞ</td><td class="s2" dir="ltr">[&#39;The Origins of Trunk Based Development&#39;, &#39;I think it would be useful if IDEs allowed a team to share when multiple people are editing the same file at the same time.  And even get notified when such a change gets committed so you merge it right away.  And I don&amp;#x27;t mean just watching the repo.Sometimes two people are working separately on the same bug when they could be collaborating. Its also easier to merge changes one by one, instead of dealing with 10 at once.  And if a change is completely incompatible, its best to deal with that when the code is committed, not a week later.It would also be cool if there were chat integrated with that, with a history that gets linked when you commit so you can understand the context later. (new)&#39;, &#39;I&amp;#x27;ve worked with a few different branching styles, including:1. Feature branches that get merged into master via PR in GitHub2. Sprint branch, bug fix branch, and master3. Developers push directly to master (or if they really need a code review, push to a branch)So far I prefer 3 the most, then 1, and I hope I never have to do 2 again. 3 is fastest, and we write a lot of Go so many of the comments I would have made on a Python PR for example aren&amp;#x27;t necessary. (new)&#39;, &#39;This article is completely silent on QA. You have to be able to commit code that isn&amp;#x27;t finished so it can be reviewed and tested (as well as for disaster recovery), yet you don&amp;#x27;t want other people building on it because it might have severe problems. (new)&#39;, &#39;As far as I can remember a lot of Google folk used Git on top of the &amp;#x27;mega-trunk&amp;#x27;. Not sure though if this was or was not the majority. (new)&#39;]</td><td class="s6" dir="ltr">[&#39;Reduce merge conflicts (+)&#39;, &#39;Encourage team collaboration and communication (+)&#39;, &#39;Make small, frequent commits&#39;, &#39;Commit frequently (daily)&#39;, &#39;Promote shared or collective code ownership&#39;, &#39;Use a single shared trunk&#39;, &#39;Integrate collaborative editing notifications and chat history into commit workflow for enhanced context and coordination in trunk-based teams (new)&#39;]</td></tr><tr style="height: 30px"><th id="918362267R12" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">13</div></th><td class="s7" dir="ltr">Trunk-based version control, is new?</td><td class="s8" dir="ltr">29491525</td><td class="s9" dir="ltr"><a target="_blank" href="https://www.atlassian.com/continuous-delivery/continuous-integration/trunk-based-development">https://www.atlassian.com/continuous-delivery/continuous-integration/trunk-based-development</a></td><td class="s10" dir="ltr">YANLIŞ</td><td class="s7" dir="ltr">[&#39;Trunk-based version control, is new?&#39;, &#39;I saw this and can&amp;#x27;t believe it...Is this article really saying that Gitflow was popularized before Trunk based version control?A related article said:&amp;quot;Gitflow is a legacy Git workflow that was originally a disruptive and novel strategy for managing Git branches. Gitflow has fallen in popularity in favor of trunk-based workflows, which are now considered best practices for modern continuous software development and DevOps practices. Gitflow also can be challenging to use with CI&amp;#x2F;CD. This post details Gitflow for historical purposes.&amp;quot; [1]What!?!?[1] https:&amp;#x2F;&amp;#x2F;www.atlassian.com&amp;#x2F;git&amp;#x2F;tutorials&amp;#x2F;comparing-workflows&amp;#x2F;...&#39;]</td><td class="s11" dir="ltr">[&#39;Simplifies the development workflow (+)&#39;, &#39;Promote frequent and rapid integration (CI) (+)&#39;, &#39;Accelerate release cycles (+)&#39;]</td></tr><tr style="height: 30px"><th id="918362267R13" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">14</div></th><td class="s2" dir="ltr">Ask HN: Git Workflow – Branching</td><td class="s3" dir="ltr">26386966</td><td class="s4" dir="ltr"><a target="_blank" href="https://news.ycombinator.com/item?id=26386966">https://news.ycombinator.com/item?id=26386966</a></td><td class="s5" dir="ltr">YANLIŞ</td><td class="s2" dir="ltr">[&#39;Ask HN: Git Workflow – Branching (new)&#39;, &#39;A debate is forming in my organization between GitFlow (https:&amp;#x2F;&amp;#x2F;www.atlassian.com&amp;#x2F;git&amp;#x2F;tutorials&amp;#x2F;comparing-workflows&amp;#x2F;gitflow-workflow) and Trunk-Based Development (https:&amp;#x2F;&amp;#x2F;trunkbaseddevelopment.com&amp;#x2F;). Different teams are using different approaches. Some teams are advocating for the simplicity of Trunk-Based Development while others are advocating for the flexibility of GitFlow.What does the HN community think? Which workflow do you prefer?&#39;]</td><td class="s6" dir="ltr">[&#39;Simplifies the development workflow (+)&#39;]</td></tr><tr style="height: 30px"><th id="918362267R14" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">15</div></th><td class="s7" dir="ltr">The Benefits of Trunk-Based Development</td><td class="s8" dir="ltr">44635175</td><td class="s9" dir="ltr"><a target="_blank" href="https://thinkinglabs.io/articles/2025/07/21/on-the-benefits-of-trunk-based-development.html">https://thinkinglabs.io/articles/2025/07/21/on-the-benefits-of-trunk-based-development.html</a></td><td class="s10" dir="ltr">YANLIŞ</td><td class="s7" dir="ltr">[&#39;The Benefits of Trunk-Based Development&#39;, &#39;It&amp;#x27;s basically the only way I&amp;#x27;ve ever worked, and clients (eg in investment banking) kept hiring me!  Trunk&amp;#x2F;main should always be just about prod-ready; take staging&amp;#x2F;prod branches to prove that and do any final tweaks. (new)&#39;]</td><td class="s11" dir="ltr">[&#39;Trunk always ready for release&#39;, &#39;Use a single shared trunk&#39;, &#39;Use temporary release branches&#39;, &#39;Trunk always ready for release&#39;, &#39;Simplifies the development workflow (+)&#39;]</td></tr><tr style="height: 30px"><th id="918362267R15" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">16</div></th><td class="s2" dir="ltr">Full AI-Based Workflow</td><td class="s3" dir="ltr">44520090</td><td class="s4" dir="ltr"><a target="_blank" href="https://news.ycombinator.com/item?id=44520090">https://news.ycombinator.com/item?id=44520090</a></td><td class="s5" dir="ltr">YANLIŞ</td><td class="s2" dir="ltr">[&#39;Full AI-Based Workflow (new)&#39;, &#39;So I just built a system that on pre-push, watch changes to GH actions using CLI and feed errors to Claude. I am cloning the repo in 5 separate editors with a prompt that makes it develop, commit and push working code at all times. It leans heavily on static analysis and linting with Biome to ensure maximum correctness and strong guidelines for testing.Repository is a monorepo which has cohesive services that can be developed independently. Trunk-Based development and changes go straight to production (there&amp;#x27;s a post-deploy check that runs smoke tests)I&amp;#x27;m not sure if anyone else has built something like this, but essentially I can &amp;quot;git clone&amp;quot; a new version of the repository in a different folder and literally multiply myself by just spending a couple minutes creating a prompt99% of the Job is designing prompts and adjusting the pieces to be independent so I can fit in the recent part of the context windowWHAT THE ACTUAL FUCK?&#39;, &#39;I have 3 agents working at all times but can be more, until I reach the Claude 5x limits that resets every 5 hours. I am seriously considering Claude 20x.. (new)&#39;, &#39;Cmon friend, show us some code, do not hide it, otherwise it&amp;#x27;s just a 0 evidence post to fuel the hype (new)&#39;]</td><td class="s6" dir="ltr">[&#39;Trunk-Based Development is often unrealistic in open-source projects, where async collaboration, longer feature branches, minimal feature flag use, and community-driven reviews make daily main-branch merges impractical.&#39;, &#39;Automate code quality checks (linting, testing, analysis)&#39;, &#39;Automate test execution (unit, integration, e2e)&#39;, &#39;Deploy frequently and provide fast feedback&#39;, &#39;Enable fast and continuous feedback (+)&#39;, &#39;Promote frequent and rapid integration (CI) (+)&#39;, &#39;Shortens automated feedback cycles by testing each trunk commit against the main codebase through CI/CD pipelines (+).&#39;, &#39;Simplifies the development workflow (+)&#39;, &#39;Use a single shared trunk&#39;, &#39;Leverage AI agents to automate development tasks and maintain trunk stability in Trunk-Based Development (new)&#39;]</td></tr><tr style="height: 30px"><th id="918362267R16" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">17</div></th><td class="s7" dir="ltr">Am I doing the right choice?</td><td class="s8" dir="ltr">39402102</td><td class="s9" dir="ltr"><a target="_blank" href="https://news.ycombinator.com/item?id=39402102">https://news.ycombinator.com/item?id=39402102</a></td><td class="s10" dir="ltr">YANLIŞ</td><td class="s7" dir="ltr">[&#39;Am I doing the right choice? (new)&#39;, &#39;I am going to do research on Incremental Learning on September 2024 at Northwestern Polytechnical University, Xi&amp;#x27;an, China.As of right now, I am working as Angular Developer, Senior Associate.I was tasked to refactor 2 feature, checkout and experience.The checkout refactoring went fine until I started to invite 2 person to work together. In short, 1 person invite basically everyone else, there is no code review and I suddenly lose control how the checkout refactoring should be done. At that point, I started to create the Google Doc.I want this to not happen next time and the experience refactoring is about to start next week.I deliberately created new repository with a `poc` folder, `experience` application and write 30 pages of Google Doc about the new change, which is:1. Trunk based development.2. Feature Flag policy.3. Pull Request policy.4. Semantic versioning policy.5. Why we should use Angular 17.6. Why we should create new repository.7. Session Cookie proof of concept.8. dependabot proof of concept.9. Clean Architecture.10. Vertical development.I set up a technical meeting, include my SPV, and the CEO to push the experience refactor forward.I work overtime almost everyday.Anyway, they paid my salary 6 days late and have not paid the 10% social security fund. And no overtime pay.I got approached by other companies:1. freelance, work from home, for Indonesian who currently live in Australia.2. full time, work from office in Jakarta.3. full time, work from office in Jakarta.4. full time, work from office in Jakarta.5. full time, work from office in Osaka.and the pay is much higher than my current job.I also work part time to create a website for the ministry of health.I am thinking to resign, to start over and to start study Incremental Learning before September 2024.I really want to say to myself &amp;quot;one more day&amp;quot;. But, I am afraid everything will fall apart if I do not resign and focus on 1 thing.I should have taken it slowly.I am overwhelmed.&#39;, &#39;Some good advice I received about 25 years ago, &amp;quot;always look after your long-term interests&amp;quot;.There are a lot of topics mixed together, basically today&amp;#x27;s problems (which sound like they can be solved by having a single maintainer who can commit topic branches prepared by others when they pass review) and what to change to.  It&amp;#x27;s good to change jobs in this business.Coming from China, value of the choices seems highest for Osaka, but you don&amp;#x27;t mention the kind of work or employer so who knows.  You can also expect some hopefully minor difficulties if you&amp;#x27;re Chinese and espectially if you don&amp;#x27;t have any Japanese.  But if it looks the best in your resume, it may be worth the effort. (new)&#39;]</td><td class="s11" dir="ltr">[&#39;Trunk-Based Development is often unrealistic in open-source projects, where async collaboration, longer feature branches, minimal feature flag use, and community-driven reviews make daily main-branch merges impractical.&#39;, &#39;Use feature flags to safely integrate incomplete features&#39;, &#39;Mandatory code review policy&#39;, &#39;Use a single shared trunk&#39;]</td></tr><tr style="height: 30px"><th id="918362267R17" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">18</div></th><td class="s2" dir="ltr">Ask HN: Strategy for Choosing PRs to Combine</td><td class="s3" dir="ltr">35909656</td><td class="s4" dir="ltr"><a target="_blank" href="https://news.ycombinator.com/item?id=35909656">https://news.ycombinator.com/item?id=35909656</a></td><td class="s5" dir="ltr">YANLIŞ</td><td class="s2" dir="ltr">[&#39;Ask HN: Strategy for Choosing PRs to Combine (new)&#39;, &#39;Env: git monorepo 10 million lines lots eg. 10s of PRs per day. Validation est 90-120mins per PRGoal: validate PRs fast so release manager can approve them to close PRAsk: rather than some Jenkins job taking PRs one at time for validation, need a strategy to pick several candidate PRs I can combine and validate together perhaps based on disjointedness of change setMy previous job had zillions of very small repos eg one task, lib. Here running PRs in order is effective, obvious. Each repo had an owner so changes were a bit more parallel. Of course it means building code is somewhat harder because dependencies must be found and combined. Dpkg helped a lot thereMonorepo is the opposite. All the code is in one trunk. It either builds and validates with PR or no. However, there&amp;#x27;s now more to build and validate and it&amp;#x27;s no longer obvious which PRs should be considered for a validation run. Sequential processing of today&amp;#x27;s PRs could run into tomorrow creating an ever increasing backlog.I want to focus on PR selection. Making the validation faster say through bazel which can better exclude sub validation steps for files that haven&amp;#x27;t changed, is something we will do regardless (new)&#39;, &#39;You should only build the parts that changed in a PR. I manage this process for a monorepo on Jenkins. We keep each PR separate, and given the complexities we already manage, I would not advise merging PRs, it will only make things more confusing for people trying to understand why a build fails.Why are you builds and PRs not being processed in parallel? (new)&#39;, &#39;What we do for the repo I work on is just optimistically assume everything will work together and then do binary search when something breaks and have a bot issue a rollback once the offending commit is found (sending an email to the committer). (new)&#39;]</td><td class="s6" dir="ltr">[&#39;Use a single shared trunk&#39;, &#39;Automate test execution (unit, integration, e2e)&#39;, &#39;Automated build and tests always pass on the CI&#39;, &#39;Enable fast and continuous feedback (+)&#39;, &#39;Promote frequent and rapid integration (CI) (+)&#39;, &#39;Simplifies the development workflow (+)&#39;, &#39;Support safe experimentation and rollback&#39;, &#39;Optimize PR validation by combining disjoint PRs for batch validation in monorepos (new)&#39;]</td></tr><tr style="height: 30px"><th id="918362267R18" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">19</div></th><td class="s7" dir="ltr">Ask HN: Is anyone using lock-based version control?</td><td class="s8" dir="ltr">30677483</td><td class="s9" dir="ltr"><a target="_blank" href="https://news.ycombinator.com/item?id=30677483">https://news.ycombinator.com/item?id=30677483</a></td><td class="s10" dir="ltr">YANLIŞ</td><td class="s7" dir="ltr">[&#39;Ask HN: Is anyone using lock-based version control? (new)&#39;, &#39;Hi all,I am just curious if anyone is using any lock-based approaches to version control for collaborative production of software or other digital assets. It seems like the merge model, exemplified by Git, is ubiquitous to the point that nobody is experimenting with any other workflows.I think lock-based version control would would very well with trunk-based development. Separate devs branch from mainline, files get locked for everyone else as they are edited, and so it is necessary to work in very tight iterations and merge back to mainline very frequently.Is anyone working with a lock-based approach to version control, either for personal projects, or in an organisational setting?Thanks :)&#39;, &#39;This would never work. If someone checked out a file, locked it, and then went on vacation, this would block everyone else. Imagine if some breaking bug was in the checked out file, now you have to find some admin to remove the lock. You could put a timer on the lock, but how would this be different from git?Perforce does trunk based development and checkouts involve talking to the server (depot). This allows you to see who else has a file checked out, but doesn&amp;#x27;t block you from editing. I have used Perforce for multiple years in a thousand+ developer org, and have never actually needed to see who else has a file checked out.&#39;, &#39;We still use Microsoft Visual Source Safe for some projects :)We have a main trunk, and a branch for each major version released, upon which we apply fixes and occasionally small feature updates as requested by customers.We’re a small team, so it works pretty well for us. We’ve worked this way for 15+ years. (new)&#39;, &#39;Yes, we use locking checkout in certain situations but not for traditional source code, more for CAD files or documents. It&amp;#x27;s a fairly rare situation, though, mostly helpful for non-coders that don&amp;#x27;t understand the concept of a merge. (new)&#39;, &#39;Not software development, but most CAD version control systems are lock based. You checkout your model or assembly, lock the parts&amp;#x2F;drawings&amp;#x2F;assembly you are working on and that prevents others from working on the same bit. Some allow a level of collaboration where two people can be working on different components within the same assembly at once.Most of these version control systems are part of a larger software package call a PLM system (Product Lifecycle Management) designed to help manage all aspects of product development from concept through to manufacturing.https:&amp;#x2F;&amp;#x2F;en.m.wikipedia.org&amp;#x2F;wiki&amp;#x2F;Product_lifecycle (new)&#39;, &#39;I used to work for a firm creating software for handling patient&amp;#x27;s data in hospitals. Mainly using Xenix, all software source was controlled via the Revision Control System, part of the OS. R.C.S allowed earlier versions of source to be generated easily, when required. All devs using R.C.S accepted it and used it easily, many times each day. (new)&#39;, &#39;Didn&amp;#x27;t we had the lock based model when a lot of software development was using svn earlier on?I also still experience it on Wiki edits, and for office document management systems.\nMy experience there is that it works for a tiny amount of users, but once you start hitting the lock things get painful. (new)&#39;, &#39;&amp;gt; exemplified by GitThe predecessors, SVN and CVS, also do not use a locked checkout model. The &amp;quot;C&amp;quot; in CVS is &amp;quot;concurrent&amp;quot;: people working at the same time in multiple checked-out sandboxes (of a central repo), picking up changes with &amp;quot;cvs up&amp;quot;, which merges.Nobody in their right mind used version control with central locking in the last 35 years. (new)&#39;]</td><td class="s11" dir="ltr">[&#39;Use a single shared trunk&#39;, &#39;Cherry-pick changes to release branches&#39;, &#39;Small team&#39;, &#39;Commit frequently (daily)&#39;, &#39;Use lock-based version control in conjunction with trunk-based development to enforce tight integration cycles (new)&#39;]</td></tr><tr style="height: 30px"><th id="918362267R19" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">20</div></th><td class="s2" dir="ltr">I love Trunk Based Development (or pushing straight to master)</td><td class="s3" dir="ltr">20608089</td><td class="s4" dir="ltr"><a target="_blank" href="https://medium.com/@mattia.battiston/why-i-love-trunk-based-development-641fcf0b94a0">https://medium.com/@mattia.battiston/why-i-love-trunk-based-development-641fcf0b94a0</a></td><td class="s5" dir="ltr">YANLIŞ</td><td class="s2" dir="ltr">[&#39;I love Trunk Based Development (or pushing straight to master)&#39;, &#39;I dont think that pair programming removes the need for an independent review of the code. 2 developers doesn&amp;#x27;t mean no bugs, and it can mean bugs^2 (new)&#39;]</td><td class="s6" dir="ltr">[&#39;Use a single shared trunk&#39;, &#39;Promote shared or collective code ownership&#39;]</td></tr><tr style="height: 30px"><th id="918362267R20" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">21</div></th><td class="s7" dir="ltr">Google&#39;s vs. Facebook&#39;s Trunk Based Development</td><td class="s8" dir="ltr">7035361</td><td class="s9" dir="ltr"><a target="_blank" href="http://paulhammant.com/2014/01/08/googles-vs-facebooks-trunk-based-development/">http://paulhammant.com/2014/01/08/googles-vs-facebooks-trunk-based-development/</a></td><td class="s10" dir="ltr">YANLIŞ</td><td class="s7" dir="ltr">[&quot;Google&#39;s vs. Facebook&#39;s Trunk Based Development&quot;, &#39;I have to say I struggle with advanced source control management and DVCS.Every time I have been in a development team that proposes anything more complicated than a basic branch, I start to break out in hot sweats.I think this has come from experiences where we have had multiple live branches and then got into a mess with merging, testing, incompatibilities, not having the right thing on the right branch etc.When it does all work, it feels more luck than judgement.I agree with a poster above that some of the teams that I have been on seem to spend massive amounts of time moving code between branches and accounting for it.  It feels like such a drag and a distraction that it&amp;#x27;s often not worth branching even for fairly substantial changes.I think I need to slice off a few days to really deepen my understanding of GIT or similar. (new)&#39;, &#39;The trouble is that VCS pain points are far from universal. Everyone has their own experience, for better or worse, and will have a view on what&amp;#x27;s important based on their personal experience (or lack of experience).In other words, arguing for a model (mainline or trunk) without first setting a context is pointless.For instance, consider the needs of a very large team versus a very small team. Consider a team that releases often versus a team that releases infrequently. Consider a team releasing multiple projects according to a roadmap versus a team releasing a single project on an ad hoc basis.The variations are many, and so too are the strategies for managing source code. (new)&#39;, &#39;It is not clear to me how&amp;quot;Trunk based development with tests and code-review pre-commit&amp;quot;is tangibly different from&amp;quot;Branch based development with tests and code-review pre-merge&amp;quot;The article talks a lot about trunk-based-development, but if you&amp;#x27;re doing any sort of checking before &amp;quot;commiting&amp;quot;, then don&amp;#x27;t you essentially have a short-lived branch?&#39;, &#39;This post puzzled me. I feel like it was missing an introductory paragraph with a thesis and summary of the two branching models. You have to read part way through the article (ignoring the confusing diagram) before this becomes apparent. (new)&#39;, &#39;I&amp;#x27;ve worked with a similar workflow in a number of places with SVN. It&amp;#x27;s horrible.These workflows which avoid branching, avoid merging, and avoid multiple services with separation of concerns are a product of the limitations of the SCM system. Too many times, the designers have praised their workflows for so perfectly utilizing the features of the chosen SCM system. They put the cart before the horse, and don&amp;#x27;t see that their workflow is an attempt to work around the places where the SCM falls short. (new)&#39;, &#39;Being reminded of an earlier article about how facebook contributed to Mercurial to optimize it[0] because their code base had become so large. Wouldn&amp;#x27;t it provide a much better flow if they built their system around separating things into packages and using a internal built (or smth like that) package manager to update etc? Making it much easier to divide things up into different repos instead of one giant one (which, quite frankly, seems like a terrible idea at this size).[0] https:&amp;#x2F;&amp;#x2F;code.facebook.com&amp;#x2F;posts&amp;#x2F;218678814984400&amp;#x2F;scaling-merc... (new)&#39;, &#39;Many people are so fond of what I call commit accounting that they spend more effort on all that branches, merges and rituals than on actually getting their code to work.One more reason to use trunk based development. Or SVN.&#39;, &#39;&amp;gt; Google have many [...] buildable and deployable things, which have very different release schedules. Facebook don’t as they substantially have the PHP web-app, and apps for iOS and Android in different repos.At least when I was there, the first sentence was true for Facebook. There was&amp;#x2F;is a separate repo for Thrift services (largely C++, but also Java, Python, and more), each Thrift service is a deployable. The deployables could be pushed at separate times and were usually pushed by teams themselves on their own schedules. The process was still frictionless and trunk-based: only difference was having to type a few well documented commands to push the service yourself. This may changed since, however.&#39;, &#39;A bit confusing article but it&amp;#x27;s very good anyway.Thanks! (new)&#39;, &#39;Though this is fascinating to read, basing your repository decisions on a ginormous company&amp;#x27;s requirements is not really useful. I have advocated trunk development everywhere I have worked and usually people come around to it. But 99.99% of people are not Google or Facebook sized. (new)&#39;, &#39;Given the known cultural emphasis on separation and redundancy at Amazon I&amp;#x27;m interested to know what their tooling and source code control implementations are. (new)&#39;, &#39;Given the known cultural emphasis on separation and redundancy at Amazon I&amp;#x27;m interested to know what their tooling and source code control implementations are. (new)&#39;]</td><td class="s11" dir="ltr">[&#39;Use a single shared trunk&#39;, &#39;Simplifies the development workflow (+)&#39;, &#39;Reduce merge conflicts (+)&#39;, &#39;Promote frequent and rapid integration (CI) (+)&#39;, &#39;Cultural or organizational resistance is common (-)&#39;, &#39;May be difficult for inexperienced developers (-)&#39;]</td></tr><tr style="height: 30px"><th id="918362267R21" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">22</div></th><td class="s2" dir="ltr">Trunk-Based Development</td><td class="s3" dir="ltr">42999413</td><td class="s4" dir="ltr"><a target="_blank" href="https://bucket.co/blog/trunk-based-development">https://bucket.co/blog/trunk-based-development</a></td><td class="s5" dir="ltr">YANLIŞ</td><td class="s2" dir="ltr">[&#39;Trunk-Based Development&#39;, &#39;This is content marketing for a feature flagging tool called “Bucket.” I’m a big fan of trunk-based development, although I prefer its original name: continuous integration. (Sadly, that name has been coopted by tool vendors.)A better alternative to feature flags is keystone interfaces. It’s very simple: build your new feature without wiring it up to the UI (or API). Test it using automated tests that bypass the UI. When it’s ready, wire it up, manually confirm that the automated tests didn’t miss anything, and release.&#39;, &#39;I am strongly opposed to feature flags and conditionals in the code, unless absolutely necessary. If you don&amp;#x27;t remove deprecated features&amp;#x2F;branches, your code will end up unmaintainable. If you do remove them, the removal is (in my experience) worse than dealing with merge conflicts. Version control is designed for the exact problem of having multiple implementations exist and merging them as needed. Why roll your own obtuse version control by having all branches in the same file simultaneously when you can just use git to have them exist in parallel universes?There&amp;#x27;s value in putting a newly completed feature behind a feature flag so you can turn it off instantly in prod. There is much less value in putting dozens of not-yet-functional features behind feature flags that shouldn&amp;#x27;t be turned on for the next several weeks&amp;#x2F;months (or maybe never). (new)&#39;, &#39;&amp;gt; On top of that, once you finally get a feature merged and deployed, it can often happen that there’s a bug causing users to have a poor experience. Since your new feature lives directly in the code, deactivating it requires rolling back the code you merged, building it, waiting for the tests to run, and redeploying the applicationWhy aren’t you using feature flags to gate new behavior&amp;#x2F;functionality? (new)&#39;, &#39;Everything old is new again:&amp;gt; Flickr is somewhat unique in that it uses a code repository with no branches; everything is checked into head, and head is pushed to production several times a day. This works well for bug fixes that we want to go out immediately, but presents a problem when we’re working on a new feature that takes several months to complete. How do we solve that problem? With flags and flippers!https:&amp;#x2F;&amp;#x2F;code.flickr.net&amp;#x2F;2009&amp;#x2F;12&amp;#x2F;02&amp;#x2F;flipping-out&amp;#x2F; (new)&#39;, &#39;&amp;gt; Trunk-based development is the seemingly radical idea of a team working together on the same code base at the same time.Seemingly radical, hm. I&amp;#x27;ve never worked any other way in 20+ years.&#39;, &#39;Every time this comes up it feels like two groups of people meet where one group either thought the other didn&amp;#x27;t exist or was much smaller than it really is. It&amp;#x27;s bizarre. (new)&#39;, &#39;I’m gonna be honest, this sounds horrible. If you do adopt this though, why even use Git? Why not use Perforce or something? (new)&#39;, &#39;Here is an article of how my team had accomplished this with GitHub actions I posted earlier: https:&amp;#x2F;&amp;#x2F;blog.gregweber.info&amp;#x2F;blog&amp;#x2F;github-actions-trunk-based-...&#39;, &#39;I&amp;#x27;d be interested to hear from anyone with substantial experience of trunk-based development who prefers a merge workflow, and can articulate why. Comments on TBD posts are usually either TBD enthusiasts, or people who have never used TBD and think it sounds stupid.&#39;, &#39;It is really sad that almost no modern code review tools support trunk-based development. Nearly all tools assume some kind of branching&amp;#x2F;pull request.One tool that was great for _both_ use cases was Jetbrains Upsource, where you could just string a bunch of related commits together in one review. Better yet, it could recognize based on the commit message (like workitem or CR number) that a commit belongs to the same code review and add it.We actually still use it, even though Jetbrains canned it, because we have found no good alternative. Some of the tools that do code review mandate to also host the code within it, which is not an option because we already host the code in a system we’re happy with.&#39;, &#39;After thinking about this for some time and weighing in with my 30 years of developer experience: don&amp;#x27;t do this. You will suffer.Branches are there for a reason, and they are light-weight enough that you can use them even in a solo project. Everything will be easier if you flow with the tool instead of trying to fight it like this. (new)&#39;, &#39;This looks horrible IMHO.I agree changes to main should be kept small. But not too small. They should be coherent &amp;#x27;chunks&amp;#x27; of functionality, even if they are not yet a fully working feature.Committing to a dedicated separate branch, quite apart from protecting against fat-finger commits etc, keeps everything together, allows for easy code review of a complete, coherent change, etc. (new)&#39;, &#39;It&amp;#x27;s things like this that make me fear we may have reached peak dev. (new)&#39;, &#39;I wonder how you code review a half implement feature. (new)&#39;, &#39;How do you do code reviews with this model? (new)&#39;, &#39;[dead] (new)&#39;, &#39;[dead] (new)&#39;]</td><td class="s6" dir="ltr">[&#39;Use a single shared trunk&#39;, &#39;Use feature flags to safely integrate incomplete features&#39;, &#39;Feature flag complexity and debt management required&#39;, &#39;Promote frequent and rapid integration (CI) (+)&#39;, &#39;Commit frequently (daily)&#39;, &#39;Make small, frequent commits&#39;, &#39;Encourage team collaboration and communication (+)&#39;, &#39;Reduce merge conflicts (+)&#39;, &#39;Simplifies the development workflow (+)&#39;, &#39;Mandatory code review policy&#39;, &#39;Requires strong discipline and team coordination (-)&#39;, &#39;Cultural or organizational resistance is common (-)&#39;, &#39;Use keystone interfaces (build features without UI/API wiring, test via automation, wire up only when ready) (new)&#39;]</td></tr><tr style="height: 30px"><th id="918362267R22" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">23</div></th><td class="s7" dir="ltr">Ask HN: Is anyone using lock-based version control?</td><td class="s8" dir="ltr">30677483</td><td class="s9" dir="ltr"><a target="_blank" href="https://news.ycombinator.com/item?id=30677483">https://news.ycombinator.com/item?id=30677483</a></td><td class="s10" dir="ltr">YANLIŞ</td><td class="s7" dir="ltr">[&#39;Ask HN: Is anyone using lock-based version control? (new)&#39;, &#39;Hi all,I am just curious if anyone is using any lock-based approaches to version control for collaborative production of software or other digital assets. It seems like the merge model, exemplified by Git, is ubiquitous to the point that nobody is experimenting with any other workflows.I think lock-based version control would would very well with trunk-based development. Separate devs branch from mainline, files get locked for everyone else as they are edited, and so it is necessary to work in very tight iterations and merge back to mainline very frequently.Is anyone working with a lock-based approach to version control, either for personal projects, or in an organisational setting?Thanks :)&#39;, &#39;This would never work. If someone checked out a file, locked it, and then went on vacation, this would block everyone else. Imagine if some breaking bug was in the checked out file, now you have to find some admin to remove the lock. You could put a timer on the lock, but how would this be different from git?Perforce does trunk based development and checkouts involve talking to the server (depot). This allows you to see who else has a file checked out, but doesn&amp;#x27;t block you from editing. I have used Perforce for multiple years in a thousand+ developer org, and have never actually needed to see who else has a file checked out.&#39;, &#39;We still use Microsoft Visual Source Safe for some projects :)We have a main trunk, and a branch for each major version released, upon which we apply fixes and occasionally small feature updates as requested by customers.We’re a small team, so it works pretty well for us. We’ve worked this way for 15+ years. (new)&#39;, &#39;Yes, we use locking checkout in certain situations but not for traditional source code, more for CAD files or documents. It&amp;#x27;s a fairly rare situation, though, mostly helpful for non-coders that don&amp;#x27;t understand the concept of a merge. (new)&#39;, &#39;Not software development, but most CAD version control systems are lock based. You checkout your model or assembly, lock the parts&amp;#x2F;drawings&amp;#x2F;assembly you are working on and that prevents others from working on the same bit. Some allow a level of collaboration where two people can be working on different components within the same assembly at once.Most of these version control systems are part of a larger software package call a PLM system (Product Lifecycle Management) designed to help manage all aspects of product development from concept through to manufacturing.https:&amp;#x2F;&amp;#x2F;en.m.wikipedia.org&amp;#x2F;wiki&amp;#x2F;Product_lifecycle (new)&#39;, &#39;I used to work for a firm creating software for handling patient&amp;#x27;s data in hospitals. Mainly using Xenix, all software source was controlled via the Revision Control System, part of the OS. R.C.S allowed earlier versions of source to be generated easily, when required. All devs using R.C.S accepted it and used it easily, many times each day. (new)&#39;, &#39;Didn&amp;#x27;t we had the lock based model when a lot of software development was using svn earlier on?I also still experience it on Wiki edits, and for office document management systems.\nMy experience there is that it works for a tiny amount of users, but once you start hitting the lock things get painful. (new)&#39;, &#39;&amp;gt; exemplified by GitThe predecessors, SVN and CVS, also do not use a locked checkout model. The &amp;quot;C&amp;quot; in CVS is &amp;quot;concurrent&amp;quot;: people working at the same time in multiple checked-out sandboxes (of a central repo), picking up changes with &amp;quot;cvs up&amp;quot;, which merges.Nobody in their right mind used version control with central locking in the last 35 years. (new)&#39;]</td><td class="s11" dir="ltr">[&#39;Use a single shared trunk&#39;, &#39;Use short-lived branches&#39;, &#39;Commit frequently (daily)&#39;, &#39;Cherry-pick changes to release branches&#39;, &#39;Small team&#39;, &#39;Use lock-based version control to enforce exclusive edits in trunk-based workflows (rare, mostly for non-code assets) (new)&#39;]</td></tr><tr style="height: 30px"><th id="918362267R23" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">24</div></th><td class="s2" dir="ltr">Ask HN: Difference between trunk based development vs. short living branches?</td><td class="s3" dir="ltr">33275619</td><td class="s4" dir="ltr"><a target="_blank" href="https://news.ycombinator.com/item?id=33275619">https://news.ycombinator.com/item?id=33275619</a></td><td class="s5" dir="ltr">YANLIŞ</td><td class="s2" dir="ltr">[&#39;Ask HN: Difference between trunk based development vs. short living branches?&#39;, &#39;Circa 2002 I got into developing with CVS where trunk based development with release branches was the only model that wouldn&amp;#x27;t have you pulling your hair out.https:&amp;#x2F;&amp;#x2F;trunkbaseddevelopment.com&amp;#x2F;branch-for-release&amp;#x2F;For a while after that it was CVS,  Visual Source Safe,  or Subversion and usually it was trunk based development with a very little bit of feature branches.More recently (post 2015 or so) it has always been Git.  Projects I do on my own account are still trunk based because there&amp;#x27;s no need for anything else.  For work it is always feature branches with pull requests,  largely it works pretty well.  Most of the feature branches I work on last less than 2 weeks,  often just a few days.  Once in a while there is a big one that takes a month.  I find it an easy way to work.&#39;]</td><td class="s6" dir="ltr">[&#39;Use a single shared trunk&#39;, &#39;Use short-lived branches&#39;, &#39;Use temporary release branches&#39;]</td></tr><tr style="height: 30px"><th id="918362267R24" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">25</div></th><td class="s7" dir="ltr">Why I Prefer Trunk-Based Development</td><td class="s8" dir="ltr">38228479</td><td class="s9" dir="ltr"><a target="_blank" href="https://koenvangilst.nl/blog/trunkbased-development">https://koenvangilst.nl/blog/trunkbased-development</a></td><td class="s10" dir="ltr">YANLIŞ</td><td class="s7" dir="ltr">[&#39;Why I Prefer Trunk-Based Development&#39;, &#39;This is why I set my main branches to be called &amp;quot;trunk&amp;quot;, and honestly kind of wish GitHub had just done the same rather than opt for &amp;quot;main&amp;quot;.(&amp;quot;main&amp;quot; is not _bad_, mind you) (new)&#39;]</td><td class="s11" dir="ltr">[&#39;Use a single shared trunk&#39;]</td></tr><tr style="height: 30px"><th id="918362267R25" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">26</div></th><td class="s2" dir="ltr">Feature Flags Best Practice – Overview</td><td class="s3" dir="ltr">35089651</td><td class="s4" dir="ltr"><a target="_blank" href="https://news.ycombinator.com/item?id=35089651">https://news.ycombinator.com/item?id=35089651</a></td><td class="s5" dir="ltr">YANLIŞ</td><td class="s2" dir="ltr">[&#39;Feature Flags Best Practice – Overview (new)&#39;, &#39;This post presents the overview of feature flags best practice, it will introduce feature flags technology step by step:1. What the Feature Flag is.\n2. How engineers use feature flag technology.\n3. How Feature Flags evolve into Feature Management.\n4. How Feature Management helps product and business teams.\n5. Using the lifecycle to represent feature flags throughout dev to business.## What&amp;#x27;s Feature FlagFeature flag is a modern engineering technology that decouples code deployments from feature releases, giving you control over who sees each feature and when they see it.## What a feature flag looks like```\nif(flags.newFeatureA == true){\n  runNewFeatureA();\n}```Feature flags, in their simplest form, are just if conditions in your code check whether a certain feature is enabled. This allows us to deploy features even when they are not ready, meaning that our codebase is always deployable. This, in turn, enables continuous deployment even while the team is continuously pushing small commits to the main branch.## How engineering teams use feature flagsFeature flags help engineering teams to:1. Reduce delivery risk and deployment stress. Perform Testing in Production, Targeted rollouts&amp;#x2F;release progressions before rolling out the feature to all users.\n2. Accelerate feature releases. Decouple deployments from releases, decouple features from the entire application package, and follow trunk-based development.\n3. Enable experimental feature development.\n4. Faster incident resolution. Automatically disable buggy features when key service metrics exceed a certain threshold in your APM tool.\n5. Maintain high stability. Progressively migrate from a monolith to microservices, switch to a new database, and migrate infrastructure to the cloud.## What&amp;#x27;s Feature ManagementFeature management is a new class of software development tools and techniques rooted in feature flags. It provides a holistic framework for feature flag-driven development, A&amp;#x2F;B testing, and experimentation, enabling teams to use flags on a massive scale across a variety of use cases.## How Feature Management empowers product and businessFeature management empowers all teams to deliver, control, experiment with, and monetize their software:- Help product managers to improve user experience by measuring the impact of features’ rollouts, and running A&amp;#x2F;B tests to improve feature quality.\n- Enable the Customer Success team to close more deals with live demos and feature trials at the push of a button. Help Support debug exactly which features and tests a customer has for faster resolution.\n- Give Marketing and Design the ability to fine-tune target audiences, coordinate announcements, and manage special customer programs.\n- Empower finance teams quickly get the billing report of how customers used and paid for the different features and subscriptions.## Categories and Lifecycle of Feature FlagsFeature Flag service covers the entire process from developing to delivering to customer success.[Picture] https:&amp;#x2F;&amp;#x2F;www.featbit.co&amp;#x2F;images&amp;#x2F;blogs&amp;#x2F;bestpractice&amp;#x2F;feature-flag-life-cycle-categories.pngFour categories of Feature Flag are presented in the whole lifecycle: Release, Experiment, Ops, and Permission. One feature flag can be destroyed immediately after the Release phase. It can also be kept until the end. It all depends on how your team uses it.Here&amp;#x27;s a diagram that makes it easy to understand the lifecycle of Feature Flags.[Picture] https:&amp;#x2F;&amp;#x2F;www.featbit.co&amp;#x2F;images&amp;#x2F;blogs&amp;#x2F;bestpractice&amp;#x2F;feature-flag-lifecycle-process.png## ConclusionFeature flags management empowers all teams to deliver, control, experiment with, and monetize their software. FeatBit&amp;#x27;s customers say the Feature Flags Management Service bridges the gap between engineering teams and the business.Original article: https:&amp;#x2F;&amp;#x2F;www.featbit.co&amp;#x2F;blogs&amp;#x2F;Feature-Flags-Best-Practice-I-Overview&#39;, &#39;Ditch the &amp;quot;== true&amp;quot;, it&amp;#x27;s redundant. flags.newfeatureA is already either true, or false. (new)&#39;]</td><td class="s6" dir="ltr">[&#39;Use feature flags to safely integrate incomplete features&#39;, &#39;Use feature flags to decouple deployment from release&#39;, &#39;Use feature flags to Support progressive delivery (A/B testing, dark launches)&#39;, &#39;Accelerate release cycles (+)&#39;, &#39;Enable fast and continuous feedback (+)&#39;, &#39;Promote frequent and rapid integration (CI) (+)&#39;, &#39;Trunk always ready for release&#39;, &#39;Deploy frequently and provide fast feedback&#39;, &#39;Simplifies the development workflow (+)&#39;, &#39;Support safe experimentation and rollback&#39;]</td></tr><tr style="height: 30px"><th id="918362267R26" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">27</div></th><td class="s7" dir="ltr">Ask HN: Trunk based development along with pair programming</td><td class="s8" dir="ltr">35057885</td><td class="s9" dir="ltr"><a target="_blank" href="https://news.ycombinator.com/item?id=35057885">https://news.ycombinator.com/item?id=35057885</a></td><td class="s10" dir="ltr">YANLIŞ</td><td class="s7" dir="ltr">[&#39;Ask HN: Trunk based development along with pair programming&#39;, &#39;Do you use trunk based development along with pair programming to commit straight to master?How is it working for you?&#39;]</td><td class="s11" dir="ltr">[&#39;Use pair programming or mob programming for collaboration&#39;, &#39;Commit frequently (daily)&#39;, &#39;Use a single shared trunk&#39;]</td></tr><tr style="height: 30px"><th id="918362267R27" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">28</div></th><td class="s2" dir="ltr">Isn&#39;t &quot;trunk based development&quot; just a complete crock of shit?</td><td class="s3" dir="ltr">43035628</td><td class="s4" dir="ltr"><a target="_blank" href="https://bucket.co/blog/trunk-based-development-crock-of-shit">https://bucket.co/blog/trunk-based-development-crock-of-shit</a></td><td class="s5" dir="ltr">YANLIŞ</td><td class="s2" dir="ltr">[&#39;Isn\&#39;t &quot;trunk based development&quot; just a complete crock of shit?&#39;, &#39;There&amp;#x27;s no single approach that works for everybody. What works best for you is dependent on several factors:- Whether you&amp;#x27;re primarily developing or maintaining- Size and organization of the codebase- Size of the team working with the codebase- Your production deployment strategy- Probably othersHere&amp;#x27;s the thing: I know teams using trunk-based development and teams using feature branch development, and they all work in the same organization! Like most things in software development, the best strategy for you is dependent upon your needs and you should eschew the idea that there&amp;#x27;s only one right way to do everything.&#39;, &#39;&amp;gt;  doing small short-lived branches of coherent chunks takes practice but it’s very possible.Indeed, chunking and sequencing changes is a learnable skill, like many other things such as system design, effective unit tests, or writing code that compiles in the first place. Out of those it&amp;#x27;s not the hardest - it&amp;#x27;s hardly like learning a new programming language - and it is very beneficial.&#39;, &#39;Slightly confused as to what is not trunk based development if TBD can include branches.&#39;, &#39;It was the only way you could do it (reasonably) with CVS because the branching model was primitive. (new)&#39;]</td><td class="s6" dir="ltr">[&#39;Use short-lived branches&#39;, &#39;Make small, frequent commits&#39;, &#39;Simplifies the development workflow (+)&#39;]</td></tr><tr style="height: 30px"><th id="918362267R28" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">29</div></th><td class="s7" dir="ltr">Ask HN: GitFlow or Trunk-Based Development?</td><td class="s8" dir="ltr">35698669</td><td class="s9" dir="ltr"><a target="_blank" href="https://news.ycombinator.com/item?id=35698669">https://news.ycombinator.com/item?id=35698669</a></td><td class="s10" dir="ltr">YANLIŞ</td><td class="s7" dir="ltr">[&#39;Ask HN: GitFlow or Trunk-Based Development?&#39;, &#39;curious what&amp;#x27;s your current development workflow :o) (new)&#39;, &#39;Always TBD. Anything else is a complete and utter mess.  Branch for development. Always rebased squashed and merged back to master and delete dev branch. Leaves clean git history with no mess and no merge issues. This is the way. (new)&#39;]</td><td class="s11" dir="ltr">[&#39;Use short-lived branches&#39;, &#39;Rebase before merge&#39;, &#39;Squashing commits into logical units&#39;, &#39;Simplifies the development workflow (+)&#39;, &#39;Reduce merge conflicts (+)&#39;, &#39;Use a single shared trunk&#39;]</td></tr><tr style="height: 30px"><th id="918362267R29" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">30</div></th><td class="s2" dir="ltr">Ask HN: In trunk based development, you do not use branches at all?</td><td class="s3" dir="ltr">33244710</td><td class="s4" dir="ltr"><a target="_blank" href="https://news.ycombinator.com/item?id=33244710">https://news.ycombinator.com/item?id=33244710</a></td><td class="s5" dir="ltr">YANLIŞ</td><td class="s2" dir="ltr">[&#39;Ask HN: In trunk based development, you do not use branches at all?&#39;, &#39;Of course you do - for PRs or just to self-review in some cases. (new)&#39;, &#39;We do for pull requests going back to the trunk. (new)&#39;, &#39;They commit incomplete changes directly to master after trying to make them unreachable. Personally I’d rather commit when ready, even if I’m going to be using a runtime experiment to ramp up slowly from zero. I don’t like being one mixup away from breaking prod. (new)&#39;]</td><td class="s6" dir="ltr">[&#39;Use short-lived branches&#39;, &#39;Use feature flags to safely integrate incomplete features&#39;]</td></tr><tr style="height: 30px"><th id="918362267R30" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">31</div></th><td class="s7" dir="ltr">Trunk-Based Development vs. Git Flow</td><td class="s8" dir="ltr">19551932</td><td class="s9" dir="ltr"><a target="_blank" href="https://hackernoon.com/trunk-based-development-vs-git-flow-b1b23044dfb">https://hackernoon.com/trunk-based-development-vs-git-flow-b1b23044dfb</a></td><td class="s10" dir="ltr">YANLIŞ</td><td class="s7" dir="ltr">[&#39;Trunk-Based Development vs. Git Flow&#39;, &#39;One major advantage of the gitflow&amp;#x2F;hubflow git workflows is that there is a standard way of merging across branches. For example, a &amp;#x27;hotfix&amp;#x27; branch is merged into the stable master branch  and also develop with one standard command; there&amp;#x27;s no need to re-explain and train new devs on how the branches were supposed to work here. I even copied the diagram(s) into my notes: https:&amp;#x2F;&amp;#x2F;westurner.github.io&amp;#x2F;tools&amp;#x2F;#hubflowIMHO, `git log` on the stable master branch containing each and every tagged release is preferable to having multiple open release branches.Requiring tests to pass before a PR gets merged is a good policy that&amp;#x27;s independent of the trunk or gitflow workflow decision. (new)&#39;]</td><td class="s11" dir="ltr">[&#39;Use tags for releases&#39;, &#39;Use temporary release branches&#39;]</td></tr><tr style="height: 30px"><th id="918362267R31" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">32</div></th><td class="s2" dir="ltr">Trunk-Based Development</td><td class="s3" dir="ltr">39084135</td><td class="s4" dir="ltr"><a target="_blank" href="https://trunkbaseddevelopment.com/">https://trunkbaseddevelopment.com/</a></td><td class="s5" dir="ltr">YANLIŞ</td><td class="s2" dir="ltr">[&#39;Trunk-Based Development&#39;, &#39;I work at a place that has a few very large code bases, we use trunk-based. I will never go back, &amp;quot;what is your git workflow?&amp;quot; Is a question on my list of things to ask potential employers now and the only good answer is &amp;quot;trunk&amp;quot;. So much mental load is wasted on these other strategies.&#39;, &#39;Google and Facebook both use trunk based development for nearly all code at both companies.This guide advises you to consider trunk based development if your release cycles are less than ~4 weeks. I&amp;#x27;d suggest doing it no matter what. The only place where I&amp;#x27;ve run into problems with this was managing very long term hold outs where we wanted to avoid changing user visible behavior. Instead of branches, we maintained literal copies of all the files for multiple years. I don&amp;#x27;t think revision control is the right place to solve that problem though, because there were no clear service boundaries to decide what things to pin, we just did it in an adhoc way.&#39;, &#39;I think that good tooling is a necessity to do trunk based development well - not just CI&amp;#x2F;CD and testing on PRs, but also being able to have stacks of commits in multiple PRs before landing as a whole (from ghstack, Sapling, or Graphite).Having worked at Facebook before where managing stacks of diffs was far better than GitHub, I wish that more of the improvements to the developer workflow could be open sourced beyond Sapling now that Phabricator is no longer supported.&#39;, &#39;TFA advocates strongly against long-lived branches, which I understand and agree with, but with one exception: major&amp;#x2F;LTS versions should have their own branch, so that hotfixes can be cherry-picked from main (or, rarely, applied directly to the major version branch. (new)&#39;, &#39;Nice to see this getting some treatment. It&amp;#x27;s been my preferred source control strategy at several places now -- both small and large, though nothing so large as Facebook.It has its limitations, but for the the 90+% of places that aren&amp;#x27;t operating at Facebook scale, it&amp;#x27;s probably the right choice. It doesn&amp;#x27;t eliminate merge hell, but it does localize it, making it a lot easier to resolve conflicts without accidentally undoing somebody else&amp;#x27;s work.It&amp;#x27;s especially well-suited for any projects that are in constant-iteration mode, where there&amp;#x27;s a steady stream of bugfixes and new developments getting deployed daily (or even multiple times a day).You can even manage longer-lived branches after a fashion: the cleanest pattern seems to be to capture your changes into a patch, revert your branch to the commit immediately before your changes, merge&amp;#x2F;rebase main, then apply your patch on top. This is bad and lame because it rewrites history and requires a force push to get it into the remote, but it&amp;#x27;s also nice because it keeps your changes at the tip of the branch and makes review a bit easier in e.g. GitLab.Every small shop I&amp;#x27;ve worked with that has tried to use more complex branching models eventually hoses the repo and ends up burning a lot of dev hours one day trying to make sense of a git log that looks like a diagram of network sorting. (new)&#39;, &#39;I&amp;#x27;ve been pushing and using trunk for years. To think someone looked at the graph for git-flow and said &amp;quot;yes please&amp;quot; is madness.That said, trunk-based is probably not great if you actually do need to support multiple versions of a piece of software simultaneously.&#39;, &#39;Could use a (2015) - according to the front-matter on the repo (in the master branch, natch).  It&amp;#x27;s been posted here a number of times, it was particularly popular the first posted time in 2017[0] (199 points, 208 comments).[0]: https:&amp;#x2F;&amp;#x2F;news.ycombinator.com&amp;#x2F;item?id=13514289 (new)&#39;, &#39;I’ve been pretty happy with trunk-based development in my job. It’s simple and reliable. I don’t miss alternatives in any way.A significant amount of Git-isms are based around Linux kernel needs. Which is great. But closed source and typical open source needs are pretty different, and much simpler.&#39;, &#39;(2017)Some recent discussion: https:&amp;#x2F;&amp;#x2F;news.ycombinator.com&amp;#x2F;item?id=34733805 (new)&#39;, &#39;This site has developed a lot of content without seeming to directly address the major concerns anyone coming from git flow will have. For example, their code review page does not really address how github and gitlab are both set up to support branch based review, and trunk based review is a lot harder when using those tools. Similarly, I poked around and figured out what they recommend for hotfixes, which is just fix it on trunk and cherry-pick the commit. That works sometimes, but anywhere with infrequent releases (like regulated environments or shipped software) may find that pretty painful. I suspect I could raise more issues if I put more energy into it, but it&amp;#x27;s hard to want to, given how the content is presented.Overall, this site reads like someone who&amp;#x27;s so convinced they&amp;#x27;re right that they don&amp;#x27;t bother to take other viewpoints seriously enough to actually refute them.&#39;, &#39;There is no “right” or “best” way to do this job, right? But kudos for taking a position and articulating it. (new)&#39;, &#39;I like TBD. I&amp;#x27;ve always found the difficulty was in getting people to use feature flags, and then also managing those flags.https:&amp;#x2F;&amp;#x2F;trunkbaseddevelopment.com&amp;#x2F;feature-flags&amp;#x2F; (new)&#39;, &#39;We’re considering this at my org. We’ve got a distributed backend with about 2 dozen repos, with a big web of dependencies between them.When you need to make a breaking change to one that is depended on by a lot of the other repos, it can be incredibly tedious to fix all the downstream effects.Using trunk would resolve it, but would also of course introduce other issues. (new)&#39;, &#39;How does this look like when you have multiple active versions of an application? In some cases there are apps deployed in different environments (or to different clients) in different versions and having a single place to make all commits is not feasible.How do things that have LTS versions in parallel with &amp;quot;regular&amp;quot; versions organize? (new)&#39;, &#39;There&amp;#x27;s a workflow where you commit to each release branch?I genuinely did not know that. I thought working on individual branches, merging to master, and then cutting the release branch from there (to merge back into master if any changes were found during testing) was the only major way people actually did things. (new)&#39;, &#39;Seems very similar to Fossil&amp;#x27;s philosophy, which I&amp;#x27;ve started to appreciate. (new)&#39;, &#39;Wait so no develop branch? The utility gained by having “what’s in production” and “what we’re working on” as separated feels hard to part with. (new)&#39;, &#39;No thanks.I&amp;#x27;ve worked on teams using trunk based development before and I ended up being the one having to fix other people&amp;#x27;s messes, deal with them losing work, and the absolute hell of trying to find where a bug was introduced.The only people I really want on my team are those that understand Git. And even when there are team members that don&amp;#x27;t understand Git, I sure do and can pretty easily un-eff any situation someone gets themselves into.Seriously, Git is actually simple and it should be a fundamental CS class taught at all universities.&#39;, &#39;Confusing content without any clarifying step by step. (new)&#39;, &#39;[flagged] (new)&#39;]</td><td class="s6" dir="ltr">[&#39;Accelerate release cycles (+)&#39;, &#39;Adopt CI/CD pipelines for automated integration and delivery&#39;, &#39;Automate code quality checks (linting, testing, analysis)&#39;, &#39;Automate test execution (unit, integration, e2e)&#39;, &#39;Automated build and tests always pass on the CI&#39;, &#39;Cherry-pick changes to release branches&#39;, &#39;Commit frequently (daily)&#39;, &#39;Deploy frequently and provide fast feedback&#39;, &#39;Enable fast and continuous feedback (+)&#39;, &#39;Encourage team collaboration and communication (+)&#39;, &#39;Feature flag complexity and debt management required&#39;, &#39;Feature flag complexity and debt management required (-)&#39;, &#39;Promote frequent and rapid integration (CI) (+)&#39;, &#39;Reduce merge conflicts (+)&#39;, &#39;Requires robust testing and test infrastructure (-)&#39;, &#39;Requires strong discipline and team coordination (-)&#39;, &#39;Shortens automated feedback cycles by testing each trunk commit against the main codebase through CI/CD pipelines (+).&#39;, &#39;Simplifies the development workflow (+)&#39;, &#39;Use a single shared trunk&#39;, &#39;Use feature flags to safely integrate incomplete features&#39;, &#39;Use feature flags to decouple deployment from release&#39;, &#39;Use short-lived branches&#39;, &#39;Use temporary release branches&#39;, &#39;Keep trunk updated with release fixes&#39;]</td></tr><tr style="height: 30px"><th id="918362267R32" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">33</div></th><td class="s7" dir="ltr">Show HN: New version of AutoSpotting with lots of improvements</td><td class="s8" dir="ltr">33142016</td><td class="s9" dir="ltr"><a target="_blank" href="https://aws.amazon.com/marketplace/pp/prodview-6uj4pruhgmun6">https://aws.amazon.com/marketplace/pp/prodview-6uj4pruhgmun6</a></td><td class="s10" dir="ltr">YANLIŞ</td><td class="s7" dir="ltr">[&#39;Show HN: New version of AutoSpotting with lots of improvements (new)&#39;, &#39;These are the main changes in this new stable release. Some were previously available in the Open Source trunk code, while others were built over the last couple of weeks:- Added support for recently launched EC2 instance types, including up to R6a, released in July 2022.- Significantly lower Spot interruption rates in the default configuration by1.switching to the EC2 Fleet API in instant mode with the capacity-optimized-prioritized allocation strategy so that we now avoid instance types with a large likelihood of interruption.2.increasing instance type diversification by relaxing the instance type selection logic. Previously we enforced instance types with at least as much EBS bandwidth, but this is now off by default.3.Disabling the handling of Rebalancing recommendation events in the default configuration, which have been seen to significantly increase interruption rates.- Add support for biasing instance types selection to newer instance generations such as C7g, which offer significant performance improvements but with a slight cost increase. This is now turned on by default but can be turned off if lowest cost needs to be prioritised. The way this works is by penalising older generations when doing cost comparisons by 10% of the Spot price for each older generation, while the current generation isn&amp;#x27;t penalised at all.- Lower AutoSpotting costs, by considering the on demand price of the initial instance type configured on the group instead of the on-demand price of the Spot instance type that was launched to replace it.- Fixed handling of Allowed&amp;#x2F;Disallowed InstanceTypes in the default configuration, which was previously allowing all instance types and ignoring the list of Disallowed instance types.- Add support AutoScaling Group-based CodeDeploy deployment groups by triggering CodeDeploy deployments on new Spot instance launches so we no longer depends on tag-based deployment groups.This is a major release and I recommend anyone using AutoSpotting to give it a try. For now this is only available from the AWS Marketplace, but I plan to eventually release this functionality to the Open Source code. (new)&#39;]</td><td class="s11" dir="ltr">[&#39;Trunk always ready for release&#39;, &#39;Adoption of practices from known OSS projects&#39;]</td></tr><tr style="height: 30px"><th id="918362267R33" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">34</div></th><td class="s2" dir="ltr">Modern Trunk-Based Development</td><td class="s3" dir="ltr">33246219</td><td class="s4" dir="ltr"><a target="_blank" href="https://reviewpad.com/blog/modern-trunk-based-development/">https://reviewpad.com/blog/modern-trunk-based-development/</a></td><td class="s5" dir="ltr">DOĞRU</td><td class="s2" dir="ltr">[&#39;Modern Trunk-Based Development&#39;, &#39;We have been working with teams doing trunk-based dev and actually applying some of the principles to our open-source repos. This articles walks through how we automate PR merges and reduce unnecessary builds using Reviewpad.&#39;, &#39;Author of the post here! Happy to answer any questions.TLDR: Not all pull requests are the same!We are working on a way to specify and automate PR workflows so that you can separate the code review and the PR approval&amp;#x2F;merge steps.This way you can automate which PRs require code reviews and which don&amp;#x27;t.We show how we are using Reviewpad (as a GitHub Action) to automatically merge basic changes and also how to use it to ship PRs ensuring the CI passed. (new)&#39;]</td><td class="s6" dir="ltr">[&#39;Automate code quality checks (linting, testing, analysis)&#39;, &#39;Automate test execution (unit, integration, e2e)&#39;, &#39;Automated build and tests always pass on the CI&#39;, &#39;Adopt CI/CD pipelines for automated integration and delivery&#39;, &#39;Rely on modern Git-based collaboration platforms&#39;, &#39;Use of short-lived pull requests from forks as an adaptation of OSS-style contribution workflows in Trunk-Based Development. (OSS)&#39;, , &#39;Simplifies the development workflow (+)&#39;, &#39;Automate PR merge and approval workflows to distinguish which pull requests require code review and which can be auto-merged (new)&#39;]</td></tr><tr style="height: 30px"><th id="918362267R34" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">35</div></th><td class="s7" dir="ltr">The benefits of trunk-based development</td><td class="s8" dir="ltr">44655804</td><td class="s9" dir="ltr"><a target="_blank" href="https://thinkinglabs.io/articles/2025/07/21/on-the-benefits-of-trunk-based-development.html">https://thinkinglabs.io/articles/2025/07/21/on-the-benefits-of-trunk-based-development.html</a></td><td class="s10" dir="ltr">DOĞRU</td><td class="s7" dir="ltr">[&#39;The benefits of trunk-based development&#39;, &#39;&amp;gt; Note that the Pull Requests were introduced by the Open Source Software community. It allows core teams to maintain a system and accept contributions from the outside world. The outside world is generally perceived as low-trust. Therefore, we want to verify those contributions. Pull Requests are pretty helpful in that regard. However, in a closed-source corporate setting, the Pull Request model essentially indicates that the team owns the codebase, but it is not allowed to contribute.I think this is a very lopsided way of looking at pull requests. They are about a lot more than just trust. Reviewing and being reviewed is a great way of learning from colleagues, making common practices gel in a team, and keeping up to date with changes to the codebase. It’s not just a barrier.&amp;gt; money stuck into the system. It is stuck because the organisation invested considerably in creating all this code on parallel branches. However, as long as this code is not merged into mainline, deployed in production and released to users, it does not generate any revenue. Therefore, it is money stuck in the system. But, because we have less WIP, we create less inventory. As such, we have less invested money stuck in the system.I’ve been telling people that work in flight should be minimised for a long time, but this is the first time I’ve heard the inventory metaphor and I like it. It’s a similar metaphor to tech debt. (new)&#39;, &#39;Used trunk-based dev a lot. Not a fan. It sounds good on paper, but in practice, it gets messy fast and code quality is hard to maintain, especially when teams are remote.What actually works is trunk-based deployments — keep main always deployable, and ship from there. Simple.PRs, are underrated. They’re great for sharing context. You get inline comments, CI runs, you can test stuff in isolation by spinning up infra, and teammates actually see what’s changing.Stacked diffs make juggling multiple PRs manageable. And yeah, PR reviews can slow you down, but honestly, I think that&amp;#x27;s a plus. Slowing down just enough to have another human look at the code pays off more often than not.&#39;, &#39;I wonder how all these absolutist methodologies really work when you take subjectivity and our general inability to measure anything reliably away? I say this because we&amp;#x27;ve tried all of them after someone read an article on a blog saying it&amp;#x27;d solve all our problems. And we always have the same problems afterwards despite people promoting that it solved them. Sometimes even worse ones.The root cause in my company is we hire the lowest cost outsourcing outfit we can find, which hires inexperienced juniors and pretends they are senior and has a huge staff turnover because who the hell wants to work like that for more than 12 months. But of course changing the repo structure and process will compensate for that.My observation is that a good engineering team will self-organise a methodology that works. The methodology is unimportant compared to getting a good engineering team. I am fortunate that I work in a small niche pocket in the organisation that has good engineers and has resisted normalising with the process churn of the rest of the organisation.We run a &amp;quot;dark ages&amp;quot; team really. We were on SVN until 2020-ish, because, well it worked fine for us. Now we&amp;#x27;re on github on commandment but it is used like SVN. We have light feature branches. Master is always stable. Releases are tagged off master. At no point do we use any other github features not even PRs. CI is makefiles. Push to ECR&amp;#x2F;S3 by human. Deployment is makefiles. Comms is email because Slack is too distracting and demands immediacy. Issue tracking is a 17 year old JIRA project with a default workflow. We have the lowest defect rate, the lowest time to market and highest ROI per head in the entire org and we don&amp;#x27;t have or need a platform&amp;#x2F;sre&amp;#x2F;devops team supporting us.We are a disliked because we didn&amp;#x27;t do anything for over 10 years other than deliver software. (new)&#39;, &#39;&amp;gt; With trunk-based development teams, managing technical debt becomes a non-issue. It just happens.Unless it doesn&amp;#x27;t happen. Issues that are dealt with automatically are those that would break the build, or make tests or linting checks fail; everything else can simply accumulate without anyone &amp;quot;wasting time&amp;quot; on it.Technical debt is often recognized retroactively (e.g. there is a new foreign customer and not enough time to write thousands of neglected translated labels and messages).&#39;, &#39;It probably depeds on the kind of software you create, but in our case:When i add non-trivial code I want others of my team to review it first. When it is on trunk, it gets less easier to refactor as others already might use it. In this sense using a MR is really good way to get some quality checks before it goes to main and needs to be supported (in most cases) indefinitely. Next, we have system tests that i really want to avoid breaking on main and getting EVERYONE stuck.The problem arises if I keep that branch for more than a week. Merge conflicts get harder, the financial investment is not leveraged, etc etc.The problem is with long lived branches. This is something you should avoid, you can take it to the extreme, no branches. But extreme is almost never good.PS CC is really good at rebasing and resolving merge conflicts. (new)&#39;, &#39;I don&amp;#x27;t get this trust discussion. I don&amp;#x27;t trust myself not to do a mistake, why should I trust somebody else.Also - while pair programming is great - it does not replace a code review. When you do pair programming you start working on the problem at the same time, you get tiered and annoyed of the problem at the same time. You want to go to lunch break at the same time. All reasons to slip in a sloppy solution and convince each other it is actually ok.While doing code review you get a fresh perspective on the matter. (new)&#39;, &#39;After a couple of decades in the Danish software industry I&amp;#x27;ve come to accept that there is only trunk-based development (COME AT ME!). Feature branches, set releases and so on are fake safety gaps that people add when they don&amp;#x27;t trust themselves and&amp;#x2F;or their developers. These days I view it similar to someone who won&amp;#x27;t deploy changes on fridays because they fear for their weekend. If you&amp;#x27;re too afraid to deploy on a friday, then you should not be allowed to deploy on a monday. Similarily, if you&amp;#x27;re not brave enough to push changes to production, then your changes aren&amp;#x27;t ready.Of course I don&amp;#x27;t actually think there is a religion on how to do these things, but I&amp;#x27;ve never seen any particular quality added by people doing quarterly releases from a feature branch. For the most part I think this part at the very beginning of the article explains a lot of the reason as to why that is:&amp;gt; When we do trunk-based development, the WIP we commit gets used, before any actual user sees it, by our whole team.In my eyes all of it comes down to management much more than deployment strategies. The disadvantage of feature branching is that it&amp;#x27;s very easy for management to cut costs on testing. The disadvantage of trunk-based development is that it requires functional teams of people who can actually work together and accept the &amp;quot;norms&amp;quot;.&#39;, &#39;I&amp;#x27;m a big fan of trunk based development in the Churchillian sense. It&amp;#x27;s the worst form of development, except for all the others.I don&amp;#x27;t think it&amp;#x27;s for every project, or even every feature in a given project. But there&amp;#x27;s a niche it works best for, and that niche happens to represent a massive percentage of all software engineering.The niche is, you&amp;#x27;re building a web app. It&amp;#x27;s some shitty Web 8.0 version of a Craigslist or something. No one wants to pay for formalized testing. No one really wants to spend a lot of time on quality. Arguably it&amp;#x27;s not that important to users. The year is Enshittified 2030 and they&amp;#x27;re lucky if they can even log into their online banking, let alone slide into someone&amp;#x27;s DMs on your platform.What&amp;#x27;s the solution? TBH it&amp;#x27;s not tripling down on good engineering process.  (Don&amp;#x27;t get me wrong, good engineering process absolutely has a role, I&amp;#x27;m merely suggesting that as you move from flight control software to online classifieds to your neighbor&amp;#x27;s recipe blog, that role diminishes in favor of less formal feedback.) The solution is radically forcing the code into the light of day in front of people who can say or do something about the biggest problems. The minor bugs will probably slip through this net, but the really nasty ones WILL get worked out if people on your team have to deal with them first, followed by an &amp;#x27;insider&amp;#x27; circle of users, finally followed by the general public.That translates to certain buzzwords actually representing great ideas in this type of development, such as: feature flags, CI, pilot rollouts, and... trunk-based development.Just get the code&amp;#x2F;feature out in front of a couple people who matter, as early as the day it was written, and keep expanding until you&amp;#x27;re public.&#39;, &#39;After having worked four years with trunk based development and enjoying it very much, I worked on a project were it was required to have one branch per feature for review purposes. It caused lots of delays, temporary work arounds, merge conflicts, moving changes between branches, bugs being introduced, due to reviews being delayed. I got the impression it made development twice as slow and did not improve code quality.&#39;, &#39;It&amp;#x27;s funny as i get older to see how all these patterns just repeat themselves. When i started out i worked in a team that used subversion and it was by default trunk-based development flow. no code reviews except the single big changeset from all devs. it was how things were done back then by many teams. Then there was a shift towards feature-request-based development with the rise of git and github. trunk-based development was now seen as &amp;quot;unprofessional&amp;quot; in corporate. totally fine and i was there to teach this mind shift.while the feature-branch-based flow solved some problems it introduced many more like stall branches and out-of-sync code. this became the default as most devs simply weren&amp;#x27;t aware or had the discipline to merge early and cut their &amp;quot;tickets&amp;quot; to an appropriate size.mostly for compliance reasons in corporate and big teams i would still advise feature-request-based flow. but as another colleague noted here - it slows you down and if it&amp;#x27;s a one or two people shop &amp;#x2F; product you will reap more benefits by doing basic trunk-based flow.&#39;, &#39;What they are describing as &amp;quot;Trunk-Based Development&amp;quot; seems a little extreme, and frankly, I&amp;#x27;m not sure how achievable it is. Generally, when I&amp;#x27;ve seen&amp;#x2F;implemented TBD it has involved Pull Requests and code reviews (they seem to imply it shouldn&amp;#x27;t). With their definition, I think a few issues arise:\n* Even if you think you can have high quality without PRs, in many industries, it&amp;#x27;s part of security&amp;#x2F;compliance.\n* They say that PRs undermine shared ownership, when actually, PRs done right can enable shared ownership (yes, I can&amp;#x27;t just merge whatever I want, but also, I get to help ensure no one merges whatever they want).They also say that &amp;quot;no branches are created&amp;quot;. In reality, I don&amp;#x27;t see how you do any modern development without branches. If anything, contributors need a local branch that is then merged to the trunk (unless, somehow, everyone is live-editing the main branch?). The idea of TBD is just to have smaller, short-lived branches that are frequently merged into main (very doable with pull requests).&#39;, &#39;I cannot imagine any advantage of this extreme description of trunk based development over trunk based development with commit stack workflows. You dont have long lived wip but you have draft commits that can mature and be worked on in parallel (also critical for coding agents) constantly auto rebasing on each other. i cannot count the number of bugs that i found before something landed on trunk just because i let “finished” work mature in draft for a bit while i work on the next task. this is especially important if the features have overlap or include ui changes that could have glitches undetectable by tests. similarly you don’t have prs but you have review stacks that are tested and evaluated in any amount of detail required by the context BEFORE they become the new trunk tip.  (only fast forward, no merge commits)&#39;, &#39;&amp;gt; Note that the Pull Requests were introduced by the Open Source Software community.&amp;quot;Pull requests&amp;quot; by that name maybe. But code reviews existed way before that. As soon as code was written, programmers started to ask for peer reviews of their code.- Design and code inspections to reduce errors in program development. 31 December 1976. https:&amp;#x2F;&amp;#x2F;ieeexplore.ieee.org&amp;#x2F;document&amp;#x2F;5388086But I guess that today&amp;#x27;s programmers think that software engineering was created in 2010. (new)&#39;, &#39;OK it is faster as article claims but I want to see the tickets, team composition, how long they work together, team dynamics, assholes blocking PRs vs assholes pushing stuff to trunk „because they know better”.Amount of work that was done and amount of bug reports and anyone can write that their customers are happy.If they worked previously on PRs some numbers how that was going compared to what they do now.For me it is just fluff and I wasted time reading it. (new)&#39;, &#39;A decade in software development taught me: it always depends. It’s never a good idea to speak in absolutes.Your development workflow depends on your product, on your team, their skills, on your organization and so on.As with everything you need to carefully evaluate, if Trunk-based development is a good fit for your product, your team and your organizational structure. Sometimes it fits well, sometimes it’s not a good fit.I think a lot of people dismiss gitflow and its feature-branched model as too complicated. Yes, it feels so slow, right?But it gives inexperienced teams a very clear and documented workflow, especially so, if you need to support multiple versions of your product in the wild. It clearly dictates how to do bugfixes and hotfixes, that need to be done in multiple releases of your product.Could you achieve the same with Trunk-based development? Maybe? Could an inexperienced team come up with it on their own? I don’t think so.See, it always depends.&#39;, &#39;Is it really true that Google has no feature branches? Sounds unlikely to me. How do you do code reviews for example if everything goes straight to main? (new)&#39;, &#39;TBD as described here is what everyone basically used to do in the olds with SVN (because branches were so hard). PRs are objectively better, just have to complete them on a regular basis. The article conflates PRs with long running branches. (new)&#39;, &#39;The article title isn&amp;#x27;t misleading at all: they list the (subjective) benefits without listing any of its disadvantages. Sure, that list is useful for some trivial projects.But good luck selling that to some regulated companies where basic risk assessment is a must. Tell a financial institution you&amp;#x27;ll _never_ fuck their money transfer pipeline, because you don&amp;#x27;t do code reviews, you &amp;quot;deliver value&amp;quot; even on Fridays and your methodology avoids all sort of errors or malicious modifications.IMHO, trunk based development removes some safety. Software development is a complex task and we all risk to break things even on a good day. You&amp;#x27;re not smarter by removing safety from the process.&#39;, &#39;&amp;gt; When we do trunk-based development, the WIP we commit gets used, before any actual user sees it, by our whole team.I think this is where I&amp;#x27;m stuck.  I rarely work in projects where my team can &amp;#x27;use&amp;#x27; the code in any meaningful way.  When I wrote code for accountant my team wasn&amp;#x27;t going to be able to tell if the wash sale calculations went wonky.&#39;, &#39;If the whole team is available in one physical office, a centralized model like perforce can run circles around the various git flows. You typically see this in places like game development.Being able to lock files centrally is a massive advantage as long as you have to be at the office to do it. This forces conflict resolution in a much more direct and immediate way than the passive aggressive PR submissions that are eventually reviewed for conflicts after all parties have already burned untold amounts of energy on potentially unmergable code. (new)&#39;]</td><td class="s11" dir="ltr">[&#39;Accelerate release cycles (+)&#39;, &#39;Adopt CI/CD pipelines for automated integration and delivery&#39;, &#39;Automate code quality checks (linting, testing, analysis)&#39;, &#39;Automate test execution (unit, integration, e2e)&#39;, &#39;Automated build and tests always pass on the CI&#39;, &#39;Commit frequently (daily)&#39;, &#39;Deploy frequently and provide fast feedback&#39;, &#39;Enable fast and continuous feedback (+)&#39;, &#39;Encourage team collaboration and communication (+)&#39;, &#39;Enforce discipline for stable builds and testing&#39;, &#39;Feature flag complexity and debt management required&#39;, &#39;Improve software quality and stability&#39;, &#39;Integrate CI/CD tools&#39;, &#39;Make small, frequent commits&#39;, &#39;Promote frequent and rapid integration (CI) (+)&#39;, &#39;Promote shared or collective code ownership&#39;, &#39;Reduce merge conflicts (+)&#39;, &#39;Requires robust testing and test infrastructure (-)&#39;, &#39;Requires strong discipline and team coordination (-)&#39;, &#39;Shortens automated feedback cycles by testing each trunk commit against the main codebase through CI/CD pipelines (+).&#39;, &#39;Simplifies the development workflow (+)&#39;, &#39;Small team&#39;, &#39;Support safe experimentation and rollback&#39;, &#39;Trunk always ready for release&#39;, &#39;Use a single shared trunk&#39;, &#39;Use feature flags to safely integrate incomplete features&#39;, &#39;Use feature flags to Support progressive delivery (A/B testing, dark launches)&#39;, &#39;Use feature flags to decouple deployment from release&#39;, &#39;Use short-lived branches&#39;, &#39;Use tags for releases&#39;, &#39;Avoid big-bang merges&#39;, &#39;Use commit stack workflows (stacked diffs) to mature and review changes before merging to trunk (new)&#39;, &#39;Pilot rollouts to internal users before public release as part of trunk-based delivery (new)&#39;]</td></tr><tr style="height: 30px"><th id="918362267R35" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">36</div></th><td class="s2" dir="ltr">Trunk-Based Development</td><td class="s3" dir="ltr">13514289</td><td class="s4" dir="ltr"><a target="_blank" href="https://trunkbaseddevelopment.com">https://trunkbaseddevelopment.com</a></td><td class="s5" dir="ltr">DOĞRU</td><td class="s2" dir="ltr">[&#39;Trunk-Based Development&#39;, &#39;This workflow, like all others, is just a formalization of some reality. The reality is that many organizations and teams run on nothing but trunk - and it more-or-less works on them. Some teams work by building blocks separately and then joining them together; other prefer to hammer away on a problem all together. Both approaches work. What worries me are emotional claims that the other approach is fundamentally flawed, or that some git workflow is The One True Way.I&amp;#x27;ve seen feature branches get stuck in review for weeks. I&amp;#x27;ve seen trunk-only developers not knowing how to merge a branch back to trunk. I&amp;#x27;ve seen trunks brought into a state of disarray and never fixed again. I&amp;#x27;ve seen svn-only devs get completely bogged down and confused by a git wofkflow.Trunk-only is a reality. Not a reality some of us would want to live it - but one that nevertheless exists. (new)&#39;, &#39;&amp;quot;The core requirement of Continuous Integration that all team members commit to trunk at least once every 24 hours.&amp;quot;Continuous integration is a means to an end, not an end in itself. (new)&#39;, &#39;&amp;gt; Trunk Based Development is a key enabler of Continuous Integration, and by extension Continuous Delivery.Quite false. How do you expect developers to take you seriously when you essentially say &amp;quot;you can&amp;#x27;t properly do CI&amp;#x2F;CD with your current approach&amp;quot;? I sure am enjoying CI&amp;#x2F;CD right now.Trunk-based development seems to rely heavily on feature flags, which are a huge source of complexity and inconsistency. Even when useful, they&amp;#x27;re liabilities; not assets.git-flow (and variations) is simple, enables consistent codebase state, makes no assumptions about your codebase&amp;#x2F;infrastructure, and allows you to know the exact state of production&amp;#x2F;staging.Finally, as it happens so often with open source projects and initiatives, first thing I should see is a big &amp;quot;Why&amp;quot;. Why do I want this? Why are the alternatives inferior?&#39;, &#39;Puppet Labs’ recently published State of DevOps (2016) report specifically calls out trunk-based development as a leading indicator of high performing organizations [1].[1] https:&amp;#x2F;&amp;#x2F;puppet.com&amp;#x2F;resources&amp;#x2F;white-paper&amp;#x2F;2016-state-of-devop...&#39;, &#39;Correct me if I&amp;#x27;m wrong but isn&amp;#x27;t this just a form of centralised version control? If this is a better approach for many teams, perhaps this an indication that DVCS weren&amp;#x27;t the silver bullet they were hyped up to be.Aside from that, in my opinion the whole centralised version control vs. decentralised version control, and all the variants thereof, miss the bigger issue. Keeping track of the history of a file, and the authors of the changes, is trivial for any version control system. The real challenge is in resolving merge conflicts, and it&amp;#x27;s the low level of sophistication in merge tools that is the real bottleneck here. That&amp;#x27;s why I think tools like Semantic Merge are far more important to a development workflow than SVN vs Git vs Mercurial. It relies on the merge tool understanding the structure of code rather than treating it as an ordinary text file. Similar tools could be built for any language that offers a &amp;#x27;compiler as a service&amp;#x27; (such as RLS for Rust).https:&amp;#x2F;&amp;#x2F;www.semanticmerge.com&amp;#x2F; (new)&#39;, &#39;The suggestion that feature branches hinder CD is just untrue, at least in my experience. To me, this seems like a silly restriction to put on such a critical tool (the scm) which is designed to support unlimited flexibility. (new)&#39;, &#39;With a sentence like:&amp;quot;\nIt has been a lesser known branching model of choice since the mid-nineties, and considered tactically since the eighties.\n&amp;quot;Given:The Release Engineering of 4.3BSD\nhttps:&amp;#x2F;&amp;#x2F;docs.freebsd.org&amp;#x2F;44doc&amp;#x2F;papers&amp;#x2F;releng.html\n1989concerning a key software system and part of software history, \nreleased in 1986, which states:&amp;quot;\nFor the 4.3BSD release, certain users had permission to modify the master copy of the system source directly. ... The development phase continues until CSRG decides that it is appropriate to make a release.\n&amp;quot;,that the rcs tools of the time basically didn&amp;#x27;t even support branches natively,\nand this model is followed to this day by the direct descendants of this projectI&amp;#x27;m prone to think that.. well. Hmm. (new)&#39;, &#39;We currently use short-lived feature branches, merged via Pull Requests (+ review &amp;#x2F; automated testing) into the main development line. This way, we can communicate changes in a detailed manner before they are added to the product and make sure there is no unfished or bad code in the main branch. (The dev team is small, 5-8 devs).I don&amp;#x27;t see (yet?), what benefits TBD would provide in such a setup. (new)&#39;, &#39;This is what I do when I can get away with it. Suitable for smallish teams.All developers sit in the same branch; changes and conflicts are visible (and resolved) immediately. All work takes place there including bug fixes.When we branch out for release; the focus is on disabling unwanted features. Actual development work + &amp;quot;hardening&amp;quot; is done in the main trunk before the branch. (new)&#39;, &#39;Trunk based development works well on any scm that sucks at branching. Perforce, subversion etc.But, on git, using GitHub-Flow is far superior.The two poster children for TBD do not use git. Don&amp;#x27;t cargo cult their process without understanding the unique problems they have that you don&amp;#x27;t.Edit: downvotes on HN? This isn&amp;#x27;t Reddit, and I&amp;#x27;m advocating github flow, not git flow.GitHub flow is trunk based development but with all work in feature branches that live for less than s day or two, instead of branch by abstraction in the core code. That&amp;#x27;s it!&#39;, &#39;I described something that seems very similar years ago[1] (in response to git-flow), however I&amp;#x27;ve since come up with something better: I think knowing how to get things live is important, and the entire development process should reflect that -- too many people have a &amp;quot;code cut&amp;quot; that takes days or even weeks, and that&amp;#x27;s despite using the latest and greatest CI tools.A lot of the problems may sound familiar: How do we test something? How do we know it&amp;#x27;s good enough? We have a UAT step, but it doesn&amp;#x27;t find all the problems, so do we need more tests? To be more careful?My approach[2] turns the entire problem into a software problem, and it&amp;#x27;s proving very successful to me (faster request turnaround, fewer problem reports post-deploy, and so on). Being able to select a &amp;quot;git branch name&amp;quot; for a specific user and get acceptance is powerful.[1]: https:&amp;#x2F;&amp;#x2F;news.ycombinator.com&amp;#x2F;item?id=6125964[2]: https:&amp;#x2F;&amp;#x2F;news.ycombinator.com&amp;#x2F;item?id=11190540 (new)&#39;, &#39;We have a smallish team working on web apps and use a trunk-based-development branching strategy. Not really to do with helping CI&amp;#x2F;CD.The advantage we see is that new developers can start developing as soon as they clone the repository, without needing to switch to the &amp;#x27;development&amp;#x27; branch. This is particularly useful when on boarding new developers who are inexperienced with Git. I found that when using Git Flow that the (stable) master branch frequently ends up out-of-date when developers are required to remember to merge into it releases into it.Diagram of our branching strategy:\nhttps:&amp;#x2F;&amp;#x2F;gist.github.com&amp;#x2F;CameronWills&amp;#x2F;abf9e307669b1005c88ef82...&#39;, &#39;TLDR: instead of using diffs of changed lines in branches, use &amp;#x27;if&amp;#x27; statements in code to make Enterprise Continuous Integration gods happy. (new)&#39;, &#39;In subversion the only way I can possible develop with sanity is in an &amp;quot;unstable trunk&amp;quot;. Branch off releases N weeks before shipping, and have only the requirement that trunk passes automated tests while release branches are manually tested. Obviously you don&amp;#x27;t release more than say once every month or two, but that&amp;#x27;s more than enough for most.I&amp;#x27;m honestly not sure if the site is satire?No one develops in long lived feature branches in svn (rather, everyone does, but most only try it once before they realize the pain of trunk based dev is much smaller than that of svn merging).&#39;, &#39;One of the authors here. Ask questions :) (new)&#39;, &#39;Trunk only goes well with continuous deployment.If each increment in deployment is small enough, then you know exactly when things break and rollbacks are easy.The 3-2-1 system where you develop for 3 months, then merge for 2 months, then debug in production for 1 month, is a real drag, and doesn&amp;#x27;t lend itself to quick feedback at all.For a software looking for product market fit with ultra short cycles, I would absolutely choose trunk only.For engineering projects in areas where cycles are months, or years, more traditional branching makes more sense. (new)&#39;, &#39;The Envy configuration management system for Smalltalk worked like this. As you were working, you could see if someone had changed code &amp;quot;nearby&amp;quot; (same class, same category, same protocol) and you could review it and merge it in.Perforce provides something with the same effect. If you periodically get the most recent revision, you can see files with collisions in your change sets, then merge them in. (new)&#39;, &#39;I read Drunk-Based Development and was a bit disappointed. I can get awesome ideas while very tired and usually write them down, but a few weeks later, even though I was super exited when I wrote it down, it no longer makes any sense ... (new)&#39;, &#39;If there was indeed a superior way of developing software, why doesn&amp;#x27;t anyone take this knowledge and out-compete for example Linux? It has literally hundreds of branches of all kinds (stable branches, feature branches, test branches), this should be easy pickings! Or out-compete Google or Microsoft which, contrary to whats said in this article, use branches and probably in all their big projects. Sorry, I don&amp;#x27;t buy it. I suspect that if you are religiously against branches you will just have to re-invent them by some other name. (new)&#39;, &#39;&amp;gt;  Google do Trunk Based Development and they have 25000 developers and QA automators in that trunkFor some stuff, butIs Android trunk-only? No.Is V8 trunk-only? No.Is Chrome trunk-only? No.Those have release branches.---Some software works with trunk-only paradigm, some does not. A rule of thumb is whether your customer-facing distribution is SaaS&amp;#x2F;web-based.If you&amp;#x27;re making Google Search, you do it in a trunk. If you&amp;#x27;re making Google Chrome, you don&amp;#x27;t.&#39;]</td><td class="s6" dir="ltr">[&#39;Commit frequently (daily)&#39;, &#39;Promote frequent and rapid integration (CI) (+)&#39;, &#39;Trunk always ready for release&#39;, &#39;Use a single shared trunk&#39;, &#39;Use feature flags to safely integrate incomplete features&#39;, &#39;Feature flag complexity and debt management required&#39;, &#39;Shortens automated feedback cycles by testing each trunk commit against the main codebase through CI/CD pipelines (+).&#39;, &#39;Reduce merge conflicts (+)&#39;, &#39;Encourage team collaboration and communication (+)&#39;, &#39;Small team&#39;, &#39;Use short-lived branches&#39;, &#39;Use temporary release branches&#39;, &#39;Automate test execution (unit, integration, e2e)&#39;, &#39;Automated build and tests always pass on the CI&#39;, &#39;Enable fast and continuous feedback (+)&#39;, &#39;Simplifies the development workflow (+)&#39;, &#39;Cherry-pick changes to release branches&#39;]</td></tr><tr style="height: 30px"><th id="918362267R36" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">37</div></th><td class="s12" dir="ltr">Trunk-based development vs. long-lived feature branches</td><td class="s13" dir="ltr">37559862</td><td class="s14" dir="ltr"><a target="_blank" href="https://ardalis.com/trunk-based-development-vs-long-lived-feature-branches/">https://ardalis.com/trunk-based-development-vs-long-lived-feature-branches/</a></td><td class="s15" dir="ltr">DOĞRU</td><td class="s12" dir="ltr">[&#39;Trunk-based development vs. long-lived feature branches&#39;, &#39;Was this article written by ChatGPT? It&amp;#x27;s the same wishy-washy style. Ignore the article, the actual answer is always trunk-based development. Long lived feature branches will always come back to bite you.&#39;, &#39;&amp;gt; Branching strategies like Git Flow popularized this approach, and it&amp;#x27;s extremely common in open source software, where typically community contributors do not have mainline access, and so much create branches and make pull requestsNo? I thought Git flow had feature branches, but those were not supposed to live long, just like in every case. Long-lived feature branches should get long-lived by necessity (someone working a long time on a feature that can&amp;#x27;t or shouldn&amp;#x27;t be cut down), not by choice. In open source, feature branches are long-lived because either they don&amp;#x27;t get reviewed or the contributor lost interest&amp;#x2F;does not have the time to finish it. They didn&amp;#x27;t choose to make those branches long-lived.Maybe I just misunderstand what &amp;quot;long-lived&amp;quot; means in this context. (new)&#39;, &#39;https:&amp;#x2F;&amp;#x2F;trunkbaseddevelopment.com is probably a good resource to look at. Long lived feature branches have never worked well in my experience. (new)&#39;, &#39;The long-lived feature branch &amp;quot;pros&amp;quot; made me shiver. I hope I never work in an environment like that again (new)&#39;, &#39;You can enjoy the benefits of both approaches by adopting trunk-based releases. In our experience, we make small pull requests (like short lived feature branches) on GitHub, each focusing on a complete feature or a segment of it.GitHub Actions automatically test these pull requests and create temporary environments for further testing. If all tests pass, the code enters the merge queue and gets released as soon as it&amp;#x27;s merged into the main branch. We release every commit, keeping the main branch&amp;#x27;s release log tidy. We also use a mono-repo and implement caching, ensuring that only the modified code gets packaged and released.&#39;, &#39;Long lived means gigantic. It’s not a bad idea if you have a decent test suite. But if you don’t have one it’s too risky and can easily get out of control. (new)&#39;, &#39;Full Title: &amp;quot;Trunk-Based Development vs. Long-Lived Feature Branches: Which One is Right for Your Software Team?&amp;quot;&#39;, &#39;Maybe there is a middle ground, such as creating &amp;quot;v2&amp;quot; (or whatsoever) folder with the newest changes where you can easily switch between the old and the new functionality. (new)&#39;, &#39;TLDRTrunk-based development = putting unfinished work in the team&amp;#x27;s shared branch.Feature-branches = finishing your work first.Anyone who&amp;#x27;s ever completed a complex PR knows how much plans change over the course of the work. Obviously those immature stages shouldn&amp;#x27;t be shared with the team, let alone be in main, whether behind feature flags or not. (new)&#39;]</td><td class="s16" dir="ltr">[&#39;Use short-lived branches&#39;, &#39;Use of short-lived pull requests from forks as an adaptation of OSS-style contribution workflows in Trunk-Based Development. (OSS)&#39;, &#39;Automate test execution (unit, integration, e2e)&#39;, &#39;Automate code quality checks (linting, testing, analysis)&#39;, &#39;Adopt CI/CD pipelines for automated integration and delivery&#39;, &#39;Trunk always ready for release&#39;, &#39;Deploy frequently and provide fast feedback&#39;, &#39;Make small, frequent commits&#39;, &#39;Reduce merge conflicts (+)&#39;, &#39;Simplifies the development workflow (+)&#39;, &#39;Promote frequent and rapid integration (CI) (+)&#39;, &#39;Shortens automated feedback cycles by testing each trunk commit against the main codebase through CI/CD pipelines (+).&#39;, &#39;Use a single shared trunk&#39;, &#39;Use of automated merge queues to release code as soon as it is merged into the main branch (new)&#39;]</td></tr></tbody></table></div>